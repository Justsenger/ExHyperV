
================================================================================
FILE: App.xaml.cs
================================================================================

﻿using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;
using System.Xml.Linq;
using ExHyperV.Tools; 

namespace ExHyperV;

public partial class App
{
    private const string DefaultLanguage = "en-US";
    private const string ConfigFilePath = "Config.xml";

    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        string targetLanguage;
        if (File.Exists(ConfigFilePath))
        {
            var configLanguage = ReadLanguageFromConfig();
            if (IsLanguageSupported(configLanguage))
            {
                targetLanguage = configLanguage;
            }
            else
            {
                targetLanguage = GetValidSystemLanguage();
                WriteLanguageToConfig(targetLanguage);
            }
        }
        else
        {
            targetLanguage = GetValidSystemLanguage();
            WriteLanguageToConfig(targetLanguage);
        }
        SetLanguage(targetLanguage);
        Utils.InitializePowerShell();
    }
    protected override void OnExit(ExitEventArgs e)
    {
        Utils.CleanupPowerShell();

        base.OnExit(e);
    }

    private string GetValidSystemLanguage()
    {
        var systemLang = GetSystemLanguageViaAPI();
        return IsLanguageSupported(systemLang) ? systemLang : DefaultLanguage;
    }

    private bool IsLanguageSupported(string languageCode)
    {
        return languageCode == "en-US" || languageCode == "zh-CN";
    }

    private string GetSystemLanguageViaAPI()
    {
        var localeName = new StringBuilder(85);
        var result = GetUserDefaultLocaleName(localeName, localeName.Capacity);
        return result > 0 ? localeName.ToString().Substring(0, result - 1) : DefaultLanguage;
    }

    private void SetLanguage(string cultureCode)
    {
        var culture = new CultureInfo(cultureCode);
        Thread.CurrentThread.CurrentCulture = culture;
        Thread.CurrentThread.CurrentUICulture = culture;
    }

    private string ReadLanguageFromConfig()
    {
        try
        {
            var configDoc = XDocument.Load(ConfigFilePath);
            return configDoc.Root?.Element("Language")?.Value ?? DefaultLanguage;
        }
        catch
        {
            return DefaultLanguage;
        }
    }

    private void WriteLanguageToConfig(string cultureCode)
    {
        var configDoc = File.Exists(ConfigFilePath)
            ? XDocument.Load(ConfigFilePath)
            : new XDocument(new XElement("Config"));

        var root = configDoc.Root;
        var langElement = root?.Element("Language");

        if (langElement == null)
            root?.Add(new XElement("Language", cultureCode));
        else
            langElement.Value = cultureCode;

        configDoc.Save(ConfigFilePath);
    }

    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    private static extern int GetUserDefaultLocaleName(
        [Out] StringBuilder lpLocaleName,
        int cchLocaleName
    );
}

================================================================================
FILE: AssemblyInfo.cs
================================================================================

﻿

================================================================================
FILE: MainWindow.xaml.cs
================================================================================

﻿using System.Windows;
using ExHyperV.Views.Pages;
using Wpf.Ui.Appearance;
using Wpf.Ui.Controls;

namespace ExHyperV
{
    public partial class MainWindow : FluentWindow
    {
        public MainWindow()
        {
            InitializeComponent();
            Loaded += PagePreload;

            if (SystemThemeManager.GetCachedSystemTheme() == SystemTheme.Dark)
            { //根据系统主题自动切换
                ApplicationThemeManager.Apply(ApplicationTheme.Dark);
            }
            else { ApplicationThemeManager.Apply(ApplicationTheme.Light); }

            Loaded += (sender, args) =>  //监听系统切换主题事件
            {
                SystemThemeWatcher.Watch(this, WindowBackdropType.Mica, true);
            };
        }

        private void PagePreload(object sender, RoutedEventArgs e)
        {
            //预加载所有子界面，多线程。
            RootNavigation.Navigate(typeof(DDAPage));
            RootNavigation.Navigate(typeof(GPUPage));
            RootNavigation.Navigate(typeof(StatusPage));
            RootNavigation.Navigate(typeof(VMNetPage));
            RootNavigation.Navigate(typeof(MemoryPage));
            RootNavigation.Navigate(typeof(CpuPage));

            RootNavigation.Navigate(typeof(MainPage));
        }




    }
}

================================================================================
FILE: Converters\BooleanToVisibilityConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    /// <summary>
    /// 将布尔值转换为WPF的Visibility枚举值，支持通过ConverterParameter="Invert"进行反向转换。
    /// </summary>
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            if (parameter is string s && s.Equals("Invert", StringComparison.OrdinalIgnoreCase))
            {
                boolValue = !boolValue;
            }

            return boolValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Converters\CommandParameterConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    /// <summary>
    /// 一个多值转换器，它将多个绑定值“打包”成一个 object[] 数组。
    /// </summary>
    public class CommandParameterConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            return values.Clone();
        }
        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Converters\EqualityConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    public class EqualityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return value?.ToString().Equals(parameter?.ToString(), StringComparison.OrdinalIgnoreCase);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (value is bool b && b) ? parameter : Binding.DoNothing;
        }
    }
}

================================================================================
FILE: Converters\GpuImagePathConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows.Data;
using System.Windows.Media.Imaging;
using ExHyperV.Tools;

namespace ExHyperV.Converters
{
    public class GpuImagePathConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length < 2)
            {
                return null;
            }

            string manu = values[0] as string ?? "";
            string name = values[1] as string ?? "";

            // 1. 从 Utils 获取图片路径字符串
            string imagePath = Utils.GetGpuImagePath(manu, name);

            try
            {
                // 2. 创建一个 Uri 对象
                Uri imageUri = new Uri(imagePath, UriKind.Absolute);

                // 3. 创建并返回一个 BitmapImage 对象
                BitmapImage bitmap = new BitmapImage();
                bitmap.BeginInit();
                bitmap.UriSource = imageUri;
                bitmap.CacheOption = BitmapCacheOption.OnLoad; // 确保图片被加载
                bitmap.EndInit();

                return bitmap;
            }
            catch
            {
                // 如果路径无效或图片不存在，返回 null，避免程序崩溃
                return null;
            }
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Converters\InverseBooleanConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    [ValueConversion(typeof(bool), typeof(bool))]
    public class InverseBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool booleanValue)
            {
                return !booleanValue;
            }
            return DependencyProperty.UnsetValue;
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return Convert(value, targetType, parameter, culture);
        }
    }
}

================================================================================
FILE: Converters\InversePercentageConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    public class InversePercentageConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double percentage)
            {
                // 返回一个 GridLength，表示剩余的比例
                double inversePercentage = 100.0 - percentage;
                if (inversePercentage < 0) inversePercentage = 0;
                return new GridLength(inversePercentage, GridUnitType.Star);
            }
            // 如果输入无效，返回一个占据所有剩余空间的 GridLength
            return new GridLength(1, GridUnitType.Star);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Converters\OsTypeToImageConverter.cs
================================================================================

﻿using System;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Media.Imaging;

namespace ExHyperV.Converters
{
    public class OsTypeToImageConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // 统一转为小写
            string osType = value?.ToString()?.ToLower() ?? "default";

            string imageName = osType switch
            {
                // Windows (对应 microsoft.png)
                "windows" => "microsoft.png",

                // Linux 发行版
                "linux" => "linux.png",
                "android" => "android.png",
                "chromeos" => "chromeos.png",
                "fydeos" => "fydeos.png",

                // Apple
                "macos" => "macos.png",

                // BSD
                "freebsd" => "freebsd.png",
                "openbsd" => "openbsd.png",

                // 软路由/NAS
                "openwrt" => "openwrt.png",
                "fnos" => "fnos.png",

                // 默认
                _ => "default.png"
            };

            return new BitmapImage(new Uri($"pack://application:,,,/Assets/{imageName}"));
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Converters\StringToVisibilityConverter.cs
================================================================================

﻿using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    public class StringToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return string.IsNullOrEmpty(value as string) ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Converters\VmNameToIconConverter.cs
================================================================================

﻿using System;
using System.Globalization;
using System.Windows.Data;

namespace ExHyperV.Converters
{
    public class VmNameToIconConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is string name)
            {
                return name.Equals("Host", StringComparison.OrdinalIgnoreCase) ? "\uE977" : "\uE7F8";
            }
            return "\uE7F8";
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

================================================================================
FILE: Models\AdapterInfo.cs
================================================================================

﻿namespace ExHyperV.Models
{
    /// <summary>
    /// 表示一个网络适配器（虚拟机的或主机的）的数据模型。
    /// </summary>
    public class AdapterInfo
    {
        public string VMName { get; set; }
        public string MacAddress { get; set; }
        public string Status { get; set; }
        public string IPAddresses { get; set; }

        public AdapterInfo(string vMName, string macAddress, string status, string ipAddresses)
        {
            VMName = vMName;
            MacAddress = macAddress;
            Status = status;
            IPAddresses = ipAddresses;
        }
    }
}

================================================================================
FILE: Models\CpuUiModels.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using System.Collections.ObjectModel;
using System.Windows.Media;
using ExHyperV.ViewModels;

namespace ExHyperV.Models
{
    public class CpuCoreMetric
    {
        public string VmName { get; set; }
        public int CoreId { get; set; }
        public float Usage { get; set; }
        public bool IsRunning { get; set; }
    }

    public enum CoreType
    {
        Unknown,
        Performance,
        Efficient
    }

    public partial class UiCoreModel : ObservableObject
    {
        [ObservableProperty]
        private int _coreId;

        [ObservableProperty]
        private double _usage;

        [ObservableProperty]
        private PointCollection _historyPoints;

        public CoreType CoreType { get; init; } = CoreType.Unknown;
    }

    public partial class UiVmModel : ObservableObject
    {
        [ObservableProperty]
        private string _name;

        [ObservableProperty]
        private bool _isRunning = true;

        [ObservableProperty]
        private int _columns = 2;

        [ObservableProperty]
        private int _rows;

        [ObservableProperty]
        private double _averageUsage;

        public ObservableCollection<UiCoreModel> Cores { get; } = new ObservableCollection<UiCoreModel>();

        [ObservableProperty]
        private VMProcessorViewModel _processor = new VMProcessorViewModel();
    }
}

================================================================================
FILE: Models\DeviceInfo.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
namespace ExHyperV.Models
{
    //可分配硬件设备的数据模型。
    public class DeviceInfo : ObservableObject
    {
        public string FriendlyName { get; }
        public string ClassType { get; }
        public string InstanceId { get; }
        public string Path { get; }
        public string Vendor { get; }

        private string _status;
        public string Status
        {
            get => _status;
            set => SetProperty(ref _status, value);
        }

        // 构造函数
        public DeviceInfo(string friendlyName, string status, string classType, string instanceId, string path, string vendor)
        {
            FriendlyName = friendlyName;
            _status = status;
            ClassType = classType;
            InstanceId = instanceId;
            Path = path;
            Vendor = vendor;
        }
    }
}

================================================================================
FILE: Models\GPUInfo.cs
================================================================================

﻿namespace ExHyperV.Models
{
    public class GPUInfo
    {
        public string Name { get; set; } //显卡名称
        public string Valid { get; set; } //是否联机
        public string Manu { get; set; } //厂商
        public string InstanceId { get; set; } //显卡实例id
        public string Pname { get; set; } //可分区的显卡路径
        public string Ram { get; set; } //显存大小
        public string DriverVersion { get; set; } //驱动版本
        public string Vendor { get; set; } //制造商

        // 构造函数
        public GPUInfo(string name, string valid, string manu, string instanceId, string pname, string ram, string driverversion, string vendor)
        {
            Name = name;
            Valid = valid;
            Manu = manu;
            InstanceId = instanceId;
            Pname = pname;
            Ram = ram;
            DriverVersion = driverversion;
            Vendor = vendor;
        }
    }
}

================================================================================
FILE: Models\HcsModels.cs
================================================================================

﻿using System.Text.Json.Serialization;

namespace ExHyperV.Models
{
    public class VmCpuGroupInfo
    {
        [JsonPropertyName("CpuGroupId")]
        public Guid CpuGroupId { get; set; }
    }
    public class HcsQueryResult
    {
        [JsonPropertyName("Properties")]
        public List<HcsProperty> Properties { get; set; }
    }
    public class HcsProperty
    {
        [JsonPropertyName("CpuGroups")]
        public List<HcsCpuGroupDetail> CpuGroups { get; set; }
    }
    public class HcsCpuGroupDetail
    {
        [JsonPropertyName("GroupId")]
        public Guid GroupId { get; set; }

        [JsonPropertyName("Affinity")]
        public HcsCpuAffinity Affinity { get; set; }
    }
    public class HcsCpuAffinity
    {
        [JsonPropertyName("LogicalProcessorCount")]
        public uint LogicalProcessorCount { get; set; }

        [JsonPropertyName("LogicalProcessors")]
        public List<uint> LogicalProcessors { get; set; }
    }
}

================================================================================
FILE: Models\IsoFileSystemType.cs
================================================================================

﻿namespace ExHyperV.Models
{
    public enum IsoFileSystemType
    {
        Udf,      // 默认推荐
        Iso9660   // 兼容模式
    }
}

================================================================================
FILE: Models\PartitionInfo.cs
================================================================================

﻿public enum OperatingSystemType
{
    Unknown,
    Windows,
    Linux,
    EFI,
    Other
}
public class PartitionInfo
{
    public int PartitionNumber { get; }
    public ulong StartOffset { get; }
    public ulong SizeInBytes { get; }
    public OperatingSystemType OsType { get; }
    public string TypeDescription { get; }

    public PartitionInfo(int number, ulong startOffset, ulong size, OperatingSystemType osType, string typeDescription)
    {
        PartitionNumber = number;
        StartOffset = startOffset;
        SizeInBytes = size;
        OsType = osType;
        TypeDescription = typeDescription;
    }

    public string DisplayName => $"Partition {PartitionNumber} ({SizeInGb:F2} GB) - {TypeDescription}";
    public double SizeInGb => SizeInBytes / (1024.0 * 1024.0 * 1024.0);

    public string IconPath
    {
        get
        {
            switch (OsType)
            {
                case OperatingSystemType.Windows:
                    return "pack://application:,,,/Assets/Microsoft.png";
                case OperatingSystemType.Linux:
                    return "pack://application:,,,/Assets/Linux.png";
                default:
                    return null;
            }
        }
    }

}

================================================================================
FILE: Models\PhysicalAdapterInfo.cs
================================================================================

﻿namespace ExHyperV.Models
{
    /// <summary>
    /// 表示一个物理网络适配器的数据模型，主要用于存储其描述信息。
    /// </summary>
    public class PhysicalAdapterInfo
    {
        public string InterfaceDescription { get; private set; }

        public PhysicalAdapterInfo(string desc)
        {
            InterfaceDescription = desc;
        }
    }
}

================================================================================
FILE: Models\SshCredentials.cs
================================================================================

﻿namespace ExHyperV.Models
{
    public class SshCredentials
    {
        public string Host { get; set; }

        public int Port { get; set; }
        public string Username { get; set; }
        public string Password { get; set; }

        public string ProxyHost { get; set; } 
        public int? ProxyPort { get; set; }   

        public bool InstallGraphics { get; set; } = true;


    }
}

================================================================================
FILE: Models\StorageModels.cs
================================================================================

﻿
namespace ExHyperV.Models
{
    public class AttachedDriveInfo
    {
        public int ControllerLocation { get; set; }
        public string DriveType { get; set; } 
        public string DiskType { get; set; }  
        public string PathOrDiskNumber { get; set; }
        public string DiskModel { get; set; }
        public double DiskSizeGB { get; set; }
        public string SerialNumber { get; set; }
        public int DiskNumber { get; set; } // 新增：专门存储物理磁盘号
    }

    public class VmStorageControllerInfo
    {
        public string VMName { get; set; }
        public int Generation { get; set; }
        public string ControllerType { get; set; } 
        public int ControllerNumber { get; set; }
        public List<AttachedDriveInfo> AttachedDrives { get; set; } = new();
    }
    public class HostDiskInfo
    {
        public int Number { get; set; }
        public string FriendlyName { get; set; }
        public double SizeGB { get; set; }
        public bool IsOffline { get; set; }
        public bool IsSystem { get; set; }
        public string OperationalStatus { get; set; }
    }
}

================================================================================
FILE: Models\SwitchInfo.cs
================================================================================

﻿namespace ExHyperV.Models
{
    /// <summary>
    /// Hyper-V 虚拟交换机的数据模型。
    /// </summary>
    public class SwitchInfo
    {
        public string SwitchName { get; set; }
        public string SwitchType { get; set; }
        public string AllowManagementOS { get; set; }
        public string Id { get; set; }
        public string NetAdapterInterfaceDescription { get; set; }
        public SwitchInfo(string switchName, string switchType, string host, string id, string phydesc)
        {
            SwitchName = switchName;
            SwitchType = switchType;
            AllowManagementOS = host;
            Id = id;
            NetAdapterInterfaceDescription = phydesc;
        }
    }
}

================================================================================
FILE: Models\UiStorageModels.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Properties;
using ExHyperV.Tools;
using System.IO;

namespace ExHyperV.Models
{
    public partial class UiDriveModel : ObservableObject
    {
        [ObservableProperty] private string _driveType;
        [ObservableProperty] private string _diskType;
        [ObservableProperty] private string _pathOrDiskNumber;
        [ObservableProperty] private int _controllerLocation;
        [ObservableProperty] private string _controllerType;
        [ObservableProperty] private int _controllerNumber;

        [ObservableProperty] private int _diskNumber;
        [ObservableProperty] private string _diskModel;
        [ObservableProperty] private double _diskSizeGB;
        [ObservableProperty] private string _serialNumber;

        public string DisplayName
        {
            get
            {
                if (DiskType == "Physical" && !string.IsNullOrEmpty(DiskModel))
                    return DiskModel;

                if (DiskType == "Virtual" && !string.IsNullOrEmpty(PathOrDiskNumber))
                {
                    try { return Path.GetFileName(PathOrDiskNumber); }
                    catch { return Resources.Model_Drive_VirtualDisk; }
                }

                return DriveType == "HardDisk" ? Resources.Model_Drive_VirtualHardDisk : Resources.Model_Drive_OpticalDrive;
            }
        }

        public string SourceTypeDisplayName => DiskType == "Physical" ? Resources.Model_Drive_SourcePhysical : Resources.Model_Drive_SourceVirtual;

        public string Icon => DriveType == "HardDisk" ? "\uEDA2" : "\uE958";

        public string SizeDisplay
        {
            get
            {
                if (_diskSizeGB <= 0)
                {
                    return "";
                }

                const long bytesPerGb = 1024L * 1024L * 1024L;
                long totalBytes = (long)(_diskSizeGB * bytesPerGb);

                return Utils.FormatBytes(totalBytes);
            }
        }
    }
}

================================================================================
FILE: Models\VirtualMachineMemoryInfo.cs
================================================================================

﻿namespace ExHyperV.Models
{
    public class VirtualMachineMemoryInfo
    {
        public string VMName { get; set; }
        public string State { get; set; }
        public bool DynamicMemoryEnabled { get; set; }
        public long StartupMB { get; set; }
        public long MinimumMB { get; set; }
        public long MaximumMB { get; set; }
        public int Buffer { get; set; } // 内存缓冲区 (%)
        public int Priority { get; set; } // 内存权重 (优先级)
        public long AssignedMB { get; set; }
        public long DemandMB { get; set; }
        public string Status { get; set; }
    }
}

================================================================================
FILE: Models\VMInfo.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using System; // 必须引用 System 以使用 TimeSpan
using System.Collections.Generic;

namespace ExHyperV.Models
{
    public partial class VMInfo : ObservableObject
    {
        [ObservableProperty]
        private string _name;

        [ObservableProperty]
        private string _lowMMIO;

        [ObservableProperty]
        private string _highMMIO;

        [ObservableProperty]
        private string _guestControlled;

        [ObservableProperty]
        private Dictionary<string, string> _gPUs;

        [ObservableProperty]
        private int _generation;

        [ObservableProperty]
        private bool _isRunning;

        [ObservableProperty]
        private string _notes;

        [ObservableProperty]
        private string _status;

        [ObservableProperty]
        private int _cpuCount;

        [ObservableProperty]
        private double _memoryGb;

        [ObservableProperty]
        private string _diskSize;

        // 修改点 1：属性类型改为 TimeSpan
        [ObservableProperty]
        private TimeSpan _uptime;

        // 修改点 2：构造函数使用可选参数
        // 注意 uptime 参数改为 TimeSpan? 类型，且默认值为 null
        public VMInfo(
            string name,
            string low,
            string high,
            string guest,
            Dictionary<string, string> gpus,
            int generation = 0,
            bool isRunning = false,
            string notes = "",
            string status = "",
            int cpu = 0,
            double ram = 0,
            string disk = "0G",
            TimeSpan? uptime = null) // 允许不传时间
        {
            _name = name;
            _lowMMIO = low;
            _highMMIO = high;
            _guestControlled = guest;
            _gPUs = gpus;
            _generation = generation;
            _isRunning = isRunning;
            _notes = notes;
            _status = status;
            _cpuCount = cpu;
            _memoryGb = ram;
            _diskSize = disk;

            // 如果没传 uptime (为 null)，则默认为 TimeSpan.Zero (00:00:00)
            _uptime = uptime ?? TimeSpan.Zero;
        }
    }
}

================================================================================
FILE: Models\VmInstanceInfo.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;

namespace ExHyperV.Models
{
    public partial class VmInstanceInfo : ObservableObject
    {
        [ObservableProperty]
        private string _name;

        [ObservableProperty]
        private string _state;

        [ObservableProperty]
        private string _osType;

        [ObservableProperty]
        private int _cpuCount;

        [ObservableProperty]
        private double _memoryGb;

        [ObservableProperty]
        private string _diskSize;

        [ObservableProperty]
        private string _uptime;

        public string ConfigSummary => $"{CpuCount} Cores / {MemoryGb:N1}GB RAM / {DiskSize}";

        public VmInstanceInfo(string name, string state, string osType, int cpu, double ram, string disk, string uptime = "00:00:00")
        {
            _name = name;
            _state = state;
            _osType = osType;
            _cpuCount = cpu;
            _memoryGb = ram;
            _diskSize = disk;
            _uptime = uptime;
        }
    }
}

================================================================================
FILE: Services\CpuAffinityService.cs
================================================================================

﻿using ExHyperV.Models;
using ExHyperV.Tools;
using System.Text.Json;
namespace ExHyperV.Services
{
    public class CpuAffinityService
    {
        public async Task<Guid> FindOrCreateCpuGroupAsync(List<int> selectedCores)
        {
            if (selectedCores == null || !selectedCores.Any())
            {
                return Guid.Empty;
            }

            var selectedCoresSet = new HashSet<uint>(selectedCores.Select(c => (uint)c));
            var existingGroups = await GetAllCpuGroupsAsync();

            if (existingGroups != null)
            {
                foreach (var group in existingGroups)
                {
                    if (group.Affinity?.LogicalProcessors != null)
                    {
                        var existingCoresSet = new HashSet<uint>(group.Affinity.LogicalProcessors);
                        if (existingCoresSet.SetEquals(selectedCoresSet))
                        {
                            return group.GroupId;
                        }
                    }
                }
            }

            var sortedSelectedCores = selectedCores.Select(c => (uint)c).OrderBy(c => c).ToArray();
            var newGroupId = Guid.NewGuid();

            await Task.Run(() => HcsManager.CreateCpuGroup(newGroupId, sortedSelectedCores));

            return newGroupId;
        }

        public async Task<HcsCpuGroupDetail> GetCpuGroupDetailsAsync(Guid groupId)
        {
            if (groupId == Guid.Empty)
            {
                return null;
            }

            var allGroups = await GetAllCpuGroupsAsync();
            return allGroups?.FirstOrDefault(g => g.GroupId == groupId);
        }

        public async Task<List<HcsCpuGroupDetail>> GetAllCpuGroupsAsync()
        {
            try
            {
                string jsonResult = await Task.Run(() => HcsManager.GetAllCpuGroupsAsJson());
                if (string.IsNullOrEmpty(jsonResult))
                {
                    return new List<HcsCpuGroupDetail>();
                }

                var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                var result = JsonSerializer.Deserialize<HcsQueryResult>(jsonResult, options);

                return result?.Properties?
                               .FirstOrDefault()?
                               .CpuGroups ?? new List<HcsCpuGroupDetail>();
            }
            catch
            {
                return null;
            }
        }
    }
}

================================================================================
FILE: Services\CpuMonitorService.cs
================================================================================

﻿using System.Collections.Concurrent;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using ExHyperV.Models;
using ExHyperV.Tools;

namespace ExHyperV.Services
{
    public enum CoreType
    {
        Performance, Efficient, Unknown
    }

    public class CpuMonitorService : IDisposable
    {
        private static readonly Dictionary<int, CoreType> _coreTypeCache = new Dictionary<int, CoreType>();
        private static bool _isHybrid = false;

        static CpuMonitorService()
        {
            InitializeCoreTypes();
        }

        public static CoreType GetCoreType(int coreId)
        {
            if (!_isHybrid) return CoreType.Unknown;
            return _coreTypeCache.TryGetValue(coreId, out var type) ? type : CoreType.Unknown;
        }

        private static void InitializeCoreTypes()
        {
            try
            {
                uint returnLength = 0;
                GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref returnLength);
                if (returnLength == 0) return;
                IntPtr buffer = Marshal.AllocHGlobal((int)returnLength);
                try
                {
                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, buffer, ref returnLength))
                    {
                        var ptr = buffer;
                        long offset = 0;
                        byte maxClass = 0;
                        byte minClass = 255;
                        var tempInfo = new List<(int Id, byte Class)>();
                        while (offset < returnLength)
                        {
                            var info = Marshal.PtrToStructure<SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(ptr);
                            if (info.Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
                            {
                                byte efficiencyClass = info.Processor.EfficiencyClass;
                                if (efficiencyClass > maxClass) maxClass = efficiencyClass;
                                if (efficiencyClass < minClass) minClass = efficiencyClass;
                                for (int i = 0; i < info.Processor.GroupCount; i++)
                                {
                                    IntPtr groupMaskPtr = ptr + (int)Marshal.OffsetOf<SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>("Processor")
                                                          + (int)Marshal.OffsetOf<PROCESSOR_RELATIONSHIP>("GroupMask")
                                                          + i * Marshal.SizeOf<GROUP_AFFINITY>();
                                    var groupInfo = Marshal.PtrToStructure<GROUP_AFFINITY>(groupMaskPtr);
                                    ulong mask = (ulong)groupInfo.Mask;
                                    for (int bit = 0; bit < 64; bit++)
                                    {
                                        if ((mask & (1UL << bit)) != 0)
                                        {
                                            tempInfo.Add((bit + groupInfo.Group * 64, efficiencyClass));
                                        }
                                    }
                                }
                            }
                            offset += info.Size;
                            ptr = IntPtr.Add(ptr, (int)info.Size);
                        }
                        if (maxClass > minClass)
                        {
                            _isHybrid = true;
                            foreach (var item in tempInfo)
                            {
                                _coreTypeCache[item.Id] = (item.Class == maxClass) ? CoreType.Performance : CoreType.Efficient;
                            }
                        }
                    }
                }
                finally
                {
                    Marshal.FreeHGlobal(buffer);
                }
            }
            catch { _isHybrid = false; }
        }

        [DllImport("kernel32.dll", SetLastError = true)] private static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
        private enum LOGICAL_PROCESSOR_RELATIONSHIP { RelationProcessorCore = 0 }
        [StructLayout(LayoutKind.Sequential)] private struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX { public LOGICAL_PROCESSOR_RELATIONSHIP Relationship; public uint Size; public PROCESSOR_RELATIONSHIP Processor; }
        [StructLayout(LayoutKind.Sequential)] private struct PROCESSOR_RELATIONSHIP { public byte Flags; public byte EfficiencyClass; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)] public byte[] Reserved; public ushort GroupCount; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] public GROUP_AFFINITY[] GroupMask; }
        [StructLayout(LayoutKind.Sequential)] private struct GROUP_AFFINITY { public UIntPtr Mask; public ushort Group; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)] public ushort[] Reserved; }

        private readonly ConcurrentDictionary<string, PerformanceCounter> _counters = new ConcurrentDictionary<string, PerformanceCounter>();
        private readonly ConcurrentDictionary<string, int> _vmCoreCounts = new ConcurrentDictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        public CpuMonitorService()
        {
            _vmCoreCounts["Host"] = Environment.ProcessorCount;
            Task.Run(() => MaintainCountersLoop(_cts.Token));
        }

        public void Dispose()
        {
            _cts.Cancel();
            foreach (var counter in _counters.Values)
            {
                counter.Dispose();
            }
            _counters.Clear();
        }

        public List<CpuCoreMetric> GetCpuUsage()
        {
            var results = new List<CpuCoreMetric>();
            var activeVmNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            var currentCounters = _counters.ToArray();

            foreach (var kvp in currentCounters)
            {
                string instanceName = kvp.Key;
                PerformanceCounter counter = kvp.Value;

                try
                {
                    float value = counter.NextValue();

                    if (instanceName.StartsWith("Host_"))
                    {
                        if (int.TryParse(instanceName.Substring(5), out int coreId))
                        {
                            results.Add(new CpuCoreMetric
                            {
                                VmName = "Host",
                                CoreId = coreId,
                                Usage = value,
                                IsRunning = true
                            });
                        }
                    }
                    else
                    {
                        int colonIndex = instanceName.LastIndexOf(':');
                        if (colonIndex > 0)
                        {
                            string vmName = instanceName.Substring(0, colonIndex);
                            string suffix = instanceName.Substring(colonIndex + 1);

                            var match = Regex.Match(suffix, @"Hv VP (\d+)");
                            if (match.Success)
                            {
                                int vCpuId = int.Parse(match.Groups[1].Value);
                                activeVmNames.Add(vmName);
                                results.Add(new CpuCoreMetric
                                {
                                    VmName = vmName,
                                    CoreId = vCpuId,
                                    Usage = value,
                                    IsRunning = true
                                });
                            }
                        }
                    }
                }
                catch
                {
                }
            }

            foreach (var kvp in _vmCoreCounts)
            {
                string vmName = kvp.Key;
                if (vmName == "Host") continue;

                if (!activeVmNames.Contains(vmName))
                {
                    int count = kvp.Value;
                    for (int i = 0; i < count; i++)
                    {
                        results.Add(new CpuCoreMetric { VmName = vmName, CoreId = i, IsRunning = false });
                    }
                }
            }

            return results;
        }

        private async Task MaintainCountersLoop(CancellationToken token)
        {
            int loopCount = 0;
            while (!token.IsCancellationRequested)
            {
                try
                {
                    UpdateCounterInstances();

                    if (loopCount % 5 == 0)
                    {
                        await UpdateVmInfoFromPowerShellAsync(token);
                    }

                    loopCount++;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[CpuMonitor] Maintain loop error: {ex.Message}");
                }

                try { await Task.Delay(2000, token); } catch (TaskCanceledException) { break; }
            }
        }

        private void UpdateCounterInstances()
        {
            var detectedInstances = new HashSet<string>();

            if (PerformanceCounterCategory.Exists("Hyper-V Hypervisor Logical Processor"))
            {
                var cat = new PerformanceCounterCategory("Hyper-V Hypervisor Logical Processor");
                var instances = cat.GetInstanceNames().Where(i => i.StartsWith("LP ") || i.Contains("LP "));

                foreach (var instance in instances)
                {
                    string coreIdStr = instance.Split(' ').Last();
                    string key = $"Host_{coreIdStr}";
                    detectedInstances.Add(key);

                    if (!_counters.ContainsKey(key))
                    {
                        try
                        {
                            var pc = new PerformanceCounter("Hyper-V Hypervisor Logical Processor", "% Total Run Time", instance);
                            pc.NextValue();
                            _counters.TryAdd(key, pc);
                        }
                        catch { }
                    }
                }
            }

            if (PerformanceCounterCategory.Exists("Hyper-V Hypervisor Virtual Processor"))
            {
                var cat = new PerformanceCounterCategory("Hyper-V Hypervisor Virtual Processor");
                var instances = cat.GetInstanceNames().Where(i => i.Contains(":"));

                foreach (var instance in instances)
                {
                    detectedInstances.Add(instance);

                    if (!_counters.ContainsKey(instance))
                    {
                        try
                        {
                            var pc = new PerformanceCounter("Hyper-V Hypervisor Virtual Processor", "% Total Run Time", instance);
                            pc.NextValue();
                            _counters.TryAdd(instance, pc);
                        }
                        catch { }
                    }
                }
            }

            var deadKeys = _counters.Keys.Where(k => !detectedInstances.Contains(k)).ToList();
            foreach (var key in deadKeys)
            {
                if (_counters.TryRemove(key, out var pc))
                {
                    pc.Dispose();
                }
            }
        }

        private async Task UpdateVmInfoFromPowerShellAsync(CancellationToken token)
        {
            try
            {
                string script = "Get-VMProcessor * | Select-Object VMName, Count";
                var results = await Utils.Run2(script, token);

                if (results == null) return;

                var activeConfigNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var pso in results)
                {
                    if (pso == null) continue;
                    var vmName = pso.Properties["VMName"]?.Value as string;
                    var countVal = pso.Properties["Count"]?.Value;

                    if (!string.IsNullOrEmpty(vmName) && countVal != null)
                    {
                        try
                        {
                            int count = Convert.ToInt32(countVal);
                            _vmCoreCounts[vmName] = count;
                            activeConfigNames.Add(vmName);
                        }
                        catch { }
                    }
                }

                var keysToRemove = _vmCoreCounts.Keys
                    .Where(k => k != "Host" && !activeConfigNames.Contains(k))
                    .ToList();

                foreach (var key in keysToRemove)
                {
                    _vmCoreCounts.TryRemove(key, out _);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[CpuMonitor] PowerShell update failed: {ex.Message}");
            }
        }
    }
}

================================================================================
FILE: Services\CpuTopologyService.cs
================================================================================

﻿using System.ComponentModel;
using System.Runtime.InteropServices;

namespace ExHyperV.Services
{
    public static class CpuTopologyService
    {
        private enum LOGICAL_PROCESSOR_RELATIONSHIP { RelationProcessorCore = 0 }

        [StructLayout(LayoutKind.Sequential)]
        private struct GROUP_AFFINITY
        {
            public UIntPtr Mask;
            public ushort Group;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
            public ushort[] Reserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct PROCESSOR_RELATIONSHIP
        {
            public byte Flags;
            public byte EfficiencyClass;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
            public byte[] Reserved;
            public ushort GroupCount;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
            public GROUP_AFFINITY[] GroupMask;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
        {
            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
            public uint Size;
            public PROCESSOR_RELATIONSHIP Processor;
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool GetLogicalProcessorInformationEx(
            LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
            IntPtr Buffer,
            ref uint ReturnedLength);

        public static Dictionary<int, int> GetCpuSiblingMap()
        {
            var siblingMap = new Dictionary<int, int>();
            uint bufferSize = 0;
            GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref bufferSize);
            if (bufferSize == 0) return siblingMap;

            IntPtr buffer = Marshal.AllocHGlobal((int)bufferSize);
            try
            {
                if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, buffer, ref bufferSize))
                {
                    throw new Win32Exception(Marshal.GetLastWin32Error());
                }

                IntPtr currentPtr = buffer;
                long offset = 0;
                while (offset < bufferSize)
                {
                    var info = Marshal.PtrToStructure<SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(currentPtr);

                    if (info.Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
                    {
                        var coreIdsInGroup = new List<int>();
                        for (int i = 0; i < info.Processor.GroupCount; i++)
                        {
                            IntPtr groupMaskPtr = currentPtr + (int)Marshal.OffsetOf<SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>("Processor")
                                                  + (int)Marshal.OffsetOf<PROCESSOR_RELATIONSHIP>("GroupMask")
                                                  + i * Marshal.SizeOf<GROUP_AFFINITY>();

                            var groupAffinity = Marshal.PtrToStructure<GROUP_AFFINITY>(groupMaskPtr);
                            var mask = (ulong)groupAffinity.Mask;

                            for (int bit = 0; bit < 64; bit++)
                            {
                                if ((mask & (1UL << bit)) != 0)
                                {
                                    coreIdsInGroup.Add(bit + groupAffinity.Group * 64);
                                }
                            }
                        }

                        if (coreIdsInGroup.Count == 2)
                        {
                            siblingMap[coreIdsInGroup[0]] = coreIdsInGroup[1];
                            siblingMap[coreIdsInGroup[1]] = coreIdsInGroup[0];
                        }
                    }

                    offset += info.Size;
                    currentPtr = IntPtr.Add(currentPtr, (int)info.Size);
                }
            }
            finally
            {
                if (buffer != IntPtr.Zero) Marshal.FreeHGlobal(buffer);
            }
            return siblingMap;
        }
    }
}

================================================================================
FILE: Services\DDAService.cs
================================================================================

﻿using System.Management.Automation;
using ExHyperV.Models;
using ExHyperV.Properties;
using ExHyperV.Tools;

namespace ExHyperV.Services
{
    /// <summary>
    /// 实现了IHyperVService接口，负责处理所有与PowerShell的实际交互。
    /// </summary>
    public class DDAService : IHyperVService
    {
        private const ulong RequiredMmioBytes = 64UL * 1024 * 1024 * 1024; // 64 GiB

        #region Public Methods (IHyperVService Implementation)

        public async Task<(List<DeviceInfo> Devices, List<string> VmNames)> GetDdaInfoAsync()
        {
            var deviceList = new List<DeviceInfo>();
            var vmNameList = new List<string>();

            await Task.Run(async () =>
            {
                var pciInfoProvider = new PciInfoProvider();
                await pciInfoProvider.EnsureInitializedAsync();

                try
                {
                    Dictionary<string, string> vmDeviceAssignments = new Dictionary<string, string>();

                    // 1. 获取虚拟机及已分配设备的信息
                    var hypervModule = Utils.Run("Get-Module -ListAvailable -Name Hyper-V");
                    if (hypervModule != null && hypervModule.Count != 0)
                    {
                        var vms = Utils.Run(@"Hyper-V\Get-VM | Select-Object Name");
                        if (vms != null)
                        {
                            foreach (var vm in vms)
                            {
                                var name = vm.Members["Name"]?.Value?.ToString();
                                if (string.IsNullOrEmpty(name)) continue;

                                vmNameList.Add(name);
                                var assignedDevices = Utils.Run($@"Get-VMAssignableDevice -VMName '{name}' | Select-Object InstanceID");
                                if (assignedDevices != null)
                                {
                                    foreach (var device in assignedDevices)
                                    {
                                        var instanceId = device.Members["InstanceID"]?.Value?.ToString()?.Substring(4);
                                        if (!string.IsNullOrEmpty(instanceId))
                                        {
                                            vmDeviceAssignments[instanceId] = name;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // 2. 检查已卸除(Dismounted)的设备状态
                    var pnpDevices = Utils.Run("Get-PnpDevice | Where-Object { $_.InstanceId -like 'PCIP\\*' } | Select-Object InstanceId, Status");
                    if (pnpDevices != null)
                    {
                        foreach (var pnpDevice in pnpDevices)
                        {
                            var instanceId = pnpDevice.Members["InstanceId"]?.Value?.ToString()?.Substring(4);
                            var status = pnpDevice.Members["Status"]?.Value?.ToString();
                            if (!string.IsNullOrEmpty(instanceId) && status == "OK" && !vmDeviceAssignments.ContainsKey(instanceId))
                            {
                                vmDeviceAssignments[instanceId] = Resources.removed;
                            }
                        }
                    }

                    // 3. 获取所有PCI设备并确定其最终状态
                    string getPciDevicesScript = @"function Invoke-GetPathBatch {
                                                param($Ids, $Map, $Key)
                                                if ($Ids.Count -eq 0) { return }
                                                Get-PnpDeviceProperty -InstanceId $Ids -KeyName $Key -ErrorAction SilentlyContinue | ForEach-Object {
                                                    if ($_.Data -and $_.Data.Count -gt 0) { $Map[$_.InstanceId] = $_.Data[0] }
                                                }
                                            }

                                            $fastRetries = 3
                                            $slowRetries = 2
                                            $slowRetryIntervalSeconds = 1
                                            $maxRetries = $fastRetries + $slowRetries
                                            $KeyName = 'DEVPKEY_Device_LocationPaths'

                                            $pciDevices = Get-PnpDevice | Where-Object { $_.InstanceId -like 'PCI\*' }
                                            if (-not $pciDevices) { exit }

                                            $pciDeviceCount = $pciDevices.Count
                                            if ($pciDeviceCount -gt 200) {
                                                $batchSize = 100
                                            } else {
                                                $batchSize = $pciDeviceCount
                                                if ($batchSize -lt 1) { $batchSize = 1 }
                                            }

                                            $allInstanceIds = $pciDevices.InstanceId
                                            $pathMap = @{}
                                            $idsNeedingPath = $allInstanceIds
                                            $attemptCount = 0

                                            while (($idsNeedingPath.Count -gt 0) -and ($attemptCount -lt $maxRetries)) {
                                                $attemptCount++
                                                if ($idsNeedingPath.Count -gt 0) {
                                                    $numBatches = [Math]::Ceiling($idsNeedingPath.Count / $batchSize)
                                                    for ($i = 0; $i -lt $numBatches; $i++) {
                                                        $batch = $idsNeedingPath[($i * $batchSize) .. ([Math]::Min((($i + 1) * $batchSize - 1), ($idsNeedingPath.Count - 1)))]
                                                        if ($batch.Count -gt 0) {
                                                            Invoke-GetPathBatch -Ids $batch -Map $pathMap -Key $KeyName
                                                        }
                                                    }
                                                }

                                                $idsNeedingPath = $allInstanceIds | Where-Object { -not $pathMap.ContainsKey($_) }

                                                if (($idsNeedingPath.Count -gt 0) -and ($attemptCount -ge $fastRetries) -and ($attemptCount -lt $maxRetries)) {
                                                    Start-Sleep -Seconds $slowRetryIntervalSeconds
                                                }
                                            }

                                            $pciDevices | Select-Object Class, InstanceId, FriendlyName, Status, Service | ForEach-Object {
                                                $val = $null; if ($pathMap.ContainsKey($_.InstanceId)) { $val = $pathMap[$_.InstanceId] }
                                                $_ | Add-Member -NotePropertyName 'Path' -NotePropertyValue $val -Force; $_
                                            }";

                    var pciData = Utils.Run(getPciDevicesScript);
                    if (pciData != null)
                    {
                        var sortedResults = pciData
                            .Where(r => r != null)
                            .OrderBy(r => r.Members["Service"]?.Value?.ToString()?[0])
                            .ToList();

                        foreach (var result in sortedResults)
                        {
                            var service = result.Members["Service"]?.Value?.ToString();
                            var classType = result.Members["Class"]?.Value?.ToString();
                            if (service == "pci" || string.IsNullOrEmpty(service)) continue;
                            //if (classType == "System") continue;

                            var instanceId = result.Members["InstanceId"]?.Value?.ToString();
                            var status = result.Members["Status"]?.Value?.ToString();

                            if (status == "Unknown" && !string.IsNullOrEmpty(instanceId) && instanceId.Length > 3)
                            {
                                status = vmDeviceAssignments.GetValueOrDefault(instanceId.Substring(3));
                                if (status == null) continue;
                            }
                            else
                            {
                                status = Resources.Host;
                            }

                            var friendlyName = result.Members["FriendlyName"]?.Value?.ToString();
                            var path = result.Members["Path"]?.Value?.ToString();
                            string vendor = pciInfoProvider.GetVendorFromInstanceId(instanceId);

                            deviceList.Add(new DeviceInfo(friendlyName, status, classType, instanceId, path, vendor));
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[HyperVService] Error in GetDdaInfoAsync: {ex}");
                    deviceList.Clear();
                    vmNameList.Clear();
                }
            });

            return (deviceList, vmNameList);
        }

        public async Task<bool> IsServerOperatingSystemAsync()
        {
            return await Task.Run(() =>
            {
                var result = Utils.Run("(Get-CimInstance -Class Win32_OperatingSystem).ProductType");
                return result != null && result.Count > 0 && result[0].ToString() == "3";
            });
        }

        public async Task<(MmioCheckResultType Result, string Message)> CheckMmioSpaceAsync(string vmName)
        {
            return await Task.Run(() =>
            {
                try
                {
                    var results = Utils.Run($"Hyper-V\\Get-VM -Name \"{vmName}\" | Select-Object HighMemoryMappedIoSpace");
                    if (results == null || results.Count == 0)
                        return (MmioCheckResultType.Error, Properties.Resources.Error_CannotGetVmInfo);

                    var mmioProperty = results[0].Properties["HighMemoryMappedIoSpace"];
                    if (mmioProperty == null || mmioProperty.Value == null)
                        return (MmioCheckResultType.Error, Properties.Resources.Error_CannotParseMmioSpace);

                    ulong currentMmioBytes = Convert.ToUInt64(mmioProperty.Value);
                    if (currentMmioBytes < RequiredMmioBytes)
                    {
                        long currentMmioGB = (long)(currentMmioBytes / (1024 * 1024 * 1024));
                        string message = string.Format(Properties.Resources.Warning_LowMmioSpace_ConfirmExpand, vmName, currentMmioGB);
                        return (MmioCheckResultType.NeedsConfirmation, message);
                    }
                    return (MmioCheckResultType.Ok, Properties.Resources.Info_MmioSpaceSufficient);
                }
                catch (Exception ex)
                {
                    return (MmioCheckResultType.Error, ex.Message);
                }
            });
        }

        public async Task<bool> UpdateMmioSpaceAsync(string vmName)
        {
            return await Task.Run(() =>
            {
                try
                {
                    string script =
                        $"if ((Hyper-V\\Get-VM -Name '{vmName}').State -eq 'Running') {{ Stop-VM -Name '{vmName}' -Force; }};" +
                        $"\nSet-VM -VMName '{vmName}' -HighMemoryMappedIoSpace {RequiredMmioBytes};";
                    return Utils.Run(script) != null;
                }
                catch { return false; }
            });
        }

        public async Task<(bool Success, string? ErrorMessage)> ExecuteDdaOperationAsync(string targetVmName, string currentVmName, string instanceId, string path, IProgress<string>? progress = null)
        {
            try
            {
                var operations = DDACommands(targetVmName, instanceId, path, currentVmName);
                if (operations.Count == 0) return (true, null); 
                foreach (var operation in operations)
                {
                    progress?.Report(operation.Message);
                    var logOutput = await ExecutePowerShellCommandAsync(operation.Command);
                    var errorLogs = logOutput.Where(log => log.Contains("Error", StringComparison.OrdinalIgnoreCase)).ToList();
                    if (errorLogs.Any())
                    {
                        var errorMessage = string.Join(Environment.NewLine, errorLogs);
                        return (false, errorMessage);
                    }
                }
                return (true, null);
            }
            catch (Exception ex)
            {
                return (false, ex.Message);
            }
        }

        #endregion

        #region Private Helper Methods

        private async Task<List<string>> ExecutePowerShellCommandAsync(string psCommand)
        {
            var logOutput = new List<string>();
            try
            {
                using (var powerShell = PowerShell.Create())
                {
                    powerShell.AddScript(psCommand);
                    var results = await Task.Run(() => powerShell.Invoke());
                    foreach (var item in results)
                    {
                        logOutput.Add(item.ToString());
                    }
                    var errorStream = powerShell.Streams.Error.ReadAll();
                    if (errorStream.Any())
                    {
                        foreach (var error in errorStream)
                        {
                            logOutput.Add($"Error: {error}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                logOutput.Add($"Error: {ex.Message}");
            }
            return logOutput;
        }

        private List<(string Command, string Message)> DDACommands(string Vmname, string instanceId, string path, string Nowname)
        {
            var operations = new List<(string Command, string Message)>();
            // 场景1: 设备已卸除，现在要分配给主机。
            if (Nowname == Resources.removed && Vmname == Resources.Host)
            {
                operations.Add((
                    Command: $"Mount-VMHostAssignableDevice -LocationPath '{path}'",
                    Message: Resources.mounting
                ));
            }
            // 场景2: 设备已卸除，现在要分配给某个虚拟机。
            else if (Nowname == Resources.removed && Vmname != Resources.Host)
            {
                operations.Add((
                    Command: $"Add-VMAssignableDevice -LocationPath '{path}' -VMName '{Vmname}'",
                    Message: Resources.mounting
                ));
            }
            // 场景3: 设备在主机上，现在要分配给某个虚拟机。
            else if (Nowname == Resources.Host)
            {
                operations.Add(($"Set-VM -Name '{Vmname}' -AutomaticStopAction TurnOff", Resources.string5));
                operations.Add(($"Set-VM -GuestControlledCacheTypes $true -VMName '{Vmname}'", Resources.cpucache));
                operations.Add(($"(Get-PnpDeviceProperty -InstanceId '{instanceId}' DEVPKEY_Device_LocationPaths).Data[0]", Resources.getpath));
                operations.Add(($"Disable-PnpDevice -InstanceId '{instanceId}' -Confirm:$false", Resources.Disabledevice));
                operations.Add(($"Dismount-VMHostAssignableDevice -Force -LocationPath '{path}'", Resources.Dismountdevice));
                operations.Add(($"Add-VMAssignableDevice -LocationPath '{path}' -VMName '{Vmname}'", Resources.mounting));
            }
            // 场景4: 设备从一个虚拟机移到另一个虚拟机。
            else if (Vmname != Resources.Host && Nowname != Resources.Host)
            {
                operations.Add(($"Set-VM -Name '{Vmname}' -AutomaticStopAction TurnOff", Resources.string5));
                operations.Add(($"Set-VM -GuestControlledCacheTypes $true -VMName '{Vmname}'", Resources.cpucache));
                operations.Add(($"(Get-PnpDeviceProperty -InstanceId '{instanceId}' DEVPKEY_Device_LocationPaths).Data[0]", Resources.getpath));
                operations.Add(($"Remove-VMAssignableDevice -LocationPath '{path}' -VMName '{Nowname}'", Resources.Dismountdevice));
                operations.Add(($"Add-VMAssignableDevice -LocationPath '{path}' -VMName '{Vmname}'", Resources.mounting));
            }
            // 场景5: 设备从一个虚拟机移回给主机。
            else if (Vmname == Resources.Host && Nowname != Resources.Host)
            {
                operations.Add(($"(Get-PnpDeviceProperty -InstanceId '{instanceId}' DEVPKEY_Device_LocationPaths).Data[0]", Resources.getpath));
                operations.Add(($"Remove-VMAssignableDevice -LocationPath '{path}' -VMName '{Nowname}'", Resources.Dismountdevice));
                operations.Add(($"Mount-VMHostAssignableDevice -LocationPath '{path}'", Resources.mounting));
                operations.Add(($"Enable-PnpDevice -InstanceId '{instanceId}' -Confirm:$false", Resources.enabling));
            }
            return operations;
        }
        #endregion
    }
}

================================================================================
FILE: Services\DiskParserService.cs
================================================================================

﻿using System.IO;

namespace ExHyperV.Services
{
    public class DiskParserService
    {
        private static readonly Guid WindowsBasicDataGuid = new Guid("EBD0A0A2-B9E5-4433-87C0-68B6B72699C7");
        private static readonly Guid LinuxFileSystemGuid = new Guid("0FC63DAF-8483-4772-8E79-3D69D8477DE4");
        private static readonly Guid LinuxLvmGuid = new Guid("E6D6D379-F507-44C2-A23C-238F2A3DF928");

        /// <summary>
        /// 解析磁盘分区
        /// </summary>
        public List<PartitionInfo> GetPartitions(string devicePath, int bytesPerSector = 512)
        {
            var partitions = new List<PartitionInfo>();

            try
            {
                using (var diskStream = new FileStream(devicePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    var lba0Buffer = new byte[bytesPerSector];
                    diskStream.Read(lba0Buffer, 0, bytesPerSector);

                    // MBR 签名检查
                    if (BitConverter.ToUInt16(lba0Buffer, 510) != 0xAA55)
                    {
                        return partitions;
                    }

                    if (IsGptProtectiveMbr(lba0Buffer))
                    {
                        partitions.AddRange(ParseGptPartitions(diskStream, bytesPerSector));
                    }
                    else
                    {
                        partitions.AddRange(ParseMbrPartitions(diskStream, lba0Buffer, bytesPerSector));
                    }
                }
            }
            catch (Exception)
            {
                // 忽略读取错误，返回空列表
                return new List<PartitionInfo>();
            }

            // 过滤掉小于 1GB 的分区
            const long oneGbInBytes = 1024L * 1024 * 1024;

            return partitions
                .Where(p => p.SizeInBytes >= oneGbInBytes)
                .Where(p => p.OsType == OperatingSystemType.Windows || p.OsType == OperatingSystemType.Linux)
                .ToList();
        }

        private bool IsGptProtectiveMbr(byte[] mbrBuffer)
        {
            for (int i = 0; i < 4; i++)
            {
                int offset = 446 + (i * 16);
                if (mbrBuffer[offset + 4] == 0xEE) return true;
            }
            return false;
        }

        private IEnumerable<PartitionInfo> ParseGptPartitions(FileStream diskStream, int bytesPerSector)
        {
            diskStream.Seek(bytesPerSector, SeekOrigin.Begin);

            var gptHeaderBuffer = new byte[bytesPerSector];
            diskStream.Read(gptHeaderBuffer, 0, bytesPerSector);

            if (BitConverter.ToUInt64(gptHeaderBuffer, 0) != 0x5452415020494645)
            {
                yield break;
            }

            ulong partitionArrayStartLba = BitConverter.ToUInt64(gptHeaderBuffer, 72);
            uint partitionEntryCount = BitConverter.ToUInt32(gptHeaderBuffer, 80);
            uint partitionEntrySize = BitConverter.ToUInt32(gptHeaderBuffer, 84);

            long tableSize = partitionEntryCount * partitionEntrySize;
            byte[] tableBuffer = new byte[tableSize];

            diskStream.Seek((long)(partitionArrayStartLba * (ulong)bytesPerSector), SeekOrigin.Begin);
            diskStream.Read(tableBuffer, 0, (int)tableSize);

            using (var ms = new MemoryStream(tableBuffer))
            using (var reader = new BinaryReader(ms))
            {
                for (int i = 0; i < partitionEntryCount; i++)
                {
                    var entryBuffer = reader.ReadBytes((int)partitionEntrySize);
                    var typeGuid = new Guid(entryBuffer.Take(16).ToArray());

                    if (typeGuid == Guid.Empty) continue;

                    ulong firstLba = BitConverter.ToUInt64(entryBuffer, 32);
                    ulong lastLba = BitConverter.ToUInt64(entryBuffer, 40);

                    ulong startOffset = firstLba * (ulong)bytesPerSector;
                    ulong size = (lastLba - firstLba + 1) * (ulong)bytesPerSector;

                    var (osType, desc) = GetOsTypeFromGptGuid(typeGuid);

                    yield return new PartitionInfo(i + 1, startOffset, size, osType, desc);
                }
            }
        }

        private IEnumerable<PartitionInfo> ParseMbrPartitions(FileStream diskStream, byte[] mbrBuffer, int bytesPerSector)
        {
            var partitions = new List<PartitionInfo>();
            int logicalPartitionNumber = 5;
            ulong extendedPartitionStartOffset = 0;

            for (int i = 0; i < 4; i++)
            {
                int offset = 446 + (i * 16);
                byte systemId = mbrBuffer[offset + 4];

                if (systemId == 0x00) continue;

                uint startSector = BitConverter.ToUInt32(mbrBuffer, offset + 8);
                uint totalSectors = BitConverter.ToUInt32(mbrBuffer, offset + 12);

                ulong startOffset = (ulong)startSector * (ulong)bytesPerSector;
                ulong size = (ulong)totalSectors * (ulong)bytesPerSector;

                if (systemId == 0x05 || systemId == 0x0F)
                {
                    extendedPartitionStartOffset = startOffset;
                    continue;
                }

                var (osType, desc) = GetOsTypeFromMbrId(systemId);
                partitions.Add(new PartitionInfo(i + 1, startOffset, size, osType, desc));
            }

            if (extendedPartitionStartOffset > 0)
            {
                partitions.AddRange(ParseLogicalPartitions(diskStream, extendedPartitionStartOffset, bytesPerSector, ref logicalPartitionNumber));
            }

            return partitions;
        }

        private IEnumerable<PartitionInfo> ParseLogicalPartitions(FileStream diskStream, ulong currentEbrOffset, int bytesPerSector, ref int partitionNumber)
        {
            var partitions = new List<PartitionInfo>();
            var ebrBuffer = new byte[bytesPerSector];
            ulong extendedPartitionBaseOffset = currentEbrOffset;

            while (currentEbrOffset > 0)
            {
                diskStream.Seek((long)currentEbrOffset, SeekOrigin.Begin);
                diskStream.Read(ebrBuffer, 0, bytesPerSector);

                if (BitConverter.ToUInt16(ebrBuffer, 510) != 0xAA55) break;

                int entry1Offset = 446;
                byte systemId1 = ebrBuffer[entry1Offset + 4];
                if (systemId1 != 0x00)
                {
                    uint startSectorRelative = BitConverter.ToUInt32(ebrBuffer, entry1Offset + 8);
                    uint totalSectors = BitConverter.ToUInt32(ebrBuffer, entry1Offset + 12);

                    ulong startOffset = currentEbrOffset + ((ulong)startSectorRelative * (ulong)bytesPerSector);
                    ulong size = (ulong)totalSectors * (ulong)bytesPerSector;

                    var (osType, desc) = GetOsTypeFromMbrId(systemId1);
                    partitions.Add(new PartitionInfo(partitionNumber++, startOffset, size, osType, desc));
                }

                int entry2Offset = 446 + 16;
                byte systemId2 = ebrBuffer[entry2Offset + 4];
                if (systemId2 == 0x05 || systemId2 == 0x0F)
                {
                    uint nextEbrSectorRelative = BitConverter.ToUInt32(ebrBuffer, entry2Offset + 8);
                    currentEbrOffset = extendedPartitionBaseOffset + ((ulong)nextEbrSectorRelative * (ulong)bytesPerSector);
                }
                else
                {
                    currentEbrOffset = 0;
                }
            }
            return partitions;
        }

        private (OperatingSystemType, string) GetOsTypeFromMbrId(byte systemId)
        {
            switch (systemId)
            {
                case 0x07: return (OperatingSystemType.Windows, "Windows");
                case 0x0B:
                case 0x0C: return (OperatingSystemType.Windows, "Windows");
                case 0x83: return (OperatingSystemType.Linux, "Linux");
                case 0x8E: return (OperatingSystemType.Linux, "Linux LVM");
                default: return (OperatingSystemType.Other, "Other");
            }
        }

        private (OperatingSystemType, string) GetOsTypeFromGptGuid(Guid typeGuid)
        {
            if (typeGuid == WindowsBasicDataGuid) return (OperatingSystemType.Windows, "Windows");
            if (typeGuid == LinuxFileSystemGuid) return (OperatingSystemType.Linux, "Linux");
            if (typeGuid == LinuxLvmGuid) return (OperatingSystemType.Linux, "Linux");

            return (OperatingSystemType.Other, "Other");
        }
    }
}

================================================================================
FILE: Services\GpuPartitionService.cs
================================================================================

﻿using System.Diagnostics;
using System.IO;
using ExHyperV.Models;
using ExHyperV.Tools;
using ExHyperV.Views;  
using Renci.SshNet;
using System.Net.Sockets; 


namespace ExHyperV.Services
{
    public class GpuPartitionService : IGpuPartitionService
    {

        private const string ScriptBaseUrl = "https://raw.githubusercontent.com/Justsenger/ExHyperV/main/src/Linux/script/";
        private bool IsWindows11OrGreater() => Environment.OSVersion.Version.Build >= 22000;

        // PowerShell 脚本常量
        private const string GetGpuWmiInfoScript = "Get-CimInstance -Class Win32_VideoController | select PNPDeviceID,name,AdapterCompatibility,DriverVersion";
        private const string GetGpuRamScript = @"
            Get-ItemProperty -Path ""HKLM:\SYSTEM\ControlSet001\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0*"" -ErrorAction SilentlyContinue |
                Select-Object MatchingDeviceId,
                      @{Name='MemorySize'; Expression={
                          if ($_. ""HardwareInformation.qwMemorySize"") {
                              $_.""HardwareInformation.qwMemorySize""
                          } 
                          elseif ($_. ""HardwareInformation.MemorySize"" -and $_.""HardwareInformation.MemorySize"" -isnot [byte[]]) {
                              $_.""HardwareInformation.MemorySize""
                          }
                          else {
                              $null
                          }
                      }} |
                Where-Object { $_.MemorySize -ne $null -and $_.MemorySize -gt 0 }";

        private const string GetPartitionableGpusWin11Script = "Get-VMHostPartitionableGpu | select name";
        private const string GetPartitionableGpusWin10Script = "Get-VMPartitionableGpu | select name"; 



        private const string CheckHyperVModuleScript = "Get-Module -ListAvailable -Name Hyper-V";
        private const string GetVmsScript = "Hyper-V\\Get-VM | Select vmname,LowMemoryMappedIoSpace,GuestControlledCacheTypes,HighMemoryMappedIoSpace,Notes";


        //SSH重新连接
        private async Task<bool> WaitForVmToBeResponsiveAsync(string host, int port, CancellationToken cancellationToken)
        {
            var stopwatch = Stopwatch.StartNew();
            while (stopwatch.Elapsed < TimeSpan.FromMinutes(1)) // 1分钟总超时
            {
                if (cancellationToken.IsCancellationRequested) return false;
                try
                {
                    using (var client = new TcpClient())
                    {
                        var connectTask = client.ConnectAsync(host, port);
                        if (await Task.WhenAny(connectTask, Task.Delay(2000, cancellationToken)) == connectTask)
                        {
                            await connectTask;
                            return true;
                        }
                    }
                }
                catch {}
                await Task.Delay(5000, cancellationToken);
            }
            return false; // 超时
        }

        public Task<string> GetVmStateAsync(string vmName)
        {
            return Task.Run(() =>
            {
                var result = Utils.Run($"(Get-VM -Name '{vmName}').State");
                if (result != null && result.Count > 0)
                {
                    return result[0].ToString();
                }
                return "NotFound";
            });
        }
        public Task ShutdownVmAsync(string vmName)
        {
            return Task.Run(() =>
            {
                Utils.Run($"Stop-VM -Name '{vmName}' -TurnOff");

                while (true)
                {
                    var result = Utils.Run($"(Get-VM -Name '{vmName}').State");
                    if (result != null && result.Count > 0 && result[0].ToString() == "Off")
                    {
                        break;
                    }
                    System.Threading.Thread.Sleep(500); 
                }
            });
        }


        //挂载VHDX时寻找可用的盘符，可能存在问题。
        private char GetFreeDriveLetter()
        {
            var usedLetters = DriveInfo.GetDrives().Select(d => d.Name[0]).ToList();
            for (char c = 'Z'; c >= 'A'; c--)
            {
                if (!usedLetters.Contains(c))
                {
                    return c;
                }
            }
            throw new IOException(ExHyperV.Properties.Resources.Error_NoAvailableDriveLetters);
        }
        public Task<List<PartitionInfo>> GetPartitionsFromVmAsync(string vmName)
        {
            return Task.Run(() =>
            {
                string harddiskpath = null;
                int? diskNumber = null;

                try
                {
                    var harddiskPathResult = Utils.Run($"(Get-VMHardDiskDrive -vmname '{vmName}')[0].Path");
                    if (harddiskPathResult == null || harddiskPathResult.Count == 0)
                    {
                        throw new FileNotFoundException(string.Format(Properties.Resources.Error_VmHardDiskNotFound, vmName));
                    }
                    harddiskpath = harddiskPathResult[0].ToString();

                    var mountScript = $@"
                $diskImage = Mount-DiskImage -ImagePath '{harddiskpath}' -NoDriveLetter -PassThru;
                ($diskImage | Get-Disk).Number;
            ";
                    var mountResult = Utils.Run(mountScript);

                    if (mountResult == null || mountResult.Count == 0 || !int.TryParse(mountResult[0].ToString(), out int num))
                    {
                        throw new InvalidOperationException(ExHyperV.Properties.Resources.Error_MountVhdOrGetDiskNumberFailed);
                    }
                    diskNumber = num;
                    string devicePath = $@"\\.\PhysicalDrive{diskNumber}";
                    var diskParser = new DiskParserService();
                    List<PartitionInfo> initialPartitions = diskParser.GetPartitions(devicePath);
                    return initialPartitions;
                }
                catch (UnauthorizedAccessException)
                {
                    throw new UnauthorizedAccessException(ExHyperV.Properties.Resources.Error_AdminRequiredForPartitionInfo);
                }
                finally
                {
                    if (!string.IsNullOrEmpty(harddiskpath))
                    {
                        Utils.Run($"Dismount-DiskImage -ImagePath '{harddiskpath}' -ErrorAction SilentlyContinue");
                    }
                }
            });
        }
        private string NormalizeDeviceId(string deviceId)
        {
            if (string.IsNullOrWhiteSpace(deviceId))
            {
                return string.Empty;
            }
            var normalizedId = deviceId.ToUpper();
            if (normalizedId.StartsWith(@"\\?\"))
            {
                normalizedId = normalizedId.Substring(4);
            }
            int suffixIndex = normalizedId.IndexOf("#{");
            if (suffixIndex != -1)
            {
                normalizedId = normalizedId.Substring(0, suffixIndex);
            }
            normalizedId = normalizedId.Replace('\\', '#');

            return normalizedId;
        }
        public Task<List<GPUInfo>> GetHostGpusAsync()
        {
            return Task.Run(() =>
            {
                var pciInfoProvider = new PciInfoProvider();
                pciInfoProvider.EnsureInitializedAsync().Wait();

                var gpuList = new List<GPUInfo>();
                var gpulinked = Utils.Run(GetGpuWmiInfoScript);
                if (gpulinked.Count > 0)
                {
                    foreach (var gpu in gpulinked)
                    {
                        string name = gpu.Members["name"]?.Value.ToString();
                        string instanceId = gpu.Members["PNPDeviceID"]?.Value.ToString();
                        string manu = gpu.Members["AdapterCompatibility"]?.Value.ToString();
                        string driverVersion = gpu.Members["DriverVersion"]?.Value.ToString();
                        string vendor = pciInfoProvider.GetVendorFromInstanceId(instanceId);
                        //if (vendor == "Unknown") { continue; }
                        if (instanceId != null && !instanceId.ToUpper().StartsWith("PCI\\")){continue; }
                        gpuList.Add(new GPUInfo(name, "True", manu, instanceId, null, null, driverVersion, vendor));
                    }
                }

                bool hasHyperV = Utils.Run(CheckHyperVModuleScript).Count > 0;
                if (!hasHyperV)
                {
                    return gpuList;
                }

                var gpuram = Utils.Run(GetGpuRamScript);
                if (gpuram.Count > 0)
                {
                    foreach (var existingGpu in gpuList)
                    {
                        var matchedGpu = gpuram.FirstOrDefault(g =>
                        {
                            string id = g.Members["MatchingDeviceId"]?.Value?.ToString().ToUpper().Substring(0, 21);
                            return !string.IsNullOrEmpty(id) && existingGpu.InstanceId.Contains(id);
                        });

                        string preram = matchedGpu?.Members["MemorySize"]?.Value?.ToString() ?? "0";
                        existingGpu.Ram = long.TryParse(preram, out long _) ? preram : "0";
                    }
                }

                string GetPartitionableGpusScript = IsWindows11OrGreater() ? GetPartitionableGpusWin11Script : GetPartitionableGpusWin10Script;
                var partitionableGpus = Utils.Run(GetPartitionableGpusScript);
                if (partitionableGpus.Count > 0)
                {
                    foreach (var gpu in partitionableGpus)
                    {
                        string pname = gpu.Members["Name"]?.Value.ToString();
                        string normalizedPNameId = NormalizeDeviceId(pname);

                        if (string.IsNullOrEmpty(normalizedPNameId)) continue;
                        var existingGpu = gpuList.FirstOrDefault(g =>
                            NormalizeDeviceId(g.InstanceId) == normalizedPNameId
                        );
                        if (existingGpu != null)
                        {
                            existingGpu.Pname = pname;
                        }
                    }
                }
                return gpuList;
            });
        }

        public Task<List<VMInfo>> GetVirtualMachinesAsync()
        {
            return Task.Run(() =>
            {
                var vmList = new List<VMInfo>();
                var vms = Utils.Run(GetVmsScript);
                if (vms.Count > 0)
                {
                    foreach (var vm in vms)
                    {
                        var gpulist = new Dictionary<string, string>();
                        string vmname = vm.Members["VMName"]?.Value?.ToString() ?? string.Empty;
                        string highmmio = vm.Members["HighMemoryMappedIoSpace"]?.Value?.ToString() ?? string.Empty;
                        string guest = vm.Members["GuestControlledCacheTypes"]?.Value?.ToString() ?? string.Empty;
                        string notes = vm.Members["Notes"]?.Value?.ToString() ?? string.Empty;

                        var vmgpus = Utils.Run($@"Get-VMGpuPartitionAdapter -VMName '{vmname}' | Select InstancePath,Id");
                        if (vmgpus.Count > 0)
                        {
                            foreach (var gpu in vmgpus)
                            {
                                string gpupath = gpu.Members["InstancePath"]?.Value?.ToString() ?? string.Empty;
                                string gpuid = gpu.Members["Id"]?.Value?.ToString() ?? string.Empty;
                                // 如果InstancePath为空 (Win10场景)，则尝试从备注中解析
                                if (string.IsNullOrEmpty(gpupath) && !string.IsNullOrEmpty(notes))
                                {
                                    string tagPrefix = "[AssignedGPU:";
                                    int startIndex = notes.IndexOf(tagPrefix);
                                    if (startIndex != -1)
                                    {
                                        startIndex += tagPrefix.Length;
                                        int endIndex = notes.IndexOf("]", startIndex);
                                        if (endIndex != -1)
                                        {
                                            gpupath = notes.Substring(startIndex, endIndex - startIndex);
                                        }
                                    }
                                }
                                gpulist[gpuid] = gpupath;
                            }
                        }
                        vmList.Add(new VMInfo(vmname, null, highmmio, guest, gpulist));
                    }
                }
                return vmList;
            });
        }

        private async Task<string> InjectWindowsDriversAsync(string vmName, string harddiskpath, PartitionInfo partition, string gpuManu, string gpuInstancePath)
        {
            string assignedDriveLetter = null;

            try
            {
                // 1. 挂载分区
                char suggestedLetter = GetFreeDriveLetter();
                var mountScript = $@"
            $diskImage = Mount-DiskImage -ImagePath '{harddiskpath}' -PassThru | Get-Disk;
            $partitionToMount = Get-Partition -DiskNumber $diskImage.Number | Where-Object {{ $_.PartitionNumber -eq {partition.PartitionNumber} }};
            
            if ($partitionToMount.DriveLetter) {{ return $partitionToMount.DriveLetter }}
            
            try {{
                $partitionToMount | Set-Partition -NewDriveLetter '{suggestedLetter}' -ErrorAction Stop;
                return '{suggestedLetter}'
            }} catch {{
                return ($partitionToMount | Get-Partition).DriveLetter
            }}
        ";

                var letterResult = Utils.Run(mountScript);

                if (letterResult == null || letterResult.Count == 0 || string.IsNullOrEmpty(letterResult[0].ToString()))
                {
                    return string.Format(Properties.Resources.Error_FailedToFindSystemPartition, harddiskpath);
                }

                string actualLetter = letterResult[0].ToString();
                assignedDriveLetter = actualLetter.EndsWith(":") ? actualLetter : $"{actualLetter}:";

                // 2. 验证系统路径
                string system32Path = Path.Combine(assignedDriveLetter, "Windows", "System32");
                if (!Directory.Exists(system32Path))
                {
                    return string.Format(Properties.Resources.Error_InvalidWindowsPartition, partition.PartitionNumber, assignedDriveLetter, system32Path);
                }

                string letter = assignedDriveLetter.TrimEnd(':');
                string driverStoreBase = @"C:\Windows\System32\DriverStore\FileRepository";

                string sourceFolder = FindGpuDriverSourcePath(gpuInstancePath);


                // 逻辑判定：如果找到了驱动文件夹，就只复制那个文件夹；如果没找到，回退到全量复制
                bool isFullCopy = false;
                if (string.IsNullOrEmpty(sourceFolder))
                {
                    sourceFolder = driverStoreBase;
                    isFullCopy = true;
                }
                string destinationBase = letter + @":\Windows\System32\HostDriverStore\FileRepository";
                string destinationFolder;

                if (isFullCopy)
                {
                    destinationFolder = destinationBase;
                }
                else
                {
                    // 精准复制模式
                    string folderName = new DirectoryInfo(sourceFolder).Name;
                    destinationFolder = Path.Combine(destinationBase, folderName);
                }

                // 创建目录结构
                if (!Directory.Exists(destinationBase)) Directory.CreateDirectory(destinationBase);
                if (!Directory.Exists(destinationFolder)) Directory.CreateDirectory(destinationFolder);

                // 处理只读属性
                if (Directory.Exists(destinationFolder))
                {
                    try { RemoveReadOnlyAttribute(destinationFolder); }
                    catch (Exception ex) { return string.Format(Properties.Resources.Error_RemoveOldDriverFolderReadOnlyFailed, ex.Message); }
                }

                // 执行 Robocopy
                Process robocopyProcess = new()
                {
                    StartInfo = {
                FileName = "robocopy",
                Arguments = $"\"{sourceFolder}\" \"{destinationFolder}\" /E /R:2 /W:5 /NP /NJH /NFL /NDL",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                CreateNoWindow = true
            }
                };
                robocopyProcess.Start();
                await robocopyProcess.WaitForExitAsync();

                if (robocopyProcess.ExitCode >= 8)
                {
                    return string.Format(Properties.Resources.Error_RobocopyDriverCopyFailed, robocopyProcess.ExitCode);
                }

                SetFolderReadOnly(destinationFolder);

                // 3. 注册表注入
                if (gpuManu.Contains("NVIDIA"))
                {
                    string regResult = NvidiaReg(letter + ":");
                    if (regResult != "OK")
                    {
                        return regResult;
                    }
                }

                return "OK";
            }
            finally
            {
                if (!string.IsNullOrEmpty(harddiskpath))
                {
                    var cleanupScript = $@"
                $diskImage = Get-DiskImage -ImagePath '{harddiskpath}';
                if ($diskImage -and $diskImage.Attached) {{
                    if ('{assignedDriveLetter}') {{
                         try {{
                            Remove-PartitionAccessPath -DiskNumber $diskImage.Number -PartitionNumber {partition.PartitionNumber} -AccessPath '{assignedDriveLetter}\' -ErrorAction SilentlyContinue;
                         }} catch {{}}
                    }}
                    Dismount-DiskImage -ImagePath '{harddiskpath}' -ErrorAction SilentlyContinue;
                }}
            ";
                    Utils.Run(cleanupScript);
                }
            }
        }
        public Task<string> AddGpuPartitionAsync(string vmName, string gpuInstancePath, string gpuManu, PartitionInfo selectedPartition, string id)
        {
            return Task.Run(async () =>
            {
                bool isWin10 = !IsWindows11OrGreater();
                var disabledGpuInstanceIds = new List<string>();
                int partitionableGpuCount = 0;
                string NormalizeForComparison(string deviceId)
                {
                    if (string.IsNullOrWhiteSpace(deviceId)) return string.Empty;
                    var normalizedId = deviceId.Replace('#', '\\').ToUpper();
                    if (normalizedId.StartsWith(@"\\?\")) normalizedId = normalizedId.Substring(4);
                    int suffixIndex = normalizedId.IndexOf('{');
                    if (suffixIndex != -1)
                    {
                        int lastSeparatorIndex = normalizedId.LastIndexOf('\\', suffixIndex);
                        if (lastSeparatorIndex != -1)
                        {
                            normalizedId = normalizedId.Substring(0, lastSeparatorIndex);
                        }
                    }
                    return normalizedId;
                }
                void ShowMessageOnUIThread(string message, string title = "提示")
                {
                    System.Windows.Application.Current.Dispatcher.Invoke(() => Utils.Show2(message));
                }
                try
                {
                    Utils.AddGpuAssignmentStrategyReg();
                    Utils.ApplyGpuPartitionStrictModeFix();

                    if (selectedPartition != null)
                    {
                        var vmStateResult = Utils.Run($"(Get-VM -Name '{vmName}').State");
                        if (vmStateResult == null || vmStateResult.Count == 0 || vmStateResult[0].ToString() != "Off")
                        {
                            return string.Format(Properties.Resources.Error_VmMustBeOff, vmName);
                        }
                    }

                    if (isWin10)
                    {
                        var allHostGpus = await GetHostGpusAsync();
                        partitionableGpuCount = allHostGpus.Count(gpu => !string.IsNullOrEmpty(gpu.Pname));
                        string normalizedSelectedGpuId = NormalizeForComparison(gpuInstancePath);

                        foreach (var gpu in allHostGpus)
                        {
                            if (!gpu.InstanceId.ToUpper().StartsWith("PCI\\")) continue;

                            string normalizedCurrentGpuId = NormalizeForComparison(gpu.InstanceId);

                            if (!string.Equals(normalizedCurrentGpuId, normalizedSelectedGpuId, StringComparison.OrdinalIgnoreCase))
                            {
                                disabledGpuInstanceIds.Add(gpu.InstanceId);
                            }
                        }

                        if (disabledGpuInstanceIds.Any())
                        {
                            foreach (var id in disabledGpuInstanceIds)
                            {
                                Utils.Run($"Disable-PnpDevice -InstanceId '{id}' -Confirm:$false");
                            }
                            await Task.Delay(2000);
                        }
                    }
                    string addGpuCommand = isWin10
                        ? $"Add-VMGpuPartitionAdapter -VMName '{vmName}'"
                        : $"Add-VMGpuPartitionAdapter -VMName '{vmName}' -InstancePath '{gpuInstancePath}'";

                    string vmConfigScript;
                    if (selectedPartition == null)
                    {
                        vmConfigScript = addGpuCommand;
                    }
                    else
                    {
                        vmConfigScript = $@"
                        Set-VM -GuestControlledCacheTypes $true -VMName '{vmName}';
                        Set-VM -HighMemoryMappedIoSpace 64GB –VMName '{vmName}';
                        Set-VM -LowMemoryMappedIoSpace 1GB -VMName '{vmName}';
                        {addGpuCommand};
                        ";
                    }
                    Utils.Run(vmConfigScript);
                    if (isWin10)
                    {
                        string gpuTag = $"[AssignedGPU:{gpuInstancePath}]";
                        string updateNotesScript = $@"
                        $vm = Get-VM -Name '{vmName}';
                        $currentNotes = $vm.Notes;
                        $cleanedNotes = $currentNotes -replace '\[AssignedGPU:[^\]]+\]', '';
                        $newNotes = ($cleanedNotes.Trim() + ' ' + '{gpuTag}').Trim();
                        Set-VM -VM $vm -Notes $newNotes;
                        ";
                        Utils.Run(updateNotesScript);
                    }
                    if (selectedPartition != null)
                    {
                        if (selectedPartition.OsType == OperatingSystemType.Windows)
                        {
                            var harddiskPathResult = Utils.Run($"(Get-VMHardDiskDrive -vmname '{vmName}')[0].Path");
                            if (harddiskPathResult == null || harddiskPathResult.Count == 0)
                            {
                                return ExHyperV.Properties.Resources.Error_GetVmHardDiskPathFailed;
                            }
                            string harddiskpath = harddiskPathResult[0].ToString();
                            string injectionResult = await InjectWindowsDriversAsync(vmName, harddiskpath, selectedPartition, gpuManu, id);
                            if (injectionResult != "OK")
                            {
                                return injectionResult;
                            }
                        }
                        else if (selectedPartition.OsType == OperatingSystemType.Linux)
                        {
                            var sshService = new SshService();
                            SshCredentials credentials = null;
                            ExecutionProgressWindow progressWindow = null;
                            var cts = new CancellationTokenSource();
                            Action<string> showMessage = (msg) => System.Windows.Application.Current.Dispatcher.Invoke(() => Utils.Show2(msg));
                            Func<string, string> withSudo = (cmd) =>
                            {
                                // 移除命令开头可能存在的 sudo，以防重复
                                if (cmd.Trim().StartsWith("sudo "))
                                {
                                    cmd = cmd.Trim().Substring(5);
                                }
                                // 对密码中的单引号进行转义，防止shell注入
                                string escapedPassword = credentials.Password.Replace("'", "'\\''");
                                return $"echo '{escapedPassword}' | sudo -S -E -p '' {cmd}";
                            };
                            try
                            {
                                var currentState = await GetVmStateAsync(vmName);
                                if (currentState != "Running")
                                {
                                    Utils.Run($"Start-VM -Name '{vmName}'");
                                }
                                string getMacScript = $"(Get-VMNetworkAdapter -VMName '{vmName}').MacAddress | Select-Object -First 1";
                                var macResult = await Utils.Run2(getMacScript);
                                if (macResult == null || macResult.Count == 0 || string.IsNullOrEmpty(macResult[0]?.ToString()))
                                {
                                    return string.Format(Properties.Resources.Error_GetVmMacAddressFailed, vmName);
                                }
                                string macAddressWithoutColons = macResult[0].ToString();
                                string macAddressWithColons = System.Text.RegularExpressions.Regex.Replace(macAddressWithoutColons, "(.{2})", "$1:").TrimEnd(':');

                                string vmIpAddress = string.Empty;
                                var stopwatch = Stopwatch.StartNew();
                                vmIpAddress = await Utils.GetVmIpAddressAsync(vmName, macAddressWithColons);
                                stopwatch.Stop();

                                string targetIp = vmIpAddress.Split(',').Select(ip => ip.Trim()).FirstOrDefault(ip => System.Net.IPAddress.TryParse(ip, out var addr) && addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork);

                                //弹出登录框
                                await System.Windows.Application.Current.Dispatcher.InvokeAsync(() => {
                                    var loginWindow = new SshLoginWindow(vmName, targetIp);
                                    if (loginWindow.ShowDialog() == true)
                                    {
                                        credentials = loginWindow.Credentials;
                                    }
                                });

                                if (credentials == null) return ExHyperV.Properties.Resources.Info_SshLoginCancelledByUser;
                                if (!string.IsNullOrEmpty(targetIp))
                                {
                                    credentials.Host = targetIp;
                                }
                                if (string.IsNullOrEmpty(credentials.Host))
                                {
                                    return string.Format(Properties.Resources.Error_NoValidIpv4AddressFound, "Unknown");
                                }

                            }
                            catch (Exception ex)
                            {
                                ShowMessageOnUIThread(string.Format(Properties.Resources.Error_PreparationFailed, ex.Message));
                                return string.Format(Properties.Resources.Error_PreparationFailed, ex.Message);
                            }


                            await System.Windows.Application.Current.Dispatcher.InvokeAsync(() =>
                            {
                                progressWindow = new ExecutionProgressWindow();
                                progressWindow.Show();
                            });

                            progressWindow.Closed += (s, e) =>
                            {
                                cts.Cancel();
                            };

                            while (true)
                            {
                                var userActionTcs = new TaskCompletionSource<bool>();
                                EventHandler retryHandler = (s, e) => userActionTcs.TrySetResult(true);
                                EventHandler closeHandler = (s, e) => userActionTcs.TrySetResult(false);
                                try
                                {
                                    progressWindow.RetryClicked += retryHandler;
                                    progressWindow.Closed += closeHandler;

                                    if (cts.IsCancellationRequested)
                                    {
                                        cts.Dispose();
                                        cts = new CancellationTokenSource();
                                        progressWindow.Closed += (s, e) => cts.Cancel();
                                    }

                                    if (userActionTcs.Task.IsCompleted && userActionTcs.Task.Result)
                                    {
                                        progressWindow.ResetForRetry();
                                    }
                                    Action<string> log = (message) =>
                                    {
                                        if (!cts.IsCancellationRequested) progressWindow.AppendLog(message);
                                    };
                                    Action<string> updateStatus = (status) =>
                                    {
                                        if (!cts.IsCancellationRequested) progressWindow.UpdateStatus(status);
                                    };

                                    if (cts.IsCancellationRequested) throw new OperationCanceledException();


                                    updateStatus(ExHyperV.Properties.Resources.LinuxDeploy_Step1);
                                    log(ExHyperV.Properties.Resources.LinuxDeploy_Step1);
                                    string homeDirectory;
                                    string remoteTempDir;

                                    using (var client = new SshClient(credentials.Host, credentials.Port, credentials.Username, credentials.Password))
                                    {
                                        client.Connect();
                                        log(ExHyperV.Properties.Resources.Log_SshConnectionSuccess);
                                        var pwdResult = client.RunCommand("pwd");
                                        homeDirectory = pwdResult.Result.Trim();
                                        if (string.IsNullOrEmpty(homeDirectory))
                                        {
                                            throw new Exception(ExHyperV.Properties.Resources.Error_GetLinuxHomeDirectoryFailed);
                                        }
                                        log(string.Format(Properties.Resources.Log_LinuxHomeDirectoryFound, homeDirectory));

                                        remoteTempDir = $"{homeDirectory}/exhyperv_deploy";
                                        client.RunCommand($"mkdir -p {remoteTempDir}/drivers {remoteTempDir}/lib");
                                        log(string.Format(Properties.Resources.Log_TempDeployDirectoryCreated, remoteTempDir));
                                        client.Disconnect();
                                    }
                                    log(ExHyperV.Properties.Resources.Log_RemoteEnvInitializationComplete);

                                    if (!string.IsNullOrEmpty(credentials.ProxyHost) && credentials.ProxyPort.HasValue)
                                    {
                                        updateStatus(ExHyperV.Properties.Resources.LinuxDeploy_Step2);
                                        log(ExHyperV.Properties.Resources.LinuxDeploy_Step2);
                                        log(string.Format(Properties.Resources.Log_ProxyServerInfo, credentials.ProxyHost, credentials.ProxyPort));
                                        string proxyUrl = $"http://{credentials.ProxyHost}:{credentials.ProxyPort}";
                                        string aptProxyContent = $"Acquire::http::Proxy \"{proxyUrl}\";\nAcquire::https::Proxy \"{proxyUrl}\";\n";
                                        string envProxyContent = $"\nexport http_proxy=\"{proxyUrl}\"\nexport https_proxy=\"{proxyUrl}\"\nexport no_proxy=\"localhost,127.0.0.1\"\n";
                                        string remoteAptProxyFile = $"{homeDirectory}/99proxy";
                                        string remoteEnvProxyFile = $"{homeDirectory}/proxy_env";
                                        await sshService.WriteTextFileAsync(credentials, aptProxyContent, remoteAptProxyFile);
                                        await sshService.WriteTextFileAsync(credentials, envProxyContent, remoteEnvProxyFile);
                                        var proxyCommands = new List<string>
                                    {
                                        $"sudo mv {remoteAptProxyFile} /etc/apt/apt.conf.d/99proxy",
                                        $"sudo sh -c 'cat {remoteEnvProxyFile} >> /etc/environment'",
                                        $"rm {remoteEnvProxyFile}",
                                        $"export http_proxy={proxyUrl}",
                                        $"export https_proxy={proxyUrl}"
                                    };
                                        foreach (var cmd in proxyCommands)
                                        {
                                            await sshService.ExecuteSingleCommandAsync(credentials, cmd, log, TimeSpan.FromSeconds(30));
                                        }
                                        log(ExHyperV.Properties.Resources.Log_ProxyConfigurationComplete);
                                    }

                                    log(ExHyperV.Properties.Resources.LinuxDeploy_Step3);
                                    string driverStoreBase = @"C:\Windows\System32\DriverStore\FileRepository";
                                    string preciseDriverPath = FindGpuDriverSourcePath(id);
                                    string sourceDriverPath = preciseDriverPath; // 默认为精准路径

                                    if (string.IsNullOrEmpty(preciseDriverPath))
                                    {
                                        log(ExHyperV.Properties.Resources.Log_GpuDriverNotFoundFallback);
                                        sourceDriverPath = driverStoreBase; // 回退到全量拷贝
                                    }
                                    else
                                    {
                                        log(string.Format(Properties.Resources.Log_PreciseDriverPathLocated, new DirectoryInfo(preciseDriverPath).Name));
                                    }


                                    updateStatus(ExHyperV.Properties.Resources.LinuxDeploy_Step3_Status_Import);
                                    log(ExHyperV.Properties.Resources.LinuxDeploy_Step3_Status_Import);
                                    string sourceFolderName = new DirectoryInfo(sourceDriverPath).Name;
                                    string remoteDestinationPath = $"{remoteTempDir}/drivers/{sourceFolderName}";
                                    await sshService.UploadDirectoryAsync(credentials, sourceDriverPath, remoteDestinationPath);
                                    log(ExHyperV.Properties.Resources.Log_HostDriverImportComplete);
                                    await UploadLocalFilesAsync(sshService, credentials, $"{remoteTempDir}/lib");
                                    log(ExHyperV.Properties.Resources.Log_LocalLibrariesCheckComplete);

                                    updateStatus(ExHyperV.Properties.Resources.LinuxDeploy_Step4);
                                    log(ExHyperV.Properties.Resources.LinuxDeploy_Step4);

                                    var commandsToExecute = new List<Tuple<string, TimeSpan?>>();
                                    bool enableGraphics = credentials.InstallGraphics;

                                    // 1. 下载脚本
                                    var scriptsToDownload = new List<string>
                                {
                                    $"wget -O {remoteTempDir}/install_dxgkrnl.sh {ScriptBaseUrl}install_dxgkrnl.sh",
                                    enableGraphics ? $"wget -O {remoteTempDir}/setup_graphics.sh {ScriptBaseUrl}setup_graphics.sh" : null,
                                    $"wget -O {remoteTempDir}/configure_system.sh {ScriptBaseUrl}configure_system.sh"
                                }.Where(s => s != null).ToList();

                                    foreach (var scriptCmd in scriptsToDownload)
                                    {
                                        await sshService.ExecuteSingleCommandAsync(credentials, scriptCmd, log, TimeSpan.FromMinutes(2));
                                    }
                                    await sshService.ExecuteSingleCommandAsync(credentials, $"chmod +x {remoteTempDir}/*.sh", log, TimeSpan.FromSeconds(10));
                                    log(ExHyperV.Properties.Resources.Log_DxgkrnlModuleCompiling);
                                    string dxgkrnlCommand = withSudo($"{remoteTempDir}/install_dxgkrnl.sh");
                                    var dxgkrnlResult = await sshService.ExecuteCommandAndCaptureOutputAsync(credentials, dxgkrnlCommand, log, TimeSpan.FromMinutes(60));
                                    if (dxgkrnlResult.Output.Contains("STATUS: REBOOT_REQUIRED"))
                                    {
                                        log(ExHyperV.Properties.Resources.Log_KernelUpdateRebootRequired);
                                        updateStatus(ExHyperV.Properties.Resources.Status_RebootingVm);

                                        try
                                        {
                                            await sshService.ExecuteSingleCommandAsync(credentials, withSudo("reboot"), log, TimeSpan.FromSeconds(10));
                                        }
                                        catch (Exception) { }
                                        log(ExHyperV.Properties.Resources.Log_WaitingForVmToComeOnline);
                                        bool isVmUp = await WaitForVmToBeResponsiveAsync(credentials.Host, credentials.Port, cts.Token);
                                        if (!isVmUp) throw new Exception(ExHyperV.Properties.Resources.Error_VmDidNotComeBackOnline);

                                        log(ExHyperV.Properties.Resources.Log_VmReconnectedRestartingDeploy);
                                        continue; //重新执行整个流程
                                    }

                                    if (!dxgkrnlResult.Output.Contains("STATUS: SUCCESS"))
                                    {
                                        throw new Exception(ExHyperV.Properties.Resources.Error_KernelModuleScriptFailed);
                                    }

                                    log(ExHyperV.Properties.Resources.Log_KernelModuleInstallSuccess);


                                    if (enableGraphics)
                                    {
                                        log(ExHyperV.Properties.Resources.Log_ConfiguringMesa);
                                        await sshService.ExecuteSingleCommandAsync(credentials, withSudo($"{remoteTempDir}/setup_graphics.sh"), log, TimeSpan.FromMinutes(20));
                                    }

                                    log(ExHyperV.Properties.Resources.Log_ConfiguringSystem);
                                    string configArgs = enableGraphics ? "enable_graphics" : "no_graphics";
                                    await sshService.ExecuteSingleCommandAsync(credentials, withSudo($"{remoteTempDir}/configure_system.sh {configArgs}"), log, TimeSpan.FromMinutes(5));



                                    updateStatus(ExHyperV.Properties.Resources.LinuxDeploy_Step5);
                                    log(ExHyperV.Properties.Resources.LinuxDeploy_Step5);
                                    try
                                    {
                                        await sshService.ExecuteSingleCommandAsync(credentials, "sudo reboot", log, TimeSpan.FromSeconds(5));
                                    }
                                    catch { }

                                    progressWindow.ShowSuccessState();
                                    return "OK";
                                }
                                catch (OperationCanceledException)
                                {
                                    return ExHyperV.Properties.Resources.Info_OperationCancelled;
                                }
                                catch (Exception ex)
                                {
                                    string errorMsg = string.Format(Properties.Resources.Error_DeploymentFailed, ex.Message);
                                    if (!cts.IsCancellationRequested)
                                    {
                                        progressWindow.AppendLog(string.Format(Properties.Resources.Log_ErrorBlockHeader, errorMsg));
                                        progressWindow.ShowErrorState(ExHyperV.Properties.Resources.Status_DeploymentFailedCheckLogs);
                                    }
                                    else
                                    {
                                        return ExHyperV.Properties.Resources.Info_OperationAbortedByUser;
                                    }

                                    bool shouldRetry = await userActionTcs.Task;
                                    if (!shouldRetry) return errorMsg;
                                }
                                finally
                                {
                                    progressWindow.RetryClicked -= retryHandler;
                                    progressWindow.Closed -= closeHandler;
                                }
                            }
                        }

                    }

                    if (isWin10 && partitionableGpuCount > 1)
                    {
                        Utils.Run($"Start-VM -Name '{vmName}'");
                    }
                    return "OK"; 
                }
                catch (Exception ex)
                {
                    ShowMessageOnUIThread(string.Format(Properties.Resources.Error_FatalExceptionOccurred, ex.Message));
                    return string.Format(Properties.Resources.Error_OperationFailed, ex.Message);
                }
                finally
                {
                    if (disabledGpuInstanceIds.Any())
                    {
                        await Task.Delay(1000);
                        foreach (var instanceId in disabledGpuInstanceIds)
                        {
                            Utils.Run($"Enable-PnpDevice -InstanceId '{instanceId}' -Confirm:$false");
                        }
                    }
                    if (isWin10 && partitionableGpuCount > 1)
                    {
                        string finalMessage = Properties.Resources.Warning_Win10GpuAssignmentNotPersistent;
                        System.Windows.Application.Current.Dispatcher.Invoke(() => Utils.Show(finalMessage));

                    }
                }
            });
        }
        public Task<bool> RemoveGpuPartitionAsync(string vmName, string adapterId)
        {
            return Task.Run(() =>
            {
                var results = Utils.Run2($@"Remove-VMGpuPartitionAdapter -VMName '{vmName}' -AdapterId '{adapterId}' -Confirm:$false");
                if (results != null)
                {
                    string cleanupNotesScript = $@"
                    $vm = Get-VM -Name '{vmName}';
                    $currentNotes = $vm.Notes;
                    if ($currentNotes -match '\[AssignedGPU:[^\]]+\]') {{
                    $cleanedNotes = $currentNotes -replace '\[AssignedGPU:[^\]]+\]', '';
                    Set-VM -VM $vm -Notes $cleanedNotes.Trim();
                        }}
                    ";
                    Utils.Run(cleanupNotesScript);
                    return true;
                }
                return false;
            });
        }

        private string NvidiaReg(string letter)
        {
            // 为NVIDIA显卡注入注册表信息。
            string tempRegFile = Path.Combine(Path.GetTempPath(), $"nvlddmkm_{Guid.NewGuid()}.reg");
            string systemHiveFile = $@"{letter}\Windows\System32\Config\SYSTEM";

            try
            {
                ExecuteCommand($"reg unload HKLM\\OfflineSystem");

                string localKeyPath = @"HKLM\SYSTEM\CurrentControlSet\Services\nvlddmkm";
                if (ExecuteCommand($@"reg export ""{localKeyPath}"" ""{tempRegFile}"" /y") != 0) return Properties.Resources.Error_ExportLocalRegistryInfoFailed;
                if (ExecuteCommand($@"reg load HKLM\OfflineSystem ""{systemHiveFile}""") != 0) return Properties.Resources.Error_OfflineLoadVmRegistryFailed;

                string originalText = @"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\nvlddmkm";
                string targetText = @"HKEY_LOCAL_MACHINE\OfflineSystem\ControlSet001\Services\nvlddmkm";
                string regContent = File.ReadAllText(tempRegFile);
                regContent = regContent.Replace(originalText, targetText);
                regContent = regContent.Replace("DriverStore", "HostDriverStore");
                File.WriteAllText(tempRegFile, regContent);
                ExecuteCommand($@"reg import ""{tempRegFile}""");

                return "OK";
            }
            catch (Exception ex)
            {
                return string.Format(Properties.Resources.Error_NvidiaRegistryProcessingException, ex.Message);
            }
            finally
            {
                ExecuteCommand($"reg unload HKLM\\OfflineSystem");
                if (File.Exists(tempRegFile))
                {
                    File.Delete(tempRegFile);
                }
            }
        }

        private int ExecuteCommand(string command)
        {
            try
            {
                Process process = new()
                {
                    StartInfo =
                    {
                        FileName = "cmd.exe",
                        Arguments = $"/c {command}",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = true
                    }
                };
                process.Start();
                process.WaitForExit();
                return process.ExitCode;
            }
            catch
            {
                return -1;
            }
        }

        private void SetFolderReadOnly(string folderPath)
        {
            var dirInfo = new DirectoryInfo(folderPath);
            dirInfo.Attributes |= FileAttributes.ReadOnly;
            foreach (var subDir in dirInfo.GetDirectories())
            {
                SetFolderReadOnly(subDir.FullName);
            }
            foreach (var file in dirInfo.GetFiles())
            {
                file.Attributes |= FileAttributes.ReadOnly;
            }
        }

        private void RemoveReadOnlyAttribute(string path)
        {
            if (Directory.Exists(path))
            {
                RemoveReadOnlyAttribute(new DirectoryInfo(path));
            }
        }

        private void RemoveReadOnlyAttribute(DirectoryInfo dirInfo)
        {
            dirInfo.Attributes &= ~FileAttributes.ReadOnly;
            foreach (var subDir in dirInfo.GetDirectories())
            {
                RemoveReadOnlyAttribute(subDir);
            }
            foreach (var file in dirInfo.GetFiles())
            {
                file.Attributes &= ~FileAttributes.ReadOnly;
            }
        }
        public async Task<bool> IsHyperVModuleAvailableAsync()
        {
            return await Task.Run(() =>
            {
                var result = Utils.Run("(Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V).State");
                return result.Count > 0;
            });
        }

        private async Task UploadLocalFilesAsync(SshService sshService, SshCredentials credentials, string remoteDirectory)
        {
            string systemWslLibPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "lxss", "lib");

            if (Directory.Exists(systemWslLibPath))
            {
                var allFiles = Directory.GetFiles(systemWslLibPath);

                foreach (var filePath in allFiles)
                {
                    string fileName = Path.GetFileName(filePath);
                    await sshService.UploadFileAsync(credentials, filePath, $"{remoteDirectory}/{fileName}");
                }
            }
        }
        private string FindGpuDriverSourcePath(string gpuInstancePath)
        {
            string sourceFolder = null;
            string fastScript = $@"
    $ErrorActionPreference = 'Stop';
    try {{
        $targetId = '{gpuInstancePath}'.Trim();
        $wmi = Get-CimInstance Win32_VideoController | Where-Object {{ $_.PNPDeviceID -like ""*$targetId*"" }} | Select-Object -First 1;
        
        if ($wmi -and $wmi.InstalledDisplayDrivers) {{
            $drivers = $wmi.InstalledDisplayDrivers -split ',';
            $repoDriver = $drivers | Where-Object {{ $_ -match 'FileRepository' }} | Select-Object -First 1;
            
            if ($repoDriver) {{
                $currentPath = Split-Path -Parent $repoDriver.Trim();
                while ($true) {{
                    if (Get-ChildItem -Path $currentPath -Filter *.inf -ErrorAction SilentlyContinue) {{
                        return $currentPath;
                    }}
                    $parentPath = Split-Path -Parent $currentPath;
                    $parentName = Split-Path -Leaf $parentPath;
                    if ($parentName -eq 'FileRepository') {{
                        return $currentPath;
                    }}
                    if ($parentPath -eq $currentPath) {{ break; }}
                    $currentPath = $parentPath;
                }}
                return (Split-Path -Parent $repoDriver.Trim());
            }}
        }}
    }} catch {{ }}";

            try
            {
                var fastRes = Utils.Run(fastScript);
                if (fastRes != null && fastRes.Count > 0 && fastRes[0] != null)
                {
                    string resultPath = fastRes[0].ToString().Trim();
                    if (!string.IsNullOrEmpty(resultPath) && Directory.Exists(resultPath))
                    {
                        sourceFolder = resultPath;
                    }
                }
            }
            catch { }
            return sourceFolder;
        }
    }
}

================================================================================
FILE: Services\HyperVNUMAService.cs
================================================================================

﻿using System.Diagnostics;
using ExHyperV.Tools;

namespace ExHyperV.Services
{
    public class HyperVNUMAService
    {
        public static async Task<bool> GetNumaSpanningEnabledAsync()
        {
            try
            {
                var results = await Utils.Run2("(Get-VMHost).NumaSpanningEnabled");

                if (results != null && results.Any())
                {
                    var output = results[0]?.BaseObject?.ToString();
                    if (bool.TryParse(output?.Trim(), out bool result))
                    {
                        return result;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Error] Get NUMA via Utils: {ex.Message}");
            }

            return true;
        }

        public static async Task<(bool success, string message)> SetNumaSpanningEnabledAsync(bool enabled)
        {
            try
            {
                string boolStr = enabled ? "$true" : "$false";
                string command = $"Set-VMHost -NumaSpanningEnabled {boolStr}";

                await Utils.Run2(command);

                return (true, "设置已更新");
            }
            catch (PowerShellScriptException psEx)
            {
                return (false, psEx.Message.Trim());
            }
            catch (Exception ex)
            {
                return (false, ex.Message);
            }
        }
    }
}

================================================================================
FILE: Services\HyperVSchedulerService.cs
================================================================================

﻿using ExHyperV.Tools;
using System.Diagnostics;
using System.Diagnostics.Eventing.Reader;

namespace ExHyperV.Services
{
    public enum HyperVSchedulerType
    {
        Classic,
        Core,
        Root,
        Unknown
    }

    public static class HyperVSchedulerService
    {
        public static HyperVSchedulerType GetSchedulerType()
        {
            try
            {
                string query = "*[System[Provider[@Name='Microsoft-Windows-Hyper-V-Hypervisor'] and (EventID=2)]]";
                EventLogQuery eventQuery = new EventLogQuery("System", PathType.LogName, query) { ReverseDirection = true };

                using (EventLogReader logReader = new EventLogReader(eventQuery))
                {
                    EventRecord record = logReader.ReadEvent();
                    if (record != null && record.Properties.Count > 0)
                    {
                        ushort schedulerCode = System.Convert.ToUInt16(record.Properties[0].Value);
                        return schedulerCode switch
                        {
                            1 => HyperVSchedulerType.Classic,
                            2 => HyperVSchedulerType.Classic,
                            3 => HyperVSchedulerType.Core,
                            4 => HyperVSchedulerType.Root,
                            _ => HyperVSchedulerType.Unknown,
                        };
                    }
                }
            }
            catch (System.Exception ex) { Debug.WriteLine($"[HyperVSchedulerService] 查询事件日志失败: {ex.Message}"); }
            return HyperVSchedulerType.Unknown;
        }

        public static async Task<bool> SetSchedulerTypeAsync(HyperVSchedulerType type)
        {
            string typeString = type.ToString();
            string script = $"Start-Process -FilePath 'bcdedit.exe' -ArgumentList '/set hypervisorschedulertype {typeString}' -Verb RunAs -WindowStyle Hidden -Wait";

            try
            {
                await Utils.RunScriptSTA(script);
                return true;
            }
            catch (System.Exception ex)
            {
                Debug.WriteLine($"[HyperVSchedulerService] 使用 Utils.RunScriptSTA 执行 bcdedit 失败: {ex.Message}");
                return false;
            }
        }
    }
}

================================================================================
FILE: Services\IGpuPartitionService.cs
================================================================================

﻿using ExHyperV.Models;

namespace ExHyperV.Services
{
    public interface IGpuPartitionService
    {
        Task<List<GPUInfo>> GetHostGpusAsync();
        Task<List<VMInfo>> GetVirtualMachinesAsync();
        Task<bool> RemoveGpuPartitionAsync(string vmName, string adapterId);
        Task<List<PartitionInfo>> GetPartitionsFromVmAsync(string vmName);
        Task<string> AddGpuPartitionAsync(string vmName, string gpuInstancePath, string gpuManu, PartitionInfo selectedPartition, string Id);
        Task<bool> IsHyperVModuleAvailableAsync();
        Task<string> GetVmStateAsync(string vmName);
        Task ShutdownVmAsync(string vmName);

    }
}

================================================================================
FILE: Services\IHyperVService.cs
================================================================================

﻿using ExHyperV.Models;

namespace ExHyperV.Services
{
    /// <summary>
    /// 定义了MMIO空间检查的结果类型。
    /// </summary>
    public enum MmioCheckResultType
    {
        /// <summary>
        /// MMIO空间充足，无需操作。
        /// </summary>
        Ok,

        /// <summary>
        /// MMIO空间不足，需要用户确认才能进行更新。
        /// </summary>
        NeedsConfirmation,

        /// <summary>
        /// 在检查过程中发生错误。
        /// </summary>
        Error
    }

    /// <summary>
    /// 定义了与Hyper-V和DDA设备交互的服务接口。
    /// </summary>
    public interface IHyperVService
    {
        /// <summary>
        /// 异步获取所有可分配的DDA设备和虚拟机的名称。
        /// </summary>
        /// <returns>包含设备列表和虚拟机名称列表的元组。</returns>
        Task<(List<DeviceInfo> Devices, List<string> VmNames)> GetDdaInfoAsync();

        /// <summary>
        /// 异步检查操作系统是否为服务器版本。
        /// </summary>
        /// <returns>如果是服务器版本，则为true；否则为false。</returns>
        Task<bool> IsServerOperatingSystemAsync();

        /// <summary>
        /// 异步检查指定虚拟机的MMIO空间。
        /// </summary>
        /// <param name="vmName">要检查的虚拟机名称。</param>
        /// <returns>一个包含检查结果类型和相关消息的元组。</returns>
        Task<(MmioCheckResultType Result, string Message)> CheckMmioSpaceAsync(string vmName);

        /// <summary>
        /// 异步强制更新指定虚拟机的MMIO空间（此操作会关闭虚拟机）。
        /// </summary>
        /// <param name="vmName">要更新的虚拟机名称。</param>
        /// <returns>如果操作成功，则为true；否则为false。</returns>
        Task<bool> UpdateMmioSpaceAsync(string vmName);

        /// <summary>
        /// 异步执行DDA设备分配操作。
        /// </summary>
        /// <param name="targetVmName">目标虚拟机名称或"主机"。</param>
        /// <param name="currentVmName">设备当前分配的虚拟机名称。</param>
        /// <param name="instanceId">设备的实例ID。</param>
        /// <param name="path">设备的位置路径。</param>
        /// <returns>一个元组，包含操作是否成功和失败时的错误信息。</returns>
        Task<(bool Success, string? ErrorMessage)> ExecuteDdaOperationAsync(string targetVmName, string currentVmName, string instanceId, string path, IProgress<string>? progress = null);
    }
}

================================================================================
FILE: Services\IMemoryService.cs
================================================================================

﻿using ExHyperV.Models;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace ExHyperV.Services
{
    public interface IMemoryService
    {
        Task<List<VirtualMachineMemoryInfo>> GetVirtualMachinesMemoryConfigurationAsync();
        Task<List<VirtualMachineMemoryInfo>> GetVirtualMachinesMemoryUsageAsync();
        Task<(bool Success, string Message)> SetVmMemoryAsync(VirtualMachineMemoryInfo vmMemory);
    }
}

================================================================================
FILE: Services\INetworkService.cs
================================================================================

﻿using ExHyperV.Models;

namespace ExHyperV.Services
{
    /// <summary>
    /// 定义网络相关操作的服务接口。
    /// 这是 ViewModel 与底层数据获取逻辑之间的契约。
    /// </summary>
    public interface INetworkService
    {
        /// <summary>
        /// 异步获取主机的网络信息，包括所有虚拟交换机和物理网卡。
        /// </summary>
        Task<(List<SwitchInfo> Switches, List<PhysicalAdapterInfo> PhysicalAdapters)> GetNetworkInfoAsync();

        /// <summary>
        /// 异步获取连接到特定虚拟交换机的所有网络适配器（包括虚拟机和主机）的详细状态。
        /// </summary>
        Task<List<AdapterInfo>> GetFullSwitchNetworkStateAsync(string switchName);

        /// <summary>
        /// 异步更新一个虚拟交换机的配置。
        /// </summary>
        Task UpdateSwitchConfigurationAsync(string switchName, string mode, string? adapterDescription, bool allowManagementOS, bool enableDhcp);
        /// <summary>
        /// 异步创建一个新的虚拟交换机。
        /// </summary>
        Task CreateSwitchAsync(string name, string type, string? adapterDescription);

        /// <summary>
        /// 异步删除一个指定的虚拟交换机。
        /// </summary>
        Task DeleteSwitchAsync(string switchName);
    }
}

================================================================================
FILE: Services\InstancesService.cs
================================================================================

﻿using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ExHyperV.Models;
using ExHyperV.Tools;

namespace ExHyperV.Services
{
    public class InstancesService
    {
        public Task<List<VMInfo>> GetVmListAsync()
        {
            return Task.Run(() =>
            {
                var vmList = new List<VMInfo>();
                string script = @"
                    Get-VM | ForEach-Object {
                        $vhd = Get-VMHardDiskDrive -VMName $_.Name | Select-Object -First 1
                        $vhdSize = 0
                        if ($vhd -and $vhd.Path) {
                            try {
                                $vhdInfo = Get-VHD -Path $vhd.Path -ErrorAction SilentlyContinue
                                if ($vhdInfo) { $vhdSize = $vhdInfo.Size }
                            } catch {}
                        }
                        # 修改：直接获取 Ticks
                        $upTicks = $_.Uptime.Ticks
                        
                        [PSCustomObject]@{
                            Name = $_.Name
                            State = $_.State
                            Notes = $_.Notes
                            Generation = $_.Generation
                            CPU = $_.ProcessorCount
                            RAM = [Math]::Round($_.MemoryStartup / 1GB, 1)
                            Disk = [Math]::Round($vhdSize / 1GB, 0)
                            UptimeTicks = $upTicks
                        }
                    }";

                var results = Utils.Run(script);
                if (results != null)
                {
                    foreach (var vm in results)
                    {
                        string name = vm.Members["Name"]?.Value?.ToString() ?? "Unknown";
                        string stateRaw = vm.Members["State"]?.Value?.ToString() ?? "Off";
                        string notes = vm.Members["Notes"]?.Value?.ToString() ?? "";
                        int gen = int.Parse(vm.Members["Generation"]?.Value?.ToString() ?? "0");
                        int cpu = int.Parse(vm.Members["CPU"]?.Value?.ToString() ?? "0");
                        double ram = double.Parse(vm.Members["RAM"]?.Value?.ToString() ?? "0");
                        double diskSize = double.Parse(vm.Members["Disk"]?.Value?.ToString() ?? "0");

                        // 修改：解析 Ticks
                        long ticks = 0;
                        if (vm.Members["UptimeTicks"]?.Value != null)
                        {
                            long.TryParse(vm.Members["UptimeTicks"].Value.ToString(), out ticks);
                        }
                        TimeSpan uptime = TimeSpan.FromTicks(ticks);

                        var info = new VMInfo(name, "", "", "", null, gen, stateRaw == "Running", notes, MapStateToText(stateRaw), cpu, ram, $"{diskSize}G", uptime);
                        vmList.Add(info);
                    }
                }
                return vmList;
            });
        }

        // 修改：返回值元组改为 (string State, TimeSpan Uptime)
        public Task<(string State, TimeSpan Uptime)> GetVmDynamicInfoAsync(string vmName)
        {
            return Task.Run(() =>
            {
                // 获取 Uptime.Ticks
                var result = Utils.Run($"(Get-VM -Name '{vmName}') | Select-Object State, @{{N='UpTicks';E={{$_.Uptime.Ticks}}}}");
                if (result != null && result.Count > 0)
                {
                    string state = MapStateToText(result[0].Members["State"]?.Value?.ToString());

                    long ticks = 0;
                    if (result[0].Members["UpTicks"]?.Value != null)
                    {
                        long.TryParse(result[0].Members["UpTicks"].Value.ToString(), out ticks);
                    }
                    return (state, TimeSpan.FromTicks(ticks));
                }
                return ("未知", TimeSpan.Zero);
            });
        }

        private static string MapStateToText(string state) => state switch
        {
            "Running" => "运行中",
            "Off" => "已关机",
            "Paused" => "已暂停",
            "ShuttingDown" => "正在关闭",
            "Stopping" => "正在关闭",
            "Starting" => "正在启动",
            "Saving" => "正在保存",
            "Saved" => "已保存",
            _ => state
        };

        public Task ExecuteControlActionAsync(string vmName, string action)
        {
            return Task.Run(() =>
            {
                string cmd = action switch
                {
                    "Start" => $"Start-VM -Name '{vmName}'",
                    "Stop" => $"Stop-VM -Name '{vmName}'",
                    "TurnOff" => $"Stop-VM -Name '{vmName}' -TurnOff",
                    "Suspend" => $"Suspend-VM -Name '{vmName}'",
                    "Save" => $"Save-VM -Name '{vmName}'",
                    "Restart" => $"Restart-VM -Name '{vmName}' -Force",
                    _ => null
                };
                if (!string.IsNullOrEmpty(cmd)) Utils.Run(cmd);
            });
        }

        public Task UpdateOsTypeNoteAsync(string vmName, string osType)
        {
            return Task.Run(() =>
            {
                string script = $@"
                    $vm = Get-VM -Name '{vmName}';
                    $cleaned = $vm.Notes -replace '\[OSType:[^\]]+\]', '';
                    Set-VM -VM $vm -Notes ($cleaned.Trim() + ' [OSType:{osType.ToLower()}]').Trim()";
                Utils.Run(script);
            });
        }
    }
}

================================================================================
FILE: Services\IVmProcessorService.cs
================================================================================

﻿using ExHyperV.ViewModels;

namespace ExHyperV.Services
{
    public interface IVmProcessorService
    {
        /// <summary>
        /// 异步获取指定虚拟机的处理器配置。
        /// </summary>
        /// <param name="vmName">虚拟机的名称。</param>
        /// <returns>包含处理器配置的 ViewModel，如果找不到则返回 null。</returns>
        Task<VMProcessorViewModel?> GetVmProcessorAsync(string vmName);

        /// <summary>
        /// 异步设置指定虚拟机的处理器配置。
        /// </summary>
        /// <param name="vmName">虚拟机的名称。</param>
        /// <param name="processorSettings">要应用的新处理器配置。</param>
        /// <returns>一个元组，指示操作是否成功以及相关的消息。</returns>
        Task<(bool Success, string Message)> SetVmProcessorAsync(string vmName, VMProcessorViewModel processorSettings);
    }
}

================================================================================
FILE: Services\MemoryService.cs
================================================================================

﻿using ExHyperV.Models;
using ExHyperV.Tools;
using System.Management.Automation;
using System.Text;
using System.Text.RegularExpressions;

namespace ExHyperV.Services
{
    public class MemoryService : IMemoryService
    {
        public async Task<List<VirtualMachineMemoryInfo>> GetVirtualMachinesMemoryConfigurationAsync()
        {
            string script = @"
                Get-VM | ForEach-Object {
                    $vm = $_
                    $memoryConfig = Get-VMMemory -VMName $vm.VMName
                    
                    [PSCustomObject]@{
                        VMName               = $vm.VMName
                        State                = $vm.State.ToString()
                        DynamicMemoryEnabled = [bool]$memoryConfig.DynamicMemoryEnabled
                        StartupMB            = [long]($memoryConfig.Startup / 1MB)
                        MinimumMB            = [long]($memoryConfig.Minimum / 1MB)
                        MaximumMB            = [long]($memoryConfig.Maximum / 1MB)
                        AssignedMB           = [long]($vm.MemoryAssigned / 1MB)
                        DemandMB             = [long]($vm.MemoryDemand / 1MB)
                        Status               = $vm.MemoryStatus
                        Buffer               = [int]$memoryConfig.Buffer
                        Priority             = [int]$memoryConfig.Priority
                    }
                }";

            var results = await Utils.Run2(script);
            return results?.Select(ParsePsoToModel).ToList() ?? new List<VirtualMachineMemoryInfo>();
        }

        public async Task<List<VirtualMachineMemoryInfo>> GetVirtualMachinesMemoryUsageAsync()
        {
            string script = @"
                Get-VM | Where-Object { $_.State -eq 'Running' } | ForEach-Object {
                    $vm = $_
                    [PSCustomObject]@{
                        VMName      = $vm.VMName
                        State       = $vm.State.ToString()
                        AssignedMB  = [long]($vm.MemoryAssigned / 1MB)
                        DemandMB    = [long]($vm.MemoryDemand / 1MB)
                        Status      = $vm.MemoryStatus
                    }
                }";

            var results = await Utils.Run2(script);
            return results?.Select(ParsePsoToModel).ToList() ?? new List<VirtualMachineMemoryInfo>();
        }

        public async Task<(bool Success, string Message)> SetVmMemoryAsync(VirtualMachineMemoryInfo vmMemory)
        {
            try
            {
                var sb = new StringBuilder();
                string escapedName = vmMemory.VMName.Replace("'", "''");
                long startupBytes = vmMemory.StartupMB * 1024 * 1024;

                if (!vmMemory.DynamicMemoryEnabled)
                {
                    sb.Append($"Set-VMMemory -VMName '{escapedName}' -DynamicMemoryEnabled $false -StartupBytes {startupBytes} -Priority {vmMemory.Priority} -ErrorAction Stop");
                }
                else
                {
                    long minBytes = vmMemory.MinimumMB * 1024 * 1024;
                    long maxBytes = vmMemory.MaximumMB * 1024 * 1024;
                    sb.Append($"Set-VMMemory -VMName '{escapedName}' -DynamicMemoryEnabled $true -StartupBytes {startupBytes} -MinimumBytes {minBytes} -MaximumBytes {maxBytes} -Buffer {vmMemory.Buffer} -Priority {vmMemory.Priority} -ErrorAction Stop");
                }

                await Utils.Run2(sb.ToString());
                return (true, ExHyperV.Properties.Resources.SettingsSavedSuccessfully);
            }
            catch (Exception ex)
            {
                return (false, GetFriendlyErrorMessage(ex.Message));
            }
        }

        private string GetFriendlyErrorMessage(string rawMessage)
        {
            if (string.IsNullOrWhiteSpace(rawMessage)) return ExHyperV.Properties.Resources.UnknownError;
            string cleanMsg = rawMessage.Trim();
            cleanMsg = Regex.Replace(cleanMsg, @"[\(\（].*?ID\s+[a-fA-F0-9-]{36}.*?[\)\）]", "");
            cleanMsg = cleanMsg.Replace("\r", "").Replace("\n", " ");
            var parts = cleanMsg.Split(new[] { '。', '.' }, StringSplitOptions.RemoveEmptyEntries)
                                .Select(s => s.Trim())
                                .Where(s => !string.IsNullOrWhiteSpace(s))
                                .ToList();
            if (parts.Count >= 2)
            {
                var lastPart = parts.Last();
                if (lastPart.Length > 2) return lastPart + "。";
            }
            return cleanMsg;
        }

        private VirtualMachineMemoryInfo ParsePsoToModel(PSObject pso)
        {
            if (pso == null) return null;
            var model = new VirtualMachineMemoryInfo();
            model.VMName = pso.Properties["VMName"]?.Value?.ToString() ?? string.Empty;
            model.State = pso.Properties["State"]?.Value?.ToString() ?? string.Empty;
            model.Status = pso.Properties["Status"]?.Value?.ToString() ?? string.Empty;
            if (pso.Properties["DynamicMemoryEnabled"]?.Value != null)
                model.DynamicMemoryEnabled = Convert.ToBoolean(pso.Properties["DynamicMemoryEnabled"].Value);
            long GetLong(string name) => pso.Properties[name]?.Value != null ? Convert.ToInt64(pso.Properties[name].Value) : 0L;
            int GetInt(string name) => pso.Properties[name]?.Value != null ? Convert.ToInt32(pso.Properties[name].Value) : 0;
            model.StartupMB = GetLong("StartupMB");
            model.MinimumMB = GetLong("MinimumMB");
            model.MaximumMB = GetLong("MaximumMB");
            model.AssignedMB = GetLong("AssignedMB");
            model.DemandMB = GetLong("DemandMB");
            model.Buffer = GetInt("Buffer");
            model.Priority = GetInt("Priority");
            return model;
        }
    }
}

================================================================================
FILE: Services\NetworkService.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Management.Automation;
using ExHyperV.Models;
using ExHyperV.Tools;

namespace ExHyperV.Services
{
    public class NetworkService : INetworkService
    {
        public async Task<(List<SwitchInfo> Switches, List<PhysicalAdapterInfo> PhysicalAdapters)> GetNetworkInfoAsync()
        {
            return await Task.Run(() =>
            {
                var switchList = new List<SwitchInfo>();
                var physicalAdapterList = new List<PhysicalAdapterInfo>();

                try
                {
                    Utils.Run("Set-ExecutionPolicy RemoteSigned -Scope Process -Force");

                    if (Utils.Run("Get-Module -ListAvailable -Name Hyper-V").Count == 0)
                    {
                        return (switchList, physicalAdapterList);
                    }

                    var phydata = Utils.Run(@"Get-NetAdapter -Physical | select Name, InterfaceDescription");
                    if (phydata != null)
                    {
                        foreach (var result in phydata)
                        {
                            var phyDesc = result.Properties["InterfaceDescription"]?.Value?.ToString();
                            if (!string.IsNullOrEmpty(phyDesc))
                            {
                                physicalAdapterList.Add(new PhysicalAdapterInfo(phyDesc));
                            }
                        }
                    }

                    var switchdata = Utils.Run(@"Get-VMSwitch | Select-Object Name, Id, SwitchType, AllowManagementOS, NetAdapterInterfaceDescription");
                    if (switchdata != null)
                    {
                        foreach (var result in switchdata)
                        {
                            var switchName = result.Properties["Name"]?.Value?.ToString() ?? string.Empty;
                            var switchType = result.Properties["SwitchType"]?.Value?.ToString() ?? string.Empty;
                            var host = result.Properties["AllowManagementOS"]?.Value?.ToString() ?? string.Empty;
                            var id = result.Properties["Id"]?.Value?.ToString() ?? string.Empty;
                            var phydesc = result.Properties["NetAdapterInterfaceDescription"]?.Value?.ToString() ?? string.Empty;

                            string? icsAdapter = GetIcsSourceAdapterName(switchName);
                            if (icsAdapter != null)
                            {
                                switchType = "NAT";
                                phydesc = icsAdapter;
                            }

                            if (!string.IsNullOrEmpty(switchName))
                            {
                                switchList.Add(new SwitchInfo(switchName, switchType, host, id, phydesc));
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error in GetNetworkInfoAsync: {ex}");
                    throw new InvalidOperationException(Properties.Resources.Error_GetNetworkInfoFailed, ex);
                }

                return (switchList, physicalAdapterList);
            });
        }

        public async Task<List<AdapterInfo>> GetFullSwitchNetworkStateAsync(string switchName)
        {
            return await Task.Run(async () =>
            {
                string vmAdaptersScript =
                    $@"Get-VMNetworkAdapter -VMName * | Where-Object {{ $_.SwitchName -eq '{switchName}' }} | " +
                    "Select-Object VMName, " +
                    "@{Name='MacAddress'; Expression={ " +
                    "  $m = ($_.MacAddress -replace '[^0-9A-F]', '').ToUpper(); " +
                    "  if($m.Length -eq 12) { $m -replace '(..)(..)(..)(..)(..)(..)', '$1:$2:$3:$4:$5:$6' } else { $m } " +
                    "}}, " +
                    "@{Name='AdapterStatus'; Expression={($_.Status | Out-String).Trim()}}";

                string hostAdapterScript =
                    $@"
            $v = Get-VMNetworkAdapter -ManagementOS | Where-Object {{ $_.SwitchName -eq '{switchName}' }};
            if ($v) {{
                $targetMac = $v.MacAddress -replace '[^0-9A-F]', '';
                $n = Get-NetAdapter -IncludeHidden | Where-Object {{ (($_.MacAddress -replace '[^0-9A-F]', '') -eq $targetMac) -and ($_.InterfaceDescription -like '*Hyper-V*') }} | Select-Object -First 1;
                if ($n) {{
                    $rm = ($n.MacAddress -replace '[^0-9A-F]', '').ToUpper();
                    $fm = if($rm.Length -eq 12) {{ $rm -replace '(..)(..)(..)(..)(..)(..)', '$1:$2:$3:$4:$5:$6' }} else {{ $rm }};
                    $ipList = (Get-NetIPAddress -InterfaceIndex $n.InterfaceIndex -ErrorAction SilentlyContinue).IPAddress;
                    $ips = if($ipList) {{ $ipList -join ',' }} else {{ '' }};
                    [PSCustomObject]@{{
                        VMName      = '(ManagementOS)';
                        MacAddress  = $fm;
                        Status      = $n.Status.ToString();
                        IPAddresses = $ips;
                    }};
                }}
            }}";

                try
                {
                    var allAdapters = new List<AdapterInfo>();
                    var vmResults = Utils.Run(vmAdaptersScript);
                    if (vmResults != null)
                    {
                        var tasks = vmResults.Select(async pso =>
                        {
                            var vmName = pso.Properties["VMName"]?.Value?.ToString() ?? "";
                            var macAddress = pso.Properties["MacAddress"]?.Value?.ToString() ?? "";
                            var adapterStatus = pso.Properties["AdapterStatus"]?.Value?.ToString() ?? "";
                            var ipAddresses = await Utils.GetVmIpAddressAsync(vmName, macAddress);
                            return new AdapterInfo(vmName, macAddress, adapterStatus, ipAddresses);
                        });
                        allAdapters.AddRange(await Task.WhenAll(tasks));
                    }

                    var stopwatch = Stopwatch.StartNew();
                    System.Collections.ObjectModel.Collection<PSObject>? hostResults = null;
                    while (stopwatch.ElapsedMilliseconds < 2000)
                    {
                        hostResults = Utils.Run(hostAdapterScript);
                        if (hostResults != null && hostResults.Count > 0)
                        {
                            var ipValue = hostResults[0].Properties["IPAddresses"]?.Value?.ToString();
                            if (!string.IsNullOrEmpty(ipValue)) break;
                        }
                        await Task.Delay(200);
                    }
                    stopwatch.Stop();

                    if (hostResults != null)
                    {
                        foreach (var pso in hostResults)
                        {
                            string rawVmName = pso.Properties["VMName"]?.Value?.ToString() ?? "";
                            allAdapters.Add(new AdapterInfo(
                                rawVmName == "(ManagementOS)" ? ExHyperV.Properties.Resources.DisplayName_HostManagementOS : rawVmName,
                                pso.Properties["MacAddress"]?.Value?.ToString() ?? "",
                                pso.Properties["Status"]?.Value?.ToString() ?? "",
                                pso.Properties["IPAddresses"]?.Value?.ToString() ?? ""
                            ));
                        }
                    }
                    return allAdapters;
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error getting full network state for switch '{switchName}': {ex.Message}");
                    return new List<AdapterInfo>();
                }
            });
        }
        public async Task UpdateSwitchConfigurationAsync(string switchName, string mode, string? adapterDescription, bool allowManagementOS, bool enableDhcp)
        {
            await Utils.UpdateSwitchConfigurationAsync(switchName, mode, adapterDescription, allowManagementOS, enableDhcp);
        }

        public async Task CreateSwitchAsync(string name, string type, string? adapterDescription)
        {
            try
            {
                string script;
                switch (type.ToUpper())
                {
                    case "EXTERNAL":
                        if (string.IsNullOrEmpty(adapterDescription))
                        {
                            throw new ArgumentException(Properties.Resources.Error_ExternalSwitchRequiresPhysicalAdapter);
                        }
                        script = $"New-VMSwitch -Name '{name}' -NetAdapterInterfaceDescription '{adapterDescription}' -AllowManagementOS $true";
                        await Task.Run(() => Utils.Run(script));
                        break;
                    case "NAT":
                        script = $"New-VMSwitch -Name '{name}' -SwitchType Internal";
                        await Task.Run(() => Utils.Run(script));
                        await Task.Delay(3000);
                        await UpdateSwitchConfigurationAsync(name, "NAT", adapterDescription, true, true);
                        break;
                    case "INTERNAL":
                    default:
                        script = $"New-VMSwitch -Name '{name}' -SwitchType Internal";
                        await Task.Run(() => Utils.Run(script));
                        break;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in CreateSwitchAsync: {ex}");
                throw new InvalidOperationException(string.Format(Properties.Resources.Error_CreateSwitchFailed, name, ex.Message), ex);
            }
        }

        public async Task DeleteSwitchAsync(string switchName)
        {
            await Task.Run(() =>
            {
                try
                {
                    ClearAllIcsSettings();
                    string script = $"Remove-VMSwitch -Name '{switchName}' -Force";
                    Utils.Run(script);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error in DeleteSwitchAsync: {ex}");
                    throw new InvalidOperationException(string.Format(Properties.Resources.Error_DeleteSwitchFailed, switchName), ex);
                }
            });
        }

        private void ClearAllIcsSettings()
        {
            try
            {
                string script = @"
                    $netShareManager = New-Object -ComObject HNetCfg.HNetShare;
                    foreach ($connection in $netShareManager.EnumEveryConnection) {
                        $config = $netShareManager.INetSharingConfigurationForINetConnection.Invoke($connection);
                        if ($config.SharingEnabled) {
                            $config.DisableSharing();
                        }
                    }";
                Utils.Run(script);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Exception in ClearAllIcsSettings: {ex}");
            }
        }

        private string? GetIcsSourceAdapterName(string switchName)
        {
            string script = @"
            param([string]$switchName)
            try {
                $PublicAdapterNameToFind = ""vEthernet ({0})"" -f $switchName
                $netShareManager = New-Object -ComObject HNetCfg.HNetShare
                $icsSourceAdapterName = $null
                $icsGatewayIsCorrect = $false
                foreach ($connection in $netShareManager.EnumEveryConnection) {
                    $config = $netShareManager.INetSharingConfigurationForINetConnection.Invoke($connection)
                    if ($config.SharingEnabled) {
                        $props = $netShareManager.NetConnectionProps.Invoke($connection)
                        if (($config.SharingConnectionType -eq 1) -and ($props.Name -eq $PublicAdapterNameToFind)) {
                            $icsGatewayIsCorrect = $true
                        }
                        elseif ($config.SharingConnectionType -eq 0) {
                            $icsSourceAdapterName = $props.Name
                        }
                    }
                }
                if (($icsGatewayIsCorrect) -and ($null -ne $icsSourceAdapterName)) {
                    try {
                        $adapterDetails = Get-NetAdapter -Name $icsSourceAdapterName -ErrorAction Stop
                        return $adapterDetails.InterfaceDescription
                    }
                    catch {
                        return $icsSourceAdapterName
                    }
                }
                return $null
            }
            catch {
                return $null
            }";

            try
            {
                using (var ps = PowerShell.Create())
                {
                    ps.AddScript(script);
                    ps.AddParameter("switchName", switchName);
                    var results = ps.Invoke();
                    if (ps.Streams.Error.Count > 0) return null;
                    if (results.Count > 0 && results[0] != null) return results[0].BaseObject?.ToString();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Exception in GetIcsSourceAdapterName: {ex}");
                return null;
            }

            return null;
        }
    }
}

================================================================================
FILE: Services\PciInfoProvider.cs
================================================================================

﻿using System.IO;
using System.Text.RegularExpressions;
using System.Windows;

public class PciInfoProvider
{

    private readonly Uri _pciResourceUri = new Uri("/assets/pci.ids", UriKind.Relative);
    private static readonly Regex VendorRegex = new Regex(@"^([0-9a-f]{4})\s+(.+)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    private Dictionary<string, string> _vendorDatabase;
    private bool _isInitialized = false;

    public PciInfoProvider() { }

    public async Task EnsureInitializedAsync()
    {
        if (_isInitialized) return;

        _vendorDatabase = new Dictionary<string, string>();

        var resourceInfo = Application.GetResourceStream(_pciResourceUri);

        if (resourceInfo == null)
        {
            throw new FileNotFoundException(ExHyperV.Properties.Resources.Error_EmbeddedWpfResourceNotFound, _pciResourceUri.ToString());
        }

        using (var stream = resourceInfo.Stream)
        using (var reader = new StreamReader(stream))
        {
            string line;
            while ((line = await reader.ReadLineAsync()) != null)
            {
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#") || line.StartsWith("\t")) continue;
                Match match = VendorRegex.Match(line);
                if (match.Success)
                {
                    string vendorId = match.Groups[1].Value;
                    string vendorName = match.Groups[2].Value.Trim();
                    int commentIndex = vendorName.IndexOf(" (");
                    if (commentIndex > 0)
                    {
                        vendorName = vendorName.Substring(0, commentIndex);
                    }
                    if (!_vendorDatabase.ContainsKey(vendorId))
                    {
                        _vendorDatabase[vendorId] = vendorName;
                    }
                }
            }
        }
        _isInitialized = true;
    }
    public string GetVendorFromInstanceId(string instanceId)
    {
        if (!_isInitialized || string.IsNullOrEmpty(instanceId) || _vendorDatabase.Count == 0) return "Unknown";
        var match = Regex.Match(instanceId, @"SUBSYS_[0-9A-F]{4}([0-9A-F]{4})", RegexOptions.IgnoreCase);
        if (match.Success)
        {
            string svid = match.Groups[1].Value.ToLower();
            if (_vendorDatabase.TryGetValue(svid, out var vendorName))
            {
                return vendorName;
            }
        }
        return "Unknown";
    }
}

================================================================================
FILE: Services\SettingsService.cs
================================================================================

﻿using System.Diagnostics;
using System.IO;
using System.Windows;
using System.Xml.Linq;
using ExHyperV.Properties;
using Wpf.Ui.Appearance;
using System.Net.Http;

namespace ExHyperV.Services
{

    public record UpdateResult(bool IsUpdateAvailable, string LatestVersion);
    internal class GitHubRelease
    {
        public string tag_name { get; set; }
    }
    public static class SettingsService
    {

        private static readonly HttpClient _httpClient = new HttpClient();
        private const string GitHubApiUrl = "https://api.github.com/repos/Justsenger/ExHyperV/releases/latest";
        private const string FallbackUrl = "https://update.shalingye.workers.dev/";

        static SettingsService()
        {
            _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("ExHyperV-App-Check");
        }

        public static async Task<UpdateResult> CheckForUpdateAsync(string currentVersion)
        {
            string latestVersionTag = null;
            try
            {
                var response = await _httpClient.GetAsync(GitHubApiUrl);
                if (response.IsSuccessStatusCode)
                {
                    var jsonStream = await response.Content.ReadAsStreamAsync();
                    var release = await System.Text.Json.JsonSerializer.DeserializeAsync<GitHubRelease>(jsonStream);
                    latestVersionTag = release?.tag_name;
                }
                else
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                }
            }
            catch (Exception ex)
            {
            }

            if (string.IsNullOrEmpty(latestVersionTag))
            {
                try
                {
                    latestVersionTag = (await _httpClient.GetStringAsync(FallbackUrl))?.Trim();
                }
                catch (Exception ex)
                {
                    throw new Exception(ExHyperV.Properties.Resources.Error_CheckForUpdateFailed);
                }
            }

            if (string.IsNullOrEmpty(latestVersionTag))
            {
                return new UpdateResult(false, currentVersion);
            }

            var cleanCurrentStr = currentVersion.TrimStart('V', 'v').Split('-')[0];
            var cleanLatestStr = latestVersionTag.TrimStart('V', 'v').Split('-')[0];

            if (Version.TryParse(cleanCurrentStr, out var currentVer) && Version.TryParse(cleanLatestStr, out var latestVer))
            {
                bool isUpdateAvailable = latestVer > currentVer;
                return new UpdateResult(isUpdateAvailable, latestVersionTag);
            }
            bool updateAvailableByString = !string.Equals(latestVersionTag, currentVersion, StringComparison.OrdinalIgnoreCase);
            return new UpdateResult(updateAvailableByString, latestVersionTag);
        }
        private const string ConfigFilePath = "config.xml";

        // 从XML加载语言设置
        public static string GetLanguage()
        {
            if (!File.Exists(ConfigFilePath)) return "en-US"; // 默认英文

            try
            {
                XDocument configDoc = XDocument.Load(ConfigFilePath);
                return configDoc.Root?.Element("Language")?.Value ?? "en-US";
            }
            catch
            {
                return "en-US"; // 文件损坏则返回默认值
            }
        }

        // 保存语言设置并重启应用
        public static void SetLanguageAndRestart(string languageName)
        {
            string languageCode = languageName == "中文" ? "zh-CN" : "en-US";

            XDocument configDoc;
            if (File.Exists(ConfigFilePath))
            {
                configDoc = XDocument.Load(ConfigFilePath);
                var languageElement = configDoc.Root?.Element("Language");
                if (languageElement != null)
                {
                    languageElement.Value = languageCode;
                }
                else
                {
                    configDoc.Root?.Add(new XElement("Language", languageCode));
                }
            }
            else
            {
                configDoc = new XDocument(new XElement("Config", new XElement("Language", languageCode)));
            }
            configDoc.Save(ConfigFilePath);

            // 重启应用
            var exePath = Process.GetCurrentProcess().MainModule?.FileName;
            if (exePath != null)
            {
                Process.Start(exePath);
            }
            Application.Current.Shutdown();
        }

        // 获取当前主题
        public static string GetTheme()
        {
            return ApplicationThemeManager.GetAppTheme() == ApplicationTheme.Dark ? Resources.dark : Resources.light;
        }

        // 应用新主题
        public static void ApplyTheme(string themeName)
        {
            var theme = themeName == Resources.dark ? ApplicationTheme.Dark : ApplicationTheme.Light;
            ApplicationThemeManager.Apply(theme);
        }
    }
}

================================================================================
FILE: Services\SshService.cs
================================================================================

﻿using System.IO;
using System.Text;
using ExHyperV.Models;
using Renci.SshNet;

namespace ExHyperV.Services
{
    public class SshCommandErrorException : Exception
    {
        public SshCommandErrorException(string message) : base(message) { }
    }

    public class SshCommandResult
    {
        public string Output { get; }
        public int ExitStatus { get; }

        public SshCommandResult(string output, int exitStatus)
        {
            Output = output;
            ExitStatus = exitStatus;
        }
    }

    public class SshService
    {
        private static readonly Encoding Utf8NoBom = new UTF8Encoding(false);
        public async Task<string> ExecuteSingleCommandAsync(SshCredentials credentials, string command, Action<string> logCallback, TimeSpan? commandTimeout = null)
        {
            string commandToExecute = command; 
            string commandToLog = command;

            var connectionInfo = new ConnectionInfo(credentials.Host, credentials.Username,
                new PasswordAuthenticationMethod(credentials.Username, credentials.Password))
            {
                Timeout = TimeSpan.FromSeconds(30)
            };

            using (var client = new SshClient(connectionInfo))
            {
                await Task.Run(() => client.Connect());

                if (command.Trim().StartsWith("sudo"))
                {
                    string actualCommand = command.Substring(5).Trim(); 
                    string escapedCommand = actualCommand.Replace("'", "'\\''");
                    commandToExecute = $"echo '{credentials.Password}' | sudo -S -p '' bash -c '{escapedCommand}'";
                }
                var sshCommand = client.CreateCommand(commandToExecute);
                sshCommand.CommandTimeout = commandTimeout ?? TimeSpan.FromMinutes(30);

                var asyncResult = sshCommand.BeginExecute();
                var stdoutTask = ReadStreamAsync(sshCommand.OutputStream, Encoding.UTF8, logCallback);
                var stderrTask = ReadStreamAsync(sshCommand.ExtendedOutputStream, Encoding.UTF8, logCallback);
                await Task.Run(() => sshCommand.EndExecute(asyncResult));
                await Task.WhenAll(stdoutTask, stderrTask);

                client.Disconnect();

                if (sshCommand.ExitStatus != 0)
                {
                    throw new SshCommandErrorException(string.Format(Properties.Resources.Error_SshCommandFailed, sshCommand.ExitStatus, sshCommand.Error));
                }
                return sshCommand.Result;
            }
        }

        public async Task<SshCommandResult> ExecuteCommandAndCaptureOutputAsync(SshCredentials credentials, string command, Action<string> logCallback, TimeSpan? commandTimeout = null)
        {
            string commandToExecute = command;
            var outputBuilder = new StringBuilder();

            Action<string> combinedLogCallback = (log) =>
            {
                logCallback(log);
                outputBuilder.Append(log);
            };

            var connectionInfo = new ConnectionInfo(credentials.Host, credentials.Username,
                new PasswordAuthenticationMethod(credentials.Username, credentials.Password))
            {
                Timeout = TimeSpan.FromSeconds(30)
            };

            using (var client = new SshClient(connectionInfo))
            {
                await Task.Run(() => client.Connect());

                if (command.Trim().StartsWith("sudo"))
                {
                    string actualCommand = command.Substring(5).Trim();
                    string escapedCommand = actualCommand.Replace("'", "'\\''");
                    commandToExecute = $"echo '{credentials.Password}' | sudo -S -p '' bash -c '{escapedCommand}'";
                }

                var sshCommand = client.CreateCommand(commandToExecute);
                sshCommand.CommandTimeout = commandTimeout ?? TimeSpan.FromMinutes(30);

                var asyncResult = sshCommand.BeginExecute();
                var stdoutTask = ReadStreamAsync(sshCommand.OutputStream, Encoding.UTF8, combinedLogCallback);
                var stderrTask = ReadStreamAsync(sshCommand.ExtendedOutputStream, Encoding.UTF8, combinedLogCallback);

                await Task.Run(() => sshCommand.EndExecute(asyncResult));
                await Task.WhenAll(stdoutTask, stderrTask);

                client.Disconnect();
                return new SshCommandResult(outputBuilder.ToString(), sshCommand.ExitStatus ?? -1);
            }
        }
        
        private async Task ReadStreamAsync(Stream stream, Encoding encoding, Action<string> logCallback)
        {
            var buffer = new byte[1024];
            int bytesRead;
            try
            {
                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) > 0)
                {
                    logCallback(encoding.GetString(buffer, 0, bytesRead));
                }
            }
            catch (ObjectDisposedException)
            {
            }
        }

        public Task UploadFileAsync(SshCredentials credentials, string localPath, string remotePath)
        {
            return Task.Run(() =>
            {
                var connectionInfo = new ConnectionInfo(credentials.Host, credentials.Username,
                    new PasswordAuthenticationMethod(credentials.Username, credentials.Password));

                using (var sftp = new SftpClient(connectionInfo))
                {
                    sftp.Connect();
                    using (var fileStream = new FileStream(localPath, FileMode.Open, FileAccess.Read))
                    {
                        sftp.UploadFile(fileStream, remotePath);
                    }
                    sftp.Disconnect();
                }
            });
        }
        public Task UploadDirectoryAsync(SshCredentials credentials, string localDirectory, string remoteDirectory)
        {
            return Task.Run(() =>
            {
                var connectionInfo = new ConnectionInfo(credentials.Host, credentials.Username,
                    new PasswordAuthenticationMethod(credentials.Username, credentials.Password));

                using (var sftp = new SftpClient(connectionInfo))
                {
                    sftp.Connect();
                    var dirInfo = new DirectoryInfo(localDirectory);
                    if (!dirInfo.Exists)
                    {
                        throw new DirectoryNotFoundException(string.Format(Properties.Resources.Error_LocalDirectoryNotFound, localDirectory));
                    }
                    if (!sftp.Exists(remoteDirectory))
                    {
                        sftp.CreateDirectory(remoteDirectory);
                    }

                    UploadDirectoryRecursive(sftp, dirInfo, remoteDirectory);
                    sftp.Disconnect();
                }
            });
        }
        private void UploadDirectoryRecursive(SftpClient sftp, DirectoryInfo localDirectory, string remoteDirectory)
        {
            foreach (var file in localDirectory.GetFiles())
            {
                if (file.Extension.Equals(".log", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                try
                {
                    using (var fileStream = new FileStream(file.FullName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                    {
                        var remoteFilePath = $"{remoteDirectory}/{file.Name}";
                        sftp.UploadFile(fileStream, remoteFilePath);
                    }
                }
                catch (IOException)
                {

                    continue;
                }
            }
            foreach (var subDir in localDirectory.GetDirectories())
            {
                var remoteSubDir = $"{remoteDirectory}/{subDir.Name}";
                if (!sftp.Exists(remoteSubDir))
                {
                    sftp.CreateDirectory(remoteSubDir);
                }
                UploadDirectoryRecursive(sftp, subDir, remoteSubDir);
            }
        }
        public Task WriteTextFileAsync(SshCredentials credentials, string content, string remotePath)
        {
            return Task.Run(() =>
            {
                var connectionInfo = new ConnectionInfo(credentials.Host, credentials.Username,
                    new PasswordAuthenticationMethod(credentials.Username, credentials.Password));

                using (var sftp = new SftpClient(connectionInfo))
                {
                    sftp.Connect();
                    sftp.WriteAllText(remotePath, content, Utf8NoBom);
                    sftp.Disconnect();
                }
            });
        }
    }
}

================================================================================
FILE: Services\StorageService.cs
================================================================================

﻿using System.IO;
using System.Management;
using System.Text.RegularExpressions;
using DiscUtils.Iso9660;
using ExHyperV.Models;
using ExHyperV.Tools;
using Microsoft.Management.Infrastructure;

namespace ExHyperV.Services
{
    public interface IStorageService
    {
        Task<List<VmStorageControllerInfo>> GetVmStorageInfoAsync(string vmName);
        Task<List<HostDiskInfo>> GetHostDisksAsync();
        Task<(bool Success, string Message)> SetDiskOfflineStatusAsync(int diskNumber, bool isOffline);
        Task<(bool Success, string Message, string ActualType, int ActualNumber, int ActualLocation)> AddDriveAsync(string vmName, string controllerType, int controllerNumber, int location, string driveType, string pathOrNumber, bool isPhysical, bool isNew = false, int sizeGb = 256, string vhdType = "Dynamic", string parentPath = "", string sectorFormat = "Default", string blockSize = "Default", string isoSourcePath = null, string isoVolumeLabel = null); Task<(bool Success, string Message)> RemoveDriveAsync(string vmName, UiDriveModel drive);
        Task<(bool Success, string Message)> ModifyDvdDrivePathAsync(string vmName, string controllerType, int controllerNumber, int controllerLocation, string newIsoPath);
        Task<double> GetVhdSizeGbAsync(string path);
        Task<(string ControllerType, int ControllerNumber, int Location)> GetNextAvailableSlotAsync(string vmName, string driveType);
    }

    public class StorageService : IStorageService
    {
        //快速查询虚拟机磁盘信息
        public async Task<List<VmStorageControllerInfo>> GetVmStorageInfoAsync(string vmName)
        {
            return await Task.Run(() =>
            {
                var resultList = new List<VmStorageControllerInfo>();
                string namespaceName = @"root\virtualization\v2";
                string hostNamespace = @"root\cimv2";

                Dictionary<string, int>? hvDiskMap = null;
                Dictionary<int, HostDiskInfoCache>? osDiskMap = null;

                try
                {
                    using (var session = CimSession.Create(null))
                    {
                        var vmQuery = $"SELECT * FROM Msvm_ComputerSystem WHERE ElementName = '{vmName}'";
                        var vm = session.QueryInstances(namespaceName, "WQL", vmQuery).FirstOrDefault();
                        if (vm == null) return resultList;

                        var settings = session.EnumerateAssociatedInstances(
                            namespaceName, vm, "Msvm_SettingsDefineState", "Msvm_VirtualSystemSettingData",
                            "ManagedElement", "SettingData").FirstOrDefault();

                        if (settings == null) return resultList;

                        var rasd = session.EnumerateAssociatedInstances(namespaceName, settings, "Msvm_VirtualSystemSettingDataComponent", "Msvm_ResourceAllocationSettingData", "GroupComponent", "PartComponent").ToList();
                        var sasd = session.EnumerateAssociatedInstances(namespaceName, settings, "Msvm_VirtualSystemSettingDataComponent", "Msvm_StorageAllocationSettingData", "GroupComponent", "PartComponent").ToList();

                        var allResources = new List<CimInstance>(rasd.Count + sasd.Count);
                        allResources.AddRange(rasd);
                        allResources.AddRange(sasd);

                        var controllers = new List<CimInstance>();
                        foreach (var res in allResources)
                        {
                            int rt = Convert.ToInt32(res.CimInstanceProperties["ResourceType"]?.Value ?? 0);
                            if (rt == 5 || rt == 6)
                            {
                                controllers.Add(res);
                            }
                        }

                        var childrenMap = new Dictionary<string, List<CimInstance>>();
                        var parentRegex = new Regex("InstanceID=\"([^\"]+)\"", RegexOptions.Compiled);

                        foreach (var res in allResources)
                        {
                            var parentPath = res.CimInstanceProperties["Parent"]?.Value?.ToString();
                            if (!string.IsNullOrEmpty(parentPath))
                            {
                                var match = parentRegex.Match(parentPath);
                                if (match.Success)
                                {
                                    string parentId = match.Groups[1].Value.Replace("\\\\", "\\");
                                    if (!childrenMap.ContainsKey(parentId)) childrenMap[parentId] = new List<CimInstance>();
                                    childrenMap[parentId].Add(res);
                                }
                            }
                        }

                        controllers = controllers.OrderBy(c => c.CimInstanceProperties["ResourceType"]?.Value).ToList();

                        int scsiCounter = 0;
                        int ideCounter = 0;

                        var deviceIdRegex = new Regex("DeviceID=\"([^\"]+)\"", RegexOptions.Compiled);

                        foreach (var ctrl in controllers)
                        {
                            string ctrlId = ctrl.CimInstanceProperties["InstanceID"]?.Value?.ToString() ?? "";
                            int ctrlTypeVal = Convert.ToInt32(ctrl.CimInstanceProperties["ResourceType"]?.Value);
                            string ctrlType = ctrlTypeVal == 6 ? "SCSI" : "IDE";

                            int ctrlNum = (ctrlType == "SCSI") ? scsiCounter++ : ideCounter++;

                            var vmCtrlInfo = new VmStorageControllerInfo
                            {
                                VMName = vmName,
                                ControllerType = ctrlType,
                                ControllerNumber = ctrlNum,
                                AttachedDrives = new List<AttachedDriveInfo>()
                            };

                            if (childrenMap.ContainsKey(ctrlId))
                            {
                                foreach (var slot in childrenMap[ctrlId])
                                {
                                    int resType = Convert.ToInt32(slot.CimInstanceProperties["ResourceType"]?.Value);
                                    if (resType != 16 && resType != 17) continue;

                                    string address = slot.CimInstanceProperties["AddressOnParent"]?.Value?.ToString() ?? "0";
                                    int location = int.TryParse(address, out int loc) ? loc : 0;

                                    CimInstance? media = null;
                                    string slotId = slot.CimInstanceProperties["InstanceID"]?.Value?.ToString() ?? "";

                                    if (childrenMap.ContainsKey(slotId))
                                    {
                                        media = childrenMap[slotId].FirstOrDefault(m => {
                                            int t = Convert.ToInt32(m.CimInstanceProperties["ResourceType"]?.Value);
                                            return t == 31 || t == 16 || t == 22;
                                        });
                                    }

                                    var slotHostRes = slot.CimInstanceProperties["HostResource"]?.Value as string[];
                                    if (media == null && slotHostRes != null && slotHostRes.Length > 0)
                                    {
                                        media = slot;
                                    }

                                    var driveInfo = new AttachedDriveInfo
                                    {
                                        ControllerLocation = location,
                                        DriveType = (resType == 16) ? "DvdDrive" : "HardDisk",
                                        DiskType = "Empty"
                                    };

                                    if (media != null)
                                    {
                                        var hostRes = media.CimInstanceProperties["HostResource"]?.Value as string[];
                                        string rawPath = (hostRes != null && hostRes.Length > 0) ? hostRes[0] : "";

                                        if (!string.IsNullOrWhiteSpace(rawPath))
                                        {
                                            bool isPhysicalHardDisk = rawPath.IndexOf("Msvm_DiskDrive", StringComparison.OrdinalIgnoreCase) >= 0 ||
                                                                      rawPath.IndexOf("PHYSICALDRIVE", StringComparison.OrdinalIgnoreCase) >= 0;
                                            bool isPhysicalCdRom = rawPath.IndexOf("CDROM", StringComparison.OrdinalIgnoreCase) >= 0 ||
                                                                   rawPath.IndexOf("Msvm_OpticalDrive", StringComparison.OrdinalIgnoreCase) >= 0;

                                            if (isPhysicalHardDisk)
                                            {
                                                driveInfo.DiskType = "Physical";
                                                driveInfo.PathOrDiskNumber = "Physical Drive";

                                                try
                                                {
                                                    if (hvDiskMap == null)
                                                    {
                                                        var allHvDisks = session.QueryInstances(namespaceName, "WQL", "SELECT DeviceID, DriveNumber FROM Msvm_DiskDrive");
                                                        hvDiskMap = new Dictionary<string, int>();
                                                        foreach (var d in allHvDisks)
                                                        {
                                                            string did = d.CimInstanceProperties["DeviceID"]?.Value?.ToString() ?? "";
                                                            did = did.Replace("\\\\", "\\");
                                                            int dnum = Convert.ToInt32(d.CimInstanceProperties["DriveNumber"]?.Value);
                                                            if (!string.IsNullOrEmpty(did)) hvDiskMap[did] = dnum;
                                                        }

                                                        var allOsDisks = session.QueryInstances(hostNamespace, "WQL", "SELECT Index, Model, Size, SerialNumber FROM Win32_DiskDrive");
                                                        osDiskMap = new Dictionary<int, HostDiskInfoCache>();
                                                        foreach (var d in allOsDisks)
                                                        {
                                                            int idx = Convert.ToInt32(d.CimInstanceProperties["Index"]?.Value);
                                                            long size = Convert.ToInt64(d.CimInstanceProperties["Size"]?.Value);
                                                            osDiskMap[idx] = new HostDiskInfoCache
                                                            {
                                                                Model = d.CimInstanceProperties["Model"]?.Value?.ToString(),
                                                                SerialNumber = d.CimInstanceProperties["SerialNumber"]?.Value?.ToString()?.Trim(),
                                                                SizeGB = Math.Round(size / (1024.0 * 1024.0 * 1024.0), 2)
                                                            };
                                                        }
                                                    }

                                                    var devMatch = deviceIdRegex.Match(rawPath);
                                                    if (devMatch.Success)
                                                    {
                                                        string devId = devMatch.Groups[1].Value.Replace("\\\\", "\\");
                                                        if (hvDiskMap != null && hvDiskMap.TryGetValue(devId, out int dNum))
                                                        {
                                                            driveInfo.DiskNumber = dNum;
                                                            driveInfo.PathOrDiskNumber = $"PhysicalDisk{dNum}";

                                                            if (osDiskMap != null && osDiskMap.TryGetValue(dNum, out var hostInfo))
                                                            {
                                                                driveInfo.DiskModel = hostInfo.Model;
                                                                driveInfo.SerialNumber = hostInfo.SerialNumber;
                                                                driveInfo.DiskSizeGB = hostInfo.SizeGB;
                                                            }
                                                        }
                                                    }
                                                    else if (rawPath.ToUpper().Contains("PHYSICALDRIVE"))
                                                    {
                                                        driveInfo.PathOrDiskNumber = rawPath;
                                                    }
                                                }
                                                catch { }
                                            }
                                            else if (isPhysicalCdRom)
                                            {
                                                driveInfo.DiskType = "Physical";
                                                driveInfo.PathOrDiskNumber = rawPath;
                                                driveInfo.DiskModel = "Passthrough Optical Drive";
                                            }
                                            else
                                            {
                                                driveInfo.DiskType = "Virtual";
                                                string cleanPath = rawPath.Trim('"');
                                                driveInfo.PathOrDiskNumber = cleanPath;
                                                try
                                                {
                                                    if (File.Exists(cleanPath))
                                                    {
                                                        var fi = new FileInfo(cleanPath);
                                                        driveInfo.DiskSizeGB = Math.Round(fi.Length / (1024.0 * 1024.0 * 1024.0), 2);
                                                    }
                                                }
                                                catch { }
                                            }
                                        }
                                    }
                                    vmCtrlInfo.AttachedDrives.Add(driveInfo);
                                }
                            }
                            vmCtrlInfo.AttachedDrives = vmCtrlInfo.AttachedDrives.OrderBy(d => d.ControllerLocation).ToList();
                            resultList.Add(vmCtrlInfo);
                        }
                    }
                }
                catch { }

                return resultList;
            });
        }

        private class HostDiskInfoCache
        {
            public string? Model { get; set; }
            public string? SerialNumber { get; set; }
            public double SizeGB { get; set; }
        }

        //快速查询主机磁盘信息
        public async Task<List<HostDiskInfo>> GetHostDisksAsync()
        {
            return await Task.Run(() =>
            {
                var result = new List<HostDiskInfo>();
                var usedDiskNumbers = new HashSet<int>();

                try
                {
                    using (var session = CimSession.Create(null))
                    {
                        var vmUsedDisks = session.QueryInstances(@"root\virtualization\v2", "WQL",
                            "SELECT DriveNumber FROM Msvm_DiskDrive WHERE DriveNumber IS NOT NULL");

                        foreach (var disk in vmUsedDisks)
                        {
                            if (int.TryParse(disk.CimInstanceProperties["DriveNumber"]?.Value?.ToString(), out int num))
                            {
                                usedDiskNumbers.Add(num);
                            }
                        }
                        var allHostDisks = session.QueryInstances(@"Root\Microsoft\Windows\Storage", "WQL",
                            "SELECT Number, FriendlyName, Size, IsOffline, IsSystem, IsBoot, BusType, OperationalStatus FROM MSFT_Disk");

                        foreach (var disk in allHostDisks)
                        {
                            var number = Convert.ToInt32(disk.CimInstanceProperties["Number"]?.Value ?? -1);
                            if (number == -1) continue;

                            var busType = Convert.ToUInt16(disk.CimInstanceProperties["BusType"]?.Value ?? 0);
                            var isSystem = Convert.ToBoolean(disk.CimInstanceProperties["IsSystem"]?.Value ?? false);
                            var isBoot = Convert.ToBoolean(disk.CimInstanceProperties["IsBoot"]?.Value ?? false);
                            if (busType == 7 || isSystem || isBoot || usedDiskNumbers.Contains(number))
                            {
                                continue;
                            }
                            long sizeBytes = Convert.ToInt64(disk.CimInstanceProperties["Size"]?.Value ?? 0);
                            var opStatusArray = disk.CimInstanceProperties["OperationalStatus"]?.Value as ushort[];
                            string opStatus = (opStatusArray != null && opStatusArray.Length > 0) ? opStatusArray[0].ToString() : "Unknown";
                            result.Add(new HostDiskInfo
                            {
                                Number = number,
                                FriendlyName = disk.CimInstanceProperties["FriendlyName"]?.Value?.ToString() ?? string.Empty,
                                SizeGB = Math.Round(sizeBytes / (1024.0 * 1024.0 * 1024.0), 2),
                                IsOffline = Convert.ToBoolean(disk.CimInstanceProperties["IsOffline"]?.Value ?? false),
                                IsSystem = isSystem,
                                OperationalStatus = opStatus
                            });
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[ERROR] GetHostDisksAsync failed: {ex.Message}");
                }

                return result;
            });
        }

        public async Task<(bool Success, string Message)> SetDiskOfflineStatusAsync(int diskNumber, bool isOffline) => await RunCommandAsync($"Set-Disk -Number {diskNumber} -IsOffline ${isOffline.ToString().ToLower()}");

        public async Task<(bool Success, string Message, string ActualType, int ActualNumber, int ActualLocation)> AddDriveAsync(string vmName, string controllerType, int controllerNumber, int location, string driveType, string pathOrNumber, bool isPhysical, bool isNew = false, int sizeGb = 256, string vhdType = "Dynamic", string parentPath = "", string sectorFormat = "Default", string blockSize = "Default", string isoSourcePath = null, string isoVolumeLabel = null)
        {
            string psPath = string.IsNullOrWhiteSpace(pathOrNumber) ? "$null" : $"'{pathOrNumber}'";
    if (driveType == "DvdDrive" && isNew && !string.IsNullOrWhiteSpace(isoSourcePath))
    {
                var createResult = await CreateIsoFromDirectoryAsync(isoSourcePath, pathOrNumber, isoVolumeLabel);

                if (!createResult.Success)
                {
                    return (false, createResult.Message, controllerType, controllerNumber, location);
                }
            }


            string script = $@"
    $ErrorActionPreference = 'Stop'
    
    $vmName = '{vmName}'
    $v = Get-VM -Name $vmName
    
    $oldDisk = Get-VMHardDiskDrive -VMName $vmName -ControllerType '{controllerType}' -ControllerNumber {controllerNumber} -ControllerLocation {location} -ErrorAction SilentlyContinue
    $oldDvd = Get-VMDvdDrive -VMName $vmName -ControllerNumber {controllerNumber} -ControllerLocation {location} | Where-Object {{ $_.ControllerType -eq '{controllerType}' }}

    if ('{controllerType}' -eq 'IDE' -and $v.State -eq 'Running') {{
        if ('{driveType}' -ne 'DvdDrive' -or (-not $oldDvd)) {{
            throw 'Storage_Error_IdeHotPlugNotSupported'
        }}
    }}

    if ('{controllerType}' -eq 'SCSI') {{
        $scsiCtrls = Get-VMScsiController -VMName $vmName | Sort-Object ControllerNumber
        $max = if ($scsiCtrls) {{ ($scsiCtrls | Select-Object -Last 1).ControllerNumber }} else {{ -1 }}
        
        if ({controllerNumber} -gt $max) {{
            if ($v.State -eq 'Running') {{
                throw 'Storage_Error_ScsiControllerHotAddNotSupported'
            }}
            for ($i = $max + 1; $i -le {controllerNumber}; $i++) {{ 
                Add-VMScsiController -VMName $vmName -ErrorAction Stop 
            }}
        }}
    }}
    
    if ('{driveType}' -eq 'HardDisk') {{
        if ($oldDisk) {{ Remove-VMHardDiskDrive -VMName $vmName -ControllerType '{controllerType}' -ControllerNumber {controllerNumber} -ControllerLocation {location} -ErrorAction Stop }}
        if ($oldDvd) {{ Remove-VMDvdDrive -VMName $vmName -ControllerNumber {controllerNumber} -ControllerLocation {location} -ErrorAction Stop }}
        if ('{isNew.ToString().ToLower()}' -eq 'true') {{
            $vhdParams = @{{ Path = {psPath}; SizeBytes = {sizeGb}GB; {vhdType} = $true; ErrorAction = 'Stop' }}
            if ('{sectorFormat}' -eq '512n') {{ $vhdParams.LogicalSectorSizeBytes = 512; $vhdParams.PhysicalSectorSizeBytes = 512 }}
            elseif ('{sectorFormat}' -eq '512e') {{ $vhdParams.LogicalSectorSizeBytes = 512; $vhdParams.PhysicalSectorSizeBytes = 4096 }}
            elseif ('{sectorFormat}' -eq '4kn') {{ $vhdParams.LogicalSectorSizeBytes = 4096; $vhdParams.PhysicalSectorSizeBytes = 4096 }}
            if ('{blockSize}' -ne 'Default') {{ $vhdParams.BlockSizeBytes = '{blockSize}' }}
            if ('{vhdType}' -eq 'Differencing') {{ $vhdParams.Remove('SizeBytes'); $vhdParams.Remove('Dynamic'); $vhdParams.Remove('Fixed'); $vhdParams.ParentPath = '{parentPath}' }}
            New-VHD @vhdParams
        }}
        $p = @{{ VMName=$vmName; ControllerType='{controllerType}'; ControllerNumber={controllerNumber}; ControllerLocation={location}; ErrorAction='Stop' }}
        if ('{isPhysical.ToString().ToLower()}' -eq 'true') {{ $p.DiskNumber={psPath} }} else {{ $p.Path={psPath} }}
        Add-VMHardDiskDrive @p
    }} else {{
        if ($oldDisk) {{ Remove-VMHardDiskDrive -VMName $vmName -ControllerType '{controllerType}' -ControllerNumber {controllerNumber} -ControllerLocation {location} -ErrorAction Stop }}
        if ($oldDvd) {{ Set-VMDvdDrive -VMName $vmName -ControllerNumber {controllerNumber} -ControllerLocation {location} -Path {psPath} -ErrorAction Stop }}
        else {{ Add-VMDvdDrive -VMName $vmName -ControllerNumber {controllerNumber} -ControllerLocation {location} -Path {psPath} -ErrorAction Stop }}
    }}
    Write-Output ""RESULT:{controllerType},{controllerNumber},{location}""";
            try
            {
                var results = await Utils.Run2(script);
                string lastLine = results.LastOrDefault()?.ToString() ?? "";
                if (lastLine.StartsWith("RESULT:"))
                {
                    var parts = lastLine.Substring(7).Split(',');
                    return (true, "Storage_Msg_Success", parts[0], int.Parse(parts[1]), int.Parse(parts[2]));
                }
                return (true, "Storage_Msg_Success", controllerType, controllerNumber, location);
            }
            catch (Exception ex) { return (false, Utils.GetFriendlyErrorMessage(ex.Message), controllerType, controllerNumber, location); }
        }
        public async Task<(bool Success, string Message)> RemoveDriveAsync(string vmName, UiDriveModel drive)
        {
            string script = $@"
    $ErrorActionPreference = 'Stop'
    $vmName = '{vmName}'; $cnum = {drive.ControllerNumber}; $loc = {drive.ControllerLocation}; $ctype = '{drive.ControllerType}'
    $v = Get-VM -Name $vmName
    
    if ('{drive.DriveType}' -eq 'DvdDrive') {{
        $check = Get-VMDvdDrive -VMName $vmName | Where-Object {{ $_.ControllerType -eq $ctype -and $_.ControllerNumber -eq $cnum -and $_.ControllerLocation -eq $loc }}
        if (-not $check) {{ throw 'Storage_Error_DvdDriveNotFound' }}

        if ($v.State -eq 'Off' -or $ctype -eq 'SCSI') {{ 
            Get-VMDvdDrive -VMName $vmName | Where-Object {{ $_.ControllerType -eq $ctype -and $_.ControllerNumber -eq $cnum -and $_.ControllerLocation -eq $loc }} | Remove-VMDvdDrive -ErrorAction Stop
            return 'Storage_Msg_Removed' 
        }}
        else {{ 
            if ($check.Path) {{ 
                $check | Set-VMDvdDrive -Path $null -ErrorAction Stop; 
                return 'Storage_Msg_Ejected' 
            }} else {{ 
                throw 'Storage_Error_DvdHotRemoveNotSupported' 
            }} 
        }}
    }} else {{
        $disk = Get-VMHardDiskDrive -VMName $vmName | Where-Object {{ $_.ControllerType -eq $ctype -and $_.ControllerNumber -eq $cnum -and $_.ControllerLocation -eq $loc }}
        if (-not $disk) {{ throw 'Storage_Error_DiskNotFound' }}
        $disk | Remove-VMHardDiskDrive -ErrorAction Stop
        if ('{drive.DiskType}' -eq 'Physical' -and {drive.DiskNumber} -ne -1) {{ Start-Sleep -Milliseconds 500; Set-Disk -Number {drive.DiskNumber} -IsOffline $false -ErrorAction SilentlyContinue }}
        return 'Storage_Msg_Removed'
    }}";
            try
            {
                var results = await Utils.Run2(script);
                return (true, results.LastOrDefault()?.ToString() ?? "Storage_Msg_Removed");
            }
            catch (Exception ex) { return (false, Utils.GetFriendlyErrorMessage(ex.Message)); }
        }

        public async Task<(bool Success, string Message)> ModifyDvdDrivePathAsync(string vmName, string controllerType, int controllerNumber, int controllerLocation, string newIsoPath) => await RunCommandAsync($"Set-VMDvdDrive -VMName '{vmName}' -ControllerNumber {controllerNumber} -ControllerLocation {controllerLocation} -Path {(string.IsNullOrWhiteSpace(newIsoPath) ? "$null" : $"'{newIsoPath}'")} -ErrorAction Stop");
        public async Task<double> GetVhdSizeGbAsync(string path)
        {
            return await Task.Run(() =>
            {
                try
                {
                    var scope = new ManagementScope(@"root\virtualization\v2");
                    scope.Connect();

                    var wmiQuery = new ObjectQuery("SELECT * FROM Msvm_ImageManagementService");
                    using (var searcher = new ManagementObjectSearcher(scope, wmiQuery))
                    {
                        using (var managementService = searcher.Get().OfType<ManagementObject>().FirstOrDefault())
                        {
                            if (managementService == null)
                            {
                                return 0;
                            }

                            using (var inParams = managementService.GetMethodParameters("GetVirtualHardDiskSettingData"))
                            {
                                inParams["Path"] = path;

                                using (var outParams = managementService.InvokeMethod("GetVirtualHardDiskSettingData", inParams, null))
                                {
                                    string settingData = outParams["SettingData"].ToString();

                                    var vhdSettingData = new ManagementClass("Msvm_VirtualHardDiskSettingData");
                                    vhdSettingData.SetPropertyValue("text", settingData);

                                    var sizeInBytes = (ulong)vhdSettingData.GetPropertyValue("MaxInternalSize");

                                    const double bytesPerGb = 1024.0 * 1024 * 1024;
                                    return Math.Round(sizeInBytes / bytesPerGb, 2);
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    return 0;
                }
            });
        }

        public async Task<(string ControllerType, int ControllerNumber, int Location)> GetNextAvailableSlotAsync(string vmName, string driveType)
        {
            string script = $@"
    $v = Get-VM -Name '{vmName}'; $ctype = 'IDE'; $cnum = 0; $loc = 0; $found = $false
    if ($v.Generation -eq 2 -or ($v.Generation -eq 1 -and $v.State -eq 'Running')) {{
        $ctype = 'SCSI'; $controllers = Get-VMScsiController -VMName '{vmName}' | Sort-Object ControllerNumber
        foreach ($ctrl in $controllers) {{
            $cn = $ctrl.ControllerNumber; $used = (Get-VMHardDiskDrive -VMName '{vmName}' -ControllerType SCSI -ControllerNumber $cn).ControllerLocation + (Get-VMDvdDrive -VMName '{vmName}' -ControllerNumber $cn).ControllerLocation
            for ($i=0; $i -lt 64; $i++) {{ if ($used -notcontains $i) {{ $cnum = $cn; $loc = $i; $found = $true; break }} }}
            if ($found) {{ break }}
        }}
        if (-not $found) {{ $cnum = if ($controllers) {{ ($controllers | Sort-Object ControllerNumber | Select-Object -Last 1).ControllerNumber + 1 }} else {{ 0 }}; $loc = 0; }}
    }} else {{
        $ctype = 'IDE'; for ($c=0; $c -lt 2; $c++) {{ $used = (Get-VMHardDiskDrive -VMName '{vmName}' -ControllerType IDE -ControllerNumber $c).ControllerLocation + (Get-VMDvdDrive -VMName '{vmName}' -ControllerNumber $c).ControllerLocation; for ($i=0; $i -lt 2; $i++) {{ if ($used -notcontains $i) {{ $cnum=$c; $loc=$i; $found=$true; break }} }} if ($found) {{ break }} }}
    }} ""$ctype,$cnum,$loc""";
            var res = await ExecutePowerShellAsync(script); var parts = res.Trim().Split(',');
            return parts.Length == 3 ? (parts[0], int.Parse(parts[1]), int.Parse(parts[2])) : ("SCSI", 0, 0);
        }

        private async Task<string> ExecutePowerShellAsync(string script) { try { var results = await Utils.Run2(script); return results == null ? "" : string.Join(Environment.NewLine, results.Select(r => r?.ToString() ?? "")); } catch { return ""; } }
        private async Task<(bool Success, string Message)> RunCommandAsync(string script) { try { await Utils.Run2(script); return (true, "Storage_Msg_Success"); } catch (Exception ex) { return (false, Utils.GetFriendlyErrorMessage(ex.Message)); } }
        private async Task<(bool Success, string Message)> CreateIsoFromDirectoryAsync(string sourceDirectory, string targetIsoPath, string volumeLabel)
        {
            var sourceDirInfo = new DirectoryInfo(sourceDirectory);
            if (!sourceDirInfo.Exists)
            {
                return (false, "Iso_Error_SourceDirNotFound");
            }

            const long MaxFileSize = 4294967295;
            const int MaxFileNameLength = 64;
            const int MaxPathLength = 240;
            const int MaxDirectoryDepth = 8;
            const int MaxVolumeLabelLength = 16;

            string finalVolumeLabel = string.IsNullOrWhiteSpace(volumeLabel) ? sourceDirInfo.Name : volumeLabel;
            if (finalVolumeLabel.Length > MaxVolumeLabelLength)
            {
                return (false, "Iso_Error_VolumeLabelTooLong");
            }

            return await Task.Run(() =>
            {
                try
                {
                    foreach (var item in sourceDirInfo.EnumerateFileSystemInfos("*", SearchOption.AllDirectories))
                    {
                        string relativePath = Path.GetRelativePath(sourceDirInfo.FullName, item.FullName);

                        if (item.Name.Length > MaxFileNameLength)
                        {
                            return (false, "Iso_Error_FileNameTooLong");
                        }

                        if (relativePath.Length > MaxPathLength)
                        {
                            return (false, "Iso_Error_PathTooLong");
                        }

                        int depth = relativePath.Split(Path.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries).Length;

                        if (item is FileInfo)
                        {
                            if (depth - 1 >= MaxDirectoryDepth)
                            {
                                return (false, "Iso_Error_FileDepthTooDeep");
                            }
                        }
                        else if (depth > MaxDirectoryDepth)
                        {
                            return (false, "Iso_Error_DirectoryDepthTooDeep");
                        }

                        if (item is FileInfo file && file.Length >= MaxFileSize)
                        {
                            return (false, "Iso_Error_FileTooLarge");
                        }
                    }

                    var targetDir = Path.GetDirectoryName(targetIsoPath);
                    if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir))
                    {
                        Directory.CreateDirectory(targetDir);
                    }

                    var builder = new CDBuilder
                    {
                        UseJoliet = true,
                        VolumeIdentifier = finalVolumeLabel
                    };

                    foreach (var file in Directory.GetFiles(sourceDirectory, "*", SearchOption.AllDirectories))
                    {
                        string relativePath = Path.GetRelativePath(sourceDirectory, file);
                        builder.AddFile(relativePath, file);
                    }

                    builder.Build(targetIsoPath);

                    return (true, "Iso_Msg_CreateSuccess");
                }
                catch (Exception)
                {
                    return (false, "Iso_Error_BuildFailed");
                }
            });
        }
    }
}

================================================================================
FILE: Services\VmProcessorService.cs
================================================================================

﻿using ExHyperV.Tools;
using ExHyperV.ViewModels;
using System.Text;
using System.Text.RegularExpressions;

namespace ExHyperV.Services
{
    public class VmProcessorService : IVmProcessorService
    {
        public async Task<VMProcessorViewModel?> GetVmProcessorAsync(string vmName)
        {
            try
            {
                var safeVmName = vmName.Replace("'", "''");
                var script = $"Get-VM -Name '{safeVmName}' -ErrorAction Stop | Get-VMProcessor | Select-Object " +
                             "Count, Reservation, Maximum, RelativeWeight, " +
                             "ExposeVirtualizationExtensions, EnableHostResourceProtection, " +
                             "CompatibilityForMigrationEnabled, CompatibilityForOlderOperatingSystemsEnabled, " +
                             "HwThreadCountPerCore";

                var results = await Utils.Run2(script);
                var psObj = results.FirstOrDefault();

                if (psObj == null) return null;

                dynamic data = psObj;

                return new VMProcessorViewModel
                {
                    Count = GetLong(data.Count),
                    Reserve = GetLong(data.Reservation),
                    Maximum = GetLong(data.Maximum),
                    RelativeWeight = (int)GetLong(data.RelativeWeight),
                    ExposeVirtualizationExtensions = GetBool(data.ExposeVirtualizationExtensions),
                    EnableHostResourceProtection = GetBool(data.EnableHostResourceProtection),
                    CompatibilityForMigrationEnabled = GetBool(data.CompatibilityForMigrationEnabled),
                    CompatibilityForOlderOperatingSystemsEnabled = GetBool(data.CompatibilityForOlderOperatingSystemsEnabled),
                    SmtMode = ConvertHwThreadsToSmtMode((uint)GetLong(data.HwThreadCountPerCore))
                };
            }
            catch
            {
                return null;
            }
        }

        public async Task<(bool Success, string Message)> SetVmProcessorAsync(string vmName, VMProcessorViewModel processorSettings)
        {
            try
            {
                var safeVmName = vmName.Replace("'", "''");
                var hwThreadCount = ConvertSmtModeToHwThreads(processorSettings.SmtMode);

                var sb = new StringBuilder();
                sb.Append($"$vm = Get-VM -Name '{safeVmName}' -ErrorAction Stop; ");
                sb.Append("Set-VMProcessor -VM $vm ");
                sb.Append($"-Count {processorSettings.Count} ");
                sb.Append($"-Reserve {processorSettings.Reserve} ");
                sb.Append($"-Maximum {processorSettings.Maximum} ");
                sb.Append($"-RelativeWeight {processorSettings.RelativeWeight} ");
                sb.Append($"-ExposeVirtualizationExtensions {ToPsBool(processorSettings.ExposeVirtualizationExtensions)} ");
                sb.Append($"-EnableHostResourceProtection {ToPsBool(processorSettings.EnableHostResourceProtection)} ");
                sb.Append($"-CompatibilityForMigrationEnabled {ToPsBool(processorSettings.CompatibilityForMigrationEnabled)} ");
                sb.Append($"-CompatibilityForOlderOperatingSystemsEnabled {ToPsBool(processorSettings.CompatibilityForOlderOperatingSystemsEnabled)} ");
                sb.Append($"-HwThreadCountPerCore {hwThreadCount} ");
                sb.Append("-ErrorAction Stop");

                await Utils.Run2(sb.ToString());

                return (true, ExHyperV.Properties.Resources.SettingsSavedSuccessfully);
            }
            catch (Exception ex)
            {
                var friendlyMsg = GetFriendlyErrorMessage(ex.Message);
                return (false, friendlyMsg);
            }
        }
        private string GetFriendlyErrorMessage(string rawMessage)
        {
            if (string.IsNullOrWhiteSpace(rawMessage)) return ExHyperV.Properties.Resources.UnknownError;
            string cleanMsg = rawMessage.Trim();
            cleanMsg = Regex.Replace(cleanMsg, @"[\(\（].*?ID\s+[a-fA-F0-9-]{36}.*?[\)\）]", "");
            cleanMsg = cleanMsg.Replace("\r", "").Replace("\n", " ");
            var parts = cleanMsg.Split(new[] { '。', '.' }, StringSplitOptions.RemoveEmptyEntries)
                                .Select(s => s.Trim())
                                .Where(s => !string.IsNullOrWhiteSpace(s))
                                .ToList();
            if (parts.Count >= 2)
            {
                var lastPart = parts.Last();
                if (lastPart.Length > 2)
                {
                    return lastPart + "。";
                }
            }

            return cleanMsg;
        }

        private SmtMode ConvertHwThreadsToSmtMode(uint hwThreads) => hwThreads switch
        {
            0 => SmtMode.Inherit,
            1 => SmtMode.SingleThread,
            2 => SmtMode.MultiThread,
            _ => SmtMode.Inherit
        };

        private uint ConvertSmtModeToHwThreads(SmtMode smtMode) => smtMode switch
        {
            SmtMode.Inherit => 0,
            SmtMode.SingleThread => 1,
            SmtMode.MultiThread => 2,
            _ => 0
        };

        private string ToPsBool(bool value) => value ? "$true" : "$false";

        private long GetLong(object value)
        {
            if (value == null) return 0;
            try { return Convert.ToInt64(value); } catch { return 0; }
        }

        private bool GetBool(object value)
        {
            if (value == null) return false;
            try { return Convert.ToBoolean(value); } catch { return false; }
        }
    }
}

================================================================================
FILE: Tools\DialogManager.cs
================================================================================

﻿using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using Wpf.Ui.Controls;
using TextBlock = Wpf.Ui.Controls.TextBlock;

namespace ExHyperV.Tools
{
    public static class DialogManager
    {
        /// <summary>
        /// 显示确认对话框，返回用户是否确认
        /// </summary>
        public static async Task<bool> ShowConfirmAsync(string title, string message, string confirmButtonText = null, string cancelButtonText = null, bool isDanger = false)
        {
            if (Application.Current.MainWindow is not MainWindow mainWindow)
            {
                return false;
            }

            var dialogHost = mainWindow.ContentPresenterForDialogs;
            if (dialogHost == null)
            {
                return false;
            }

            var grid = new Grid();
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(40) });
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });

            var icon = new FontIcon
            {
                FontFamily = Application.Current.FindResource("SegoeFluentIcons") as FontFamily,
                Glyph = isDanger ? "\uE7BA" : "\uE946", // Warning icon for danger, Info icon otherwise
                FontSize = 28,
                VerticalAlignment = VerticalAlignment.Center,
                Foreground = isDanger ? new SolidColorBrush(System.Windows.Media.Color.FromRgb(196, 43, 28)) : null
            };

            var contentTextBlock = new TextBlock
            {
                Text = message,
                TextWrapping = TextWrapping.Wrap,
                FontSize = 14,
                LineHeight = 24,
                VerticalAlignment = VerticalAlignment.Center,
                Margin = new Thickness(12, 0, 0, 0)
            };

            Grid.SetColumn(icon, 0);
            Grid.SetColumn(contentTextBlock, 1);
            grid.Children.Add(icon);
            grid.Children.Add(contentTextBlock);

            var dialog = new ContentDialog
            {
                Title = title,
                Content = grid,
                PrimaryButtonText = confirmButtonText ?? Properties.Resources.sure,
                CloseButtonText = cancelButtonText ?? Properties.Resources.cancel,
                DialogHost = dialogHost,
                PrimaryButtonAppearance = isDanger ? ControlAppearance.Danger : ControlAppearance.Primary
            };

            var result = await dialog.ShowAsync(CancellationToken.None);
            return result == ContentDialogResult.Primary;
        }

        public static async Task ShowAlertAsync(string title, string message)
        {
            if (Application.Current.Dispatcher.CheckAccess())
            {
                await ShowDialogInternal(title, message);
            }
            else
            {
                await Application.Current.Dispatcher.InvokeAsync(() => ShowDialogInternal(title, message));
            }
        }

        private static async Task ShowDialogInternal(string title, string message)
        {
            if (Application.Current.MainWindow is not MainWindow mainWindow)
            {
                return;
            }

            var dialogHost = mainWindow.ContentPresenterForDialogs;
            if (dialogHost == null)
            {
                return;
            }

            var grid = new Grid();
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(40) });
            grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });

            var icon = new FontIcon
            {
                FontFamily = Application.Current.FindResource("SegoeFluentIcons") as FontFamily,
                Glyph = "\uE783",
                FontSize = 28,
                VerticalAlignment = VerticalAlignment.Center
            };

            var contentTextBlock = new TextBlock
            {
                Text = message,
                TextWrapping = TextWrapping.Wrap,
                FontSize = 14,
                LineHeight = 24,
                VerticalAlignment = VerticalAlignment.Center,
                Margin = new Thickness(12, 0, 0, 0)
            };

            Grid.SetColumn(icon, 0);
            Grid.SetColumn(contentTextBlock, 1);
            grid.Children.Add(icon);
            grid.Children.Add(contentTextBlock);

            var dialog = new ContentDialog
            {
                Title = title,
                Content = grid,
                CloseButtonText = Properties.Resources.sure,
                DialogHost = dialogHost
            };

            await dialog.ShowAsync(CancellationToken.None);
        }

        public static async Task<bool> ShowContentDialogAsync(string title, UserControl content)
        {
            if (Application.Current.MainWindow is not MainWindow mainWindow)
            {
                return false;
            }

            var dialogHost = mainWindow.ContentPresenterForDialogs;
            if (dialogHost == null)
            {
                return false;
            }

            var dialog = new ContentDialog
            {
                Title = title,
                Content = content,
                PrimaryButtonText = ExHyperV.Properties.Resources.create,
                CloseButtonText = ExHyperV.Properties.Resources.cancel,
                DialogHost = dialogHost,
                VerticalContentAlignment = VerticalAlignment.Top
            };

            var result = await dialog.ShowAsync(CancellationToken.None);

            return result == ContentDialogResult.Primary;
        }
    }
}

================================================================================
FILE: Tools\HcsManager.cs
================================================================================

﻿using System.Management;
using System.Runtime.InteropServices;
using System.Xml;

namespace ExHyperV.Tools
{
    public static class HcsManager
    {
        [DllImport("vmcompute.dll", SetLastError = true, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
        private static extern int HcsModifyServiceSettings(string settings, out IntPtr result);

        [DllImport("vmcompute.dll", SetLastError = true, CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
        private static extern int HcsGetServiceProperties(string propertyQuery, out IntPtr properties, out IntPtr result);

        [DllImport("ole32.dll")]
        private static extern void CoTaskMemFree(IntPtr ptr);

        [DllImport("ole32.dll")]
        private static extern int CoInitializeEx(IntPtr pvReserved, uint dwCoInit);

        [DllImport("ole32.dll")]
        private static extern void CoUninitialize();

        public static void SetVmCpuGroup(Guid vmId, Guid groupId)
        {
            bool isUnbinding = groupId == Guid.Empty;
            string scope = @"\\.\root\virtualization\v2";
            ManagementScope managementScope = new ManagementScope(scope);

            managementScope.Connect();
            ManagementObject processorSetting = GetProcessorSettingData(managementScope, vmId);
            if (processorSetting == null)
            {
                throw new Exception($"无法找到虚拟机 (ID: {vmId}) 的处理器配置。");
            }

            string originalProcessorSettingData = processorSetting.GetText(TextFormat.WmiDtd20);
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(originalProcessorSettingData);
            XmlNode cpuGroupIdPropertyNode = doc.SelectSingleNode("//PROPERTY[@NAME='CpuGroupId']");
            XmlNode cpuGroupIdValueNode = cpuGroupIdPropertyNode?.SelectSingleNode("VALUE");

            if (cpuGroupIdValueNode == null)
            {
                if (cpuGroupIdPropertyNode == null)
                {
                    cpuGroupIdPropertyNode = doc.CreateElement("PROPERTY");
                    XmlAttribute nameAttr = doc.CreateAttribute("NAME");
                    nameAttr.Value = "CpuGroupId";
                    cpuGroupIdPropertyNode.Attributes.Append(nameAttr);
                    XmlAttribute typeAttr = doc.CreateAttribute("TYPE");
                    typeAttr.Value = "string";
                    cpuGroupIdPropertyNode.Attributes.Append(typeAttr);
                    doc.DocumentElement.AppendChild(cpuGroupIdPropertyNode);
                }
                cpuGroupIdValueNode = doc.CreateElement("VALUE");
                cpuGroupIdPropertyNode.AppendChild(cpuGroupIdValueNode);
            }

            cpuGroupIdValueNode.InnerText = isUnbinding ? Guid.Empty.ToString("D") : groupId.ToString("D");

            ManagementObject managementService = GetVirtualSystemManagementService(managementScope);
            var inParams = managementService.GetMethodParameters("ModifyResourceSettings");
            inParams["ResourceSettings"] = new string[] { doc.OuterXml };

            var outParams = managementService.InvokeMethod("ModifyResourceSettings", inParams, null);
            uint returnValue = (uint)outParams["ReturnValue"];

            if (returnValue == 4096)
            {
                ManagementObject job = new ManagementObject((string)outParams["Job"]);
                job.Get();
                while ((ushort)job["JobState"] == 4 || (ushort)job["JobState"] == 7)
                {
                    System.Threading.Thread.Sleep(500);
                    job.Get();
                }
                if ((ushort)job["JobState"] != 10)
                {
                    throw new Exception($"应用CPU组的作业失败。作业状态: {(ushort)job["JobState"]}. 错误: {job["ErrorDescription"]}");
                }
            }
            else if (returnValue != 0)
            {
                throw new Exception($"应用CPU组失败。错误码: {returnValue}");
            }
        }

        private static ManagementObject GetVirtualSystemManagementService(ManagementScope scope)
        {
            var path = new ManagementPath("Msvm_VirtualSystemManagementService") { NamespacePath = scope.Path.Path, Server = scope.Path.Server };
            var mgmtClass = new ManagementClass(path);
            return mgmtClass.GetInstances().Cast<ManagementObject>().FirstOrDefault();
        }

        private static ManagementObject GetProcessorSettingData(ManagementScope scope, Guid vmId)
        {
            string query = $"SELECT * FROM Msvm_ProcessorSettingData WHERE InstanceID LIKE '%{vmId}%'";
            using (var searcher = new ManagementObjectSearcher(scope, new ObjectQuery(query)))
            {
                return searcher.Get().Cast<ManagementObject>().FirstOrDefault();
            }
        }

        public static string GetAllCpuGroupsAsJson()
        {
            return ExecuteHcsQuery("{\"PropertyTypes\":[\"CpuGroup\"]}");
        }

        public static string GetVmCpuGroupAsJson(Guid vmId)
        {
            string scope = @"\\.\root\virtualization\v2";
            string query = $"SELECT * FROM Msvm_ProcessorSettingData WHERE InstanceID LIKE '%{vmId}%'";
            string resultJson;
            CoInitializeEx(IntPtr.Zero, 2);
            try
            {
                using (var searcher = new ManagementObjectSearcher(scope, query))
                {
                    var vmSetting = searcher.Get().Cast<ManagementObject>().FirstOrDefault();
                    if (vmSetting?["CpuGroupId"] != null && Guid.TryParse(vmSetting["CpuGroupId"].ToString(), out Guid parsedGuid) && parsedGuid != Guid.Empty)
                    {
                        resultJson = $"{{ \"CpuGroupId\": \"{vmSetting["CpuGroupId"]}\" }}";
                    }
                    else
                    {
                        resultJson = $"{{ \"CpuGroupId\": \"{Guid.Empty}\" }}";
                    }
                }
            }
            finally
            {
                CoUninitialize();
            }
            return resultJson;
        }

        public static void CreateCpuGroup(Guid groupId, uint[] processorIndexes)
        {
            var processors = string.Join(",", processorIndexes);
            string createJson = $@"{{""PropertyType"":""CpuGroup"",""Settings"":{{""Operation"":""CreateGroup"",""OperationDetails"":{{""GroupId"":""{groupId}"",""LogicalProcessorCount"":{processorIndexes.Length},""LogicalProcessors"":[{processors}]}}}}}}";
            ExecuteHcsModification(createJson);
        }

        public static void DeleteCpuGroup(Guid groupId)
        {
            string deleteJson = $@"{{""PropertyType"":""CpuGroup"",""Settings"":{{""Operation"":""DeleteGroup"",""OperationDetails"":{{""GroupId"":""{groupId}""}}}}}}";
            ExecuteHcsModification(deleteJson);
        }

        public static void SetCpuGroupCap(Guid groupId, ushort cpuCap)
        {
            string setPropertyJson = $@"{{""PropertyType"":""CpuGroup"",""Settings"":{{""Operation"":""SetProperty"",""OperationDetails"":{{""GroupId"":""{groupId}"",""PropertyCode"":65536,""PropertyValue"":{cpuCap}}}}}}}";
            ExecuteHcsModification(setPropertyJson);
        }

        private static void ExecuteHcsModification(string jsonPayload)
        {
            CoInitializeEx(IntPtr.Zero, 0);
            IntPtr resultPtr = IntPtr.Zero;
            try
            {
                int hResult = HcsModifyServiceSettings(jsonPayload, out resultPtr);
                if (hResult != 0)
                {
                    string errorJson = Marshal.PtrToStringUni(resultPtr);
                    throw new Exception($"HCS Modify call failed. HRESULT: 0x{hResult:X}. Details: {errorJson}");
                }
            }
            finally
            {
                if (resultPtr != IntPtr.Zero) CoTaskMemFree(resultPtr);
                CoUninitialize();
            }
        }

        private static string ExecuteHcsQuery(string jsonPayload)
        {
            CoInitializeEx(IntPtr.Zero, 0);
            IntPtr propertiesPtr = IntPtr.Zero;
            IntPtr resultPtr = IntPtr.Zero;
            string resultJson = null;
            try
            {
                int hResult = HcsGetServiceProperties(jsonPayload, out propertiesPtr, out resultPtr);
                if (hResult != 0)
                {
                    string errorJson = Marshal.PtrToStringUni(resultPtr);
                    throw new Exception($"HCS Query call failed. HRESULT: 0x{hResult:X}. Details: {errorJson}");
                }
                if (propertiesPtr != IntPtr.Zero)
                {
                    resultJson = Marshal.PtrToStringUni(propertiesPtr);
                }
            }
            finally
            {
                if (propertiesPtr != IntPtr.Zero) CoTaskMemFree(propertiesPtr);
                if (resultPtr != IntPtr.Zero) CoTaskMemFree(resultPtr);
                CoUninitialize();
            }
            return resultJson;
        }
    }
}

================================================================================
FILE: Tools\ProcessAffinityManager.cs
================================================================================

﻿// 文件: ProcessAffinityManager.cs

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Management;

namespace ExHyperV.Services
{
    public static class ProcessAffinityManager
    {
        /// <summary>
        /// 根据虚拟机的 GUID，通过查询用户名为该 GUID 的 vmmem 进程来查找其内存进程。
        /// </summary>
        private static Process FindVmMemoryProcess(Guid vmId)
        {
            string vmIdString = vmId.ToString("D").ToUpper();
            string wmiQuery = "SELECT ProcessId, Handle FROM Win32_Process WHERE Name LIKE 'vmmem%'";
            try
            {
                using (var searcher = new ManagementObjectSearcher(wmiQuery))
                {
                    foreach (ManagementObject mo in searcher.Get())
                    {
                        string[] owner = new string[2];
                        mo.InvokeMethod("GetOwner", (object[])owner);
                        string userName = owner[0];

                        if (!string.IsNullOrEmpty(userName) && userName.Equals(vmIdString, StringComparison.OrdinalIgnoreCase))
                        {
                            try
                            {
                                int pid = Convert.ToInt32(mo["ProcessId"]);
                                return Process.GetProcessById(pid);
                            }
                            catch (Exception ex)
                            {
                                Debug.WriteLine($"[ProcessAffinityManager] 找到匹配的 vmmem 进程 (PID: {mo["ProcessId"]}) 但获取失败: {ex.Message}");
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ProcessAffinityManager] WMI 查询 vmmem 进程失败: {ex.Message}");
            }

            return null;
        }

        /// <summary>
        /// 获取指定虚拟机的 vmmem 进程的当前 CPU 核心相关性。
        /// </summary>
        public static List<int> GetVmProcessAffinity(Guid vmId)
        {
            var coreIds = new List<int>();
            var process = FindVmMemoryProcess(vmId);
            if (process != null)
            {
                try
                {
                    long affinityMask = (long)process.ProcessorAffinity;
                    for (int i = 0; i < Environment.ProcessorCount; i++)
                    {
                        if ((affinityMask & (1L << i)) != 0)
                        {
                            coreIds.Add(i);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[ProcessAffinityManager] 获取进程 {process.Id} 的相关性失败: {ex.Message}");
                }
            }
            return coreIds;
        }

        /// <summary>
        /// 为指定虚拟机的 vmmem 进程设置新的 CPU 核心相关性。
        /// </summary>
        public static void SetVmProcessAffinity(Guid vmId, List<int> coreIds)
        {
            var process = FindVmMemoryProcess(vmId);
            if (process != null)
            {
                try
                {
                    long newAffinityMask = 0;
                    foreach (int coreId in coreIds)
                    {
                        newAffinityMask |= (1L << coreId);
                    }

                    if (coreIds.Any())
                    {
                        process.ProcessorAffinity = (IntPtr)newAffinityMask;
                    }
                    else
                    {
                        long allProcessorsMask = (1L << Environment.ProcessorCount) - 1;
                        if (Environment.ProcessorCount == 64)
                        {
                            allProcessorsMask = -1;
                        }
                        process.ProcessorAffinity = (IntPtr)allProcessorsMask;
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[ProcessAffinityManager] 设置进程 {process.Id} 的相关性失败: {ex.Message}");
                }
            }
        }
    }
}

================================================================================
FILE: Tools\ScrollHelper.cs
================================================================================

﻿using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace ExHyperV.Tools
{
    public static class ScrollHelper
    {
        public static readonly DependencyProperty LockParentScrollProperty =
            DependencyProperty.RegisterAttached(
                "LockParentScroll",
                typeof(bool),
                typeof(ScrollHelper),
                new PropertyMetadata(false, OnLockParentScrollChanged));

        public static void SetLockParentScroll(DependencyObject element, bool value) => element.SetValue(LockParentScrollProperty, value);
        public static bool GetLockParentScroll(DependencyObject element) => (bool)element.GetValue(LockParentScrollProperty);
        private static readonly DependencyProperty CachedScrollerProperty =
            DependencyProperty.RegisterAttached("CachedScroller", typeof(ScrollViewer), typeof(ScrollHelper), new PropertyMetadata(null));

        private static readonly DependencyProperty OriginalVisibilityProperty =
            DependencyProperty.RegisterAttached("OriginalVisibility", typeof(ScrollBarVisibility), typeof(ScrollHelper), new PropertyMetadata(ScrollBarVisibility.Auto));

        private static void OnLockParentScrollChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is Page page)
            {
                if ((bool)e.NewValue)
                {
                    page.Loaded += Page_Loaded;
                    page.Unloaded += Page_Unloaded;
                }
                else
                {
                    page.Loaded -= Page_Loaded;
                    page.Unloaded -= Page_Unloaded;
                }
            }
        }

        private static void Page_Loaded(object sender, RoutedEventArgs e)
        {
            var page = sender as Page;
            if (page == null) return;
            var scroller = FindParent<ScrollViewer>(page);
            if (scroller != null)
            {
                page.SetValue(CachedScrollerProperty, scroller);
                page.SetValue(OriginalVisibilityProperty, scroller.VerticalScrollBarVisibility);
                scroller.VerticalScrollBarVisibility = ScrollBarVisibility.Disabled;
            }
        }

        private static void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            var page = sender as Page;
            if (page == null) return;
            var scroller = (ScrollViewer)page.GetValue(CachedScrollerProperty);
            var originalValue = (ScrollBarVisibility)page.GetValue(OriginalVisibilityProperty);

            if (scroller != null)
            {
                scroller.VerticalScrollBarVisibility = originalValue;
                page.SetValue(CachedScrollerProperty, null);
            }
        }

        private static T? FindParent<T>(DependencyObject? child) where T : DependencyObject
        {
            while (child != null)
            {
                if (child is T parent) return parent;
                child = VisualTreeHelper.GetParent(child);
            }
            return null;
        }
    }
}

================================================================================
FILE: Tools\StretchUniformGrid.cs
================================================================================

﻿namespace ExHyperV.Tools
{
    using System;
    using System.Windows;
    using System.Windows.Controls;

    public class StretchUniformGrid : Panel
    {
        public static readonly DependencyProperty ColumnsProperty =
            DependencyProperty.Register(nameof(Columns), typeof(int), typeof(StretchUniformGrid),
                new FrameworkPropertyMetadata(1, FrameworkPropertyMetadataOptions.AffectsMeasure));

        public int Columns
        {
            get => (int)GetValue(ColumnsProperty);
            set => SetValue(ColumnsProperty, value);
        }

        public static readonly DependencyProperty RowsProperty =
            DependencyProperty.Register(nameof(Rows), typeof(int), typeof(StretchUniformGrid),
                new FrameworkPropertyMetadata(1, FrameworkPropertyMetadataOptions.AffectsMeasure));

        public int Rows
        {
            get => (int)GetValue(RowsProperty);
            set => SetValue(RowsProperty, value);
        }

        protected override Size MeasureOverride(Size availableSize)
        {
            if (InternalChildren.Count == 0 || Columns <= 0 || Rows <= 0)
            {
                return new Size(0, 0);
            }

            if (double.IsInfinity(availableSize.Width) || double.IsInfinity(availableSize.Height))
            {
                return new Size(0, 0);
            }

            return availableSize;
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            if (InternalChildren.Count == 0 || Columns <= 0 || Rows <= 0)
            {
                return finalSize;
            }

            double cellWidth = finalSize.Width / Columns;
            double cellHeight = finalSize.Height / Rows;

            if (double.IsNaN(cellWidth) || double.IsNaN(cellHeight) || double.IsInfinity(cellWidth) || double.IsInfinity(cellHeight))
            {
                return finalSize;
            }

            for (int i = 0; i < InternalChildren.Count; i++)
            {
                var child = InternalChildren[i];

                int col = i % Columns;
                int row = i / Columns;

                double x = col * cellWidth;
                double y = row * cellHeight;

                var finalRect = new Rect(x, y, cellWidth, cellHeight);
                child.Arrange(finalRect);
            }

            return finalSize;
        }
    }
}

================================================================================
FILE: Tools\SystemSwitcher.cs
================================================================================

﻿using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace ExHyperV.Tools
{
    public static class SystemSwitcher
    {
        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetCurrentProcess();
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, out LUID lpLuid);
        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges, ref TOKEN_PRIVILEGES NewState, uint BufferLength, IntPtr PreviousState, IntPtr ReturnLength);
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool CloseHandle(IntPtr hObject);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegOpenKeyEx(IntPtr hKey, string lpSubKey, uint ulOptions, int samDesired, out IntPtr phkResult);
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegSaveKey(IntPtr hKey, string lpFile, IntPtr lpSecurityAttributes);
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegReplaceKey(IntPtr hKey, string lpSubKey, string lpNewFile, string lpOldFile);
        [DllImport("advapi32.dll", SetLastError = true)]
        static extern int RegCloseKey(IntPtr hKey);
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegLoadKey(IntPtr hKey, string lpSubKey, string lpFile);
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegUnLoadKey(IntPtr hKey, string lpSubKey);
        [DllImport("advapi32.dll", SetLastError = true)]
        static extern int RegFlushKey(IntPtr hKey);
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegSetValueEx(IntPtr hKey, string lpValueName, int Reserved, int dwType, byte[] lpData, int cbData);
        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        static extern int RegQueryValueEx(IntPtr hKey, string lpValueName, IntPtr lpReserved, ref int lpType, ref int lpData, ref int lpcbData);

        [StructLayout(LayoutKind.Sequential)]
        struct LUID { public uint LowPart; public int HighPart; }
        [StructLayout(LayoutKind.Sequential)]
        struct TOKEN_PRIVILEGES { public uint PrivilegeCount; [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)] public LUID_AND_ATTRIBUTES[] Privileges; }
        [StructLayout(LayoutKind.Sequential)]
        struct LUID_AND_ATTRIBUTES { public LUID Luid; public uint Attributes; }

        const uint KEY_READ = 0x20019;
        const uint KEY_SET_VALUE = 0x0002;
        const int REG_SZ = 1;
        static readonly IntPtr HKEY_LOCAL_MACHINE = new IntPtr(unchecked((int)0x80000002));

        public static bool EnablePrivilege(string privilegeName)
        {
            if (!OpenProcessToken(GetCurrentProcess(), 0x0020 | 0x0008, out IntPtr hToken)) return false;
            try
            {
                if (!LookupPrivilegeValue(null, privilegeName, out LUID luid)) return false;
                TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES { PrivilegeCount = 1, Privileges = new LUID_AND_ATTRIBUTES[1] };
                tp.Privileges[0].Luid = luid;
                tp.Privileges[0].Attributes = 0x00000002;
                return AdjustTokenPrivileges(hToken, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero);
            }
            finally { CloseHandle(hToken); }
        }

        public static string ExecutePatch(int mode)
        {
            string tempDir = @"C:\temp";
            string hiveFile = Path.Combine(tempDir, "sys_mod_exec.hiv");
            string backupFile = Path.Combine(tempDir, "sys_bak_exec.hiv");

            try
            {
                if (!Directory.Exists(tempDir)) Directory.CreateDirectory(tempDir);
                try { if (File.Exists(hiveFile)) File.Delete(hiveFile); } catch { return "SUCCESS"; }
                try { if (File.Exists(backupFile)) File.Delete(backupFile); } catch { }

                if (!EnablePrivilege("SeBackupPrivilege") || !EnablePrivilege("SeRestorePrivilege")) return "权限不足";

                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SYSTEM", 0, (int)KEY_READ, out IntPtr hKey) != 0) return "打不开键";
                int ret = RegSaveKey(hKey, hiveFile, IntPtr.Zero);
                RegCloseKey(hKey);
                if (ret != 0) return $"导出失败:{ret}";

                string targetType = (mode == 1) ? "ServerNT" : "WinNT";
                if (!PatchHiveOffline(hiveFile, targetType)) return "离线修改失败";

                ret = RegReplaceKey(HKEY_LOCAL_MACHINE, "SYSTEM", hiveFile, backupFile);

                return ret == 0 || ret == 5 ? "SUCCESS" : $"替换失败:{ret}";
            }
            catch (Exception ex) { return ex.Message; }
        }

        private static bool PatchHiveOffline(string hivePath, string targetType)
        {
            string tempKeyName = "TEMP_OFFLINE_SYS_MOD";

            if (RegLoadKey(HKEY_LOCAL_MACHINE, tempKeyName, hivePath) != 0) return false;

            try
            {
                int currentSet = 1;
                string selectPath = tempKeyName + "\\Select";
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, selectPath, 0, (int)KEY_READ, out IntPtr hKeySelect) == 0)
                {
                    int type = 0;
                    int data = 0;
                    int size = 4;
                    if (RegQueryValueEx(hKeySelect, "Current", IntPtr.Zero, ref type, ref data, ref size) == 0)
                    {
                        currentSet = data;
                    }
                    RegCloseKey(hKeySelect);
                }

                string setPath = $"{tempKeyName}\\ControlSet{currentSet:D3}\\Control\\ProductOptions";
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, setPath, 0, (int)KEY_SET_VALUE, out IntPtr hKey) != 0)
                {
                    setPath = $"{tempKeyName}\\ControlSet001\\Control\\ProductOptions";
                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, setPath, 0, (int)KEY_SET_VALUE, out hKey) != 0) return false;
                }

                byte[] dataBytes = Encoding.ASCII.GetBytes(targetType + "\0");
                int writeRet = RegSetValueEx(hKey, "ProductType", 0, REG_SZ, dataBytes, dataBytes.Length);

                RegCloseKey(hKey);
                RegFlushKey(HKEY_LOCAL_MACHINE);

                return writeRet == 0;
            }
            finally
            {
                RegUnLoadKey(HKEY_LOCAL_MACHINE, tempKeyName);
            }
        }
    }
}

================================================================================
FILE: Tools\TopologyCanvas.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Shapes;
using ExHyperV.Models;
using UiTextBlock = Wpf.Ui.Controls.TextBlock;

namespace ExHyperV.Tools
{
    public class TopologyCanvas : Canvas
    {
        public static readonly DependencyProperty ItemsSourceProperty =
            DependencyProperty.Register("ItemsSource", typeof(ObservableCollection<AdapterInfo>), typeof(TopologyCanvas), new PropertyMetadata(null, OnItemsSourceChanged));
        public ObservableCollection<AdapterInfo> ItemsSource { get => (ObservableCollection<AdapterInfo>)GetValue(ItemsSourceProperty); set => SetValue(ItemsSourceProperty, value); }

        public static readonly DependencyProperty SwitchNameProperty =
            DependencyProperty.Register("SwitchName", typeof(string), typeof(TopologyCanvas), new PropertyMetadata(string.Empty, OnPropertiesChanged));
        public string SwitchName { get => (string)GetValue(SwitchNameProperty); set => SetValue(SwitchNameProperty, value); }

        public static readonly DependencyProperty NetworkModeProperty =
            DependencyProperty.Register("NetworkMode", typeof(string), typeof(TopologyCanvas), new PropertyMetadata("Isolated", OnPropertiesChanged));
        public string NetworkMode { get => (string)GetValue(NetworkModeProperty); set => SetValue(NetworkModeProperty, value); }

        public static readonly DependencyProperty UpstreamAdapterProperty =
            DependencyProperty.Register("UpstreamAdapter", typeof(string), typeof(TopologyCanvas), new PropertyMetadata(string.Empty, OnPropertiesChanged));
        public string UpstreamAdapter { get => (string)GetValue(UpstreamAdapterProperty); set => SetValue(UpstreamAdapterProperty, value); }

        public TopologyCanvas()
        {
            this.IsVisibleChanged += OnIsVisibleChanged;
        }

        private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            if (this.IsVisible)
            {
                Redraw();
            }
        }

        private static void OnItemsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is not TopologyCanvas canvas) return;
            if (e.OldValue is ObservableCollection<AdapterInfo> o) o.CollectionChanged -= canvas.OnCollectionChanged;
            if (e.NewValue is ObservableCollection<AdapterInfo> n) n.CollectionChanged += canvas.OnCollectionChanged;
            canvas.Redraw();
        }

        private static void OnPropertiesChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) => (d as TopologyCanvas)?.Redraw();
        private void OnCollectionChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) => Redraw();

        private void Redraw()
        {
            if (!this.IsVisible) return;
            Children.Clear();
            if (ItemsSource == null) return;

            double iconSize = 28;
            double radius = iconSize / 2;
            double verticalSpacing = 70;
            double horizontalVmSpacing = 140;
            double lineThickness = 1.5;
            double upstreamY = 20;
            double switchY = upstreamY + verticalSpacing;

            double vmBusY = switchY + 40; // 从交换机到总线的距离
            double vmY = vmBusY + 30;    // 从总线到客户端图标的距离

            void CreateNode(string type, string name, string ip, string mac, double x, double y, bool wrap = false)
            {
                var icon = Utils.FontIcon1(type, "");
                icon.FontSize = iconSize;
                SetLeft(icon, x - iconSize / 2); SetTop(icon, y - iconSize / 2); Children.Add(icon);
                var panel = new StackPanel { HorizontalAlignment = HorizontalAlignment.Center, Orientation = Orientation.Vertical };
                var nameText = new UiTextBlock { Text = name, FontSize = 12, TextAlignment = TextAlignment.Center, Margin = new Thickness(0, 0, 0, 2) };
                if (wrap) { nameText.MaxWidth = horizontalVmSpacing - 10; nameText.TextWrapping = TextWrapping.Wrap; }
                nameText.SetResourceReference(UiTextBlock.ForegroundProperty, "TextFillColorPrimaryBrush");
                panel.Children.Add(nameText);
                if (!string.IsNullOrEmpty(mac))
                {
                    var macText = new UiTextBlock { Text = mac, FontSize = 10, TextAlignment = TextAlignment.Center };
                    macText.SetResourceReference(UiTextBlock.ForegroundProperty, "TextFillColorPrimaryBrush");
                    panel.Children.Add(macText);
                }
                if (!string.IsNullOrEmpty(ip))
                {
                    var ipText = new UiTextBlock { Text = ip, FontSize = 11, TextAlignment = TextAlignment.Center, Margin = new Thickness(0, -4, 0, 0) };
                    ipText.SetResourceReference(UiTextBlock.ForegroundProperty, "TextFillColorPrimaryBrush");
                    panel.Children.Add(ipText);
                }
                panel.Loaded += (s, _) => { if (s is StackPanel p) { SetLeft(p, x - p.ActualWidth / 2); SetTop(p, y + iconSize / 2 + 5); } };
                Children.Add(panel);
            }

            void DrawLine(double x1, double y1, double x2, double y2)
            {
                var line = new Line { X1 = x1, Y1 = y1, X2 = x2, Y2 = y2, StrokeThickness = lineThickness };
                line.SetResourceReference(Shape.StrokeProperty, "TextFillColorSecondaryBrush"); Children.Add(line);
            }

            string ParseIPv4(string s) => string.IsNullOrEmpty(s) ? "" : s.Trim('{', '}').Split(new[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries).FirstOrDefault(ip => IPAddress.TryParse(ip, out var p) && p.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) ?? "";

            var clients = ItemsSource.Select(a => (Name: a.VMName, Ip: ParseIPv4(a.IPAddresses), Mac: a.MacAddress)).ToList();

            bool isDefaultSwitch = SwitchName == "Default Switch";
            bool hasUpstream = (NetworkMode == "Bridge" || NetworkMode == "NAT") && (!string.IsNullOrEmpty(UpstreamAdapter) || isDefaultSwitch);

            double totalWidth = Math.Max(200, (clients.Count > 0 ? clients.Count : 1) * horizontalVmSpacing);
            double centerX = totalWidth / 2;

            CreateNode("Switch", SwitchName, "", "", centerX, switchY);

            if (hasUpstream)
            {
                string upstreamName = isDefaultSwitch ? "Internet" : UpstreamAdapter;
                CreateNode("Upstream", upstreamName, "", "", centerX, upstreamY);
                DrawLine(centerX, upstreamY + radius, centerX, switchY);
            }

            if (clients.Any())
            {
                double startX = centerX - ((clients.Count - 1) * horizontalVmSpacing) / 2;
                DrawLine(centerX, switchY, centerX, vmBusY);
                if (clients.Count > 1) DrawLine(startX, vmBusY, startX + (clients.Count - 1) * horizontalVmSpacing, vmBusY);
                for (int i = 0; i < clients.Count; i++)
                {
                    var c = clients[i];
                    double currentX = startX + i * horizontalVmSpacing;
                    CreateNode("Net", c.Name, c.Ip, c.Mac, currentX, vmY, wrap: true);
                    DrawLine(currentX, vmBusY, currentX, vmY - radius);
                }
            }

            Width = totalWidth + 40;
            Height = vmY + 80;
        }
    }
}

================================================================================
FILE: Tools\Utils.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Reflection;
using System.Text;
using System.Windows;
using System.Windows.Media;
using Wpf.Ui.Controls;
using System.Text.RegularExpressions;

namespace ExHyperV.Tools;


public class PowerShellScriptException : Exception
{
    public PowerShellScriptException(string message) : base(message) { }
}

public class Utils
{
    private static RunspacePool? _runspacePool;


    public static void InitializePowerShell()
    {
        if (_runspacePool == null)
        {
            InitialSessionState initialSessionState = InitialSessionState.CreateDefault();
            _runspacePool = RunspaceFactory.CreateRunspacePool(initialSessionState);
            _runspacePool.Open();
        }
    }

    public static void CleanupPowerShell()
    {
        _runspacePool?.Close();
        _runspacePool?.Dispose();
        _runspacePool = null;
    }

    public static Collection<PSObject> Run(string script)
    {
        using (PowerShell ps = PowerShell.Create())
        {
            ps.AddScript(script);
            var results = ps.Invoke();
            return results;
        }
    }
    public static async Task<Collection<PSObject>> Run2(string script, CancellationToken cancellationToken = default)
    {
        return await ExecuteCoreAsync(script, cancellationToken);
    }

    private static async Task<Collection<PSObject>> ExecuteCoreAsync(string script, CancellationToken cancellationToken)
    {
        return await Task.Run(async () =>
        {
            using (var ps = PowerShell.Create())
            {
                ps.RunspacePool = _runspacePool;
                ps.AddScript(script);
                var psDataCollection = await ps.InvokeAsync().WaitAsync(cancellationToken);

                if (ps.HadErrors)
                {
                    var errorMessages = new StringBuilder();
                    foreach (var error in ps.Streams.Error)
                    {
                        errorMessages.AppendLine(error.Exception.Message);
                    }
                    throw new PowerShellScriptException(errorMessages.ToString());
                }
                return new Collection<PSObject>(psDataCollection);
            }
        }, cancellationToken);
    }
    public static string GetIconPath(string deviceType, string friendlyName)
    {
        switch (deviceType)
        {
            case "Switch":
                return "\xF597";  // 交换机图标 
            case "Upstream":
                return "\uE774";  // 地球/上游网络图标
            case "Display":
                return "\xF211";  // 显卡图标 
            case "Net":
                return "\xE839";  // 网络图标
            case "USB":
                return friendlyName.Contains("USB4")
                    ? "\xE945"    // 雷电接口图标
                    : "\xECF0";   // 普通USB图标
            case "HIDClass":
                return "\xE928";  // HID设备图标
            case "SCSIAdapter":
            case "HDC":
                return "\xEDA2";  // 存储控制器图标
            default:
                return friendlyName.Contains("Audio")
                    ? "\xE995"     // 音频设备图标
                    : "\xE950";    // 默认图标
        }
    }


    public static FontIcon FontIcon1(string classType, string friendlyName)
    {
        return new FontIcon
        {
            FontSize = 24,
            FontFamily = (FontFamily)Application.Current.Resources["SegoeFluentIcons"],
            Glyph = GetIconPath(classType, friendlyName) // 获取图标Unicode
        };
    }


    public static string GetGpuImagePath(string Manu, string name)
    {
        string imageName;

        // 根据 Manu 设置不同的图片文件名
        if (Manu.Contains("NVIDIA")) // 如果是 NVIDIA 显卡，使用 NVIDIA 的图片
        {
            imageName = "NVIDIA.png";
        }
        else if (Manu.Contains("Advanced")) //"Advanced Micro Devices, Inc."
        {
            imageName = "AMD.png";
        }
        else if (Manu.Contains("Microsoft")) //"Microsoft"
        {
            imageName = "Microsoft.png";
        }
        else if (Manu.Contains("Intel")) // "Intel Corporation"
        {
            imageName = "Intel.png";
            if (name.ToLower().Contains("iris"))
            {
                imageName = "Intel-IrisXe.png";
            }
            if (name.ToLower().Contains("arc"))
            {
                imageName = "Inter-ARC.png";
            }
            if (name.ToLower().Contains("data"))
            {
                imageName = "Inter-DataCenter.png";
            }


        }
        else if (Manu.Contains("Moore")) // "Moore Threads"
        {
            imageName = "Moore.png";
        }
        else if (Manu.Contains("Qualcomm")) // "Qualcomm Incorporated"
        {
            imageName = "Qualcomm.png";
        }
        else if (Manu.Contains("DisplayLink")) //"DisplayLink"
        {
            imageName = "DisplayLink.png";
        }
        else if (Manu.Contains("Silicon")) //"SiliconMotion"
        {
            imageName = "Silicon.png";
        }
        else
        {
            imageName = "Default.png";  // 其他情况
        }

        return $"pack://application:,,,/Assets/{imageName}";
    }

    public static FontIcon FontIcon(int Size, string Glyph)
    {
        var icon = new FontIcon
        {
            FontSize = Size,
            FontFamily = (FontFamily)Application.Current.Resources["SegoeFluentIcons"],
            Glyph = Glyph // 获取图标Unicode
        };
        return icon;
    }
    public static DateTime GetLinkerTime()
    {
        //获取编译时间
        string filePath = Assembly.GetExecutingAssembly().Location;
        var fileInfo = new System.IO.FileInfo(filePath);
        DateTime linkerTime = fileInfo.LastWriteTime;
        return linkerTime;
    }

    public static async Task UpdateSwitchConfigurationAsync(string switchName, string mode, string? physicalAdapterName, bool allowManagementOS, bool enabledhcp)
    {
        string script;
        switch (mode)
        {
            case "Bridge":


                //1.清除ICS设置。2.清除多余的宿主适配器。3.设置交换机为外部交换机，指定上游网卡。

                script = $@"$netShareManager = New-Object -ComObject HNetCfg.HNetShare;
                foreach ($connection in $netShareManager.EnumEveryConnection) {{
                    $props = $netShareManager.NetConnectionProps.Invoke($connection);
                    $config = $netShareManager.INetSharingConfigurationForINetConnection.Invoke($connection);
                    if ($config.SharingEnabled) {{
                        $config.DisableSharing();
                    }}
                }}";
                script += $"Get-VMNetworkAdapter -ManagementOS -SwitchName '{switchName}' -ErrorAction SilentlyContinue | Remove-VMNetworkAdapter -Confirm:$false;";
                script += $"\nSet-VMSwitch -Name '{switchName}' -NetAdapterInterfaceDescription '{physicalAdapterName}'";

                break;

            case "NAT":
                //1.设置为内部交换机。2.开启ICS.

                script = $"Set-VMSwitch -Name '{switchName}' -SwitchType Internal;";
                script += $@"$PublicAdapterDescription = '{physicalAdapterName}';
                $SwitchName = '{switchName}';
                $publicNic = Get-NetAdapter -InterfaceDescription $PublicAdapterDescription -ErrorAction SilentlyContinue;
                $PublicAdapterActualName = $publicNic.Name;
                $vmAdapter = Get-VMNetworkAdapter -ManagementOS -SwitchName $SwitchName -ErrorAction SilentlyContinue;
                $privateAdapter = Get-NetAdapter | Where-Object {{ ($_.MacAddress -replace '[-:]') -eq ($vmAdapter.MacAddress -replace '[-:]') }};
                $PrivateAdapterName = $privateAdapter.Name;

                $netShareManager = New-Object -ComObject HNetCfg.HNetShare;
                $publicConfig = $null;
                $privateConfig = $null;

                foreach ($connection in $netShareManager.EnumEveryConnection) {{
                    $props = $netShareManager.NetConnectionProps.Invoke($connection);
                    $config = $netShareManager.INetSharingConfigurationForINetConnection.Invoke($connection);
                    if ($config.SharingEnabled) {{
                        $config.DisableSharing();
                    }}
                    if ($props.Name -eq $PublicAdapterActualName) {{
                        $publicConfig = $config;
                    }}
                    elseif ($props.Name -eq $PrivateAdapterName) {{
                        $privateConfig = $config;
                    }}
                }}

                if ($publicConfig -and $privateConfig) {{
                    $publicConfig.EnableSharing(0);
                    $privateConfig.EnableSharing(1);

                }}
                ";
                break;

            case "Isolated":
                script = $"\nSet-VMSwitch -Name '{switchName}' -SwitchType Internal;";
                script += $@"$netShareManager = New-Object -ComObject HNetCfg.HNetShare;
                foreach ($connection in $netShareManager.EnumEveryConnection) {{
                    $props = $netShareManager.NetConnectionProps.Invoke($connection);
                    $config = $netShareManager.INetSharingConfigurationForINetConnection.Invoke($connection);
                    if ($config.SharingEnabled) {{
                        $config.DisableSharing();
                    }}
                }}";
                if (allowManagementOS)
                {
                    script += $"\nif (-not (Get-VMNetworkAdapter -ManagementOS -SwitchName '{switchName}' -ErrorAction SilentlyContinue)) {{ Add-VMNetworkAdapter -ManagementOS -SwitchName '{switchName}' }};";
                }
                else
                {
                    script += $"\nGet-VMNetworkAdapter -ManagementOS -SwitchName '{switchName}' -ErrorAction SilentlyContinue | Remove-VMNetworkAdapter -Confirm:$false;";
                }
                break;

            default:
                throw new ArgumentException($"错误：未知的网络模式 '{mode}'");
        }
        await RunScriptSTA(script);
        if (enabledhcp) { }
    }
    public static Task RunScriptSTA(string script)
    {
        var tcs = new TaskCompletionSource<object?>();

        var staThread = new Thread(() =>
        {
            try
            {
                Run(script);
                tcs.SetResult(null); // 表示成功完成
            }
            catch (Exception ex)
            {
                tcs.SetException(ex); // 将异常传递给 Task
            }
        });
        staThread.SetApartmentState(ApartmentState.STA);
        staThread.IsBackground = true;
        staThread.Start();

        return tcs.Task;
    }


    /// <summary>
    /// 添加Hyper-V GPU分配策略注册表项，以允许不受支持的GPU进行分区。
    /// </summary>
    public static void AddGpuAssignmentStrategyReg()
    {
        string path = @"HKLM:\SOFTWARE\Policies\Microsoft\Windows\HyperV";
        string script = $@"
            if (-not (Test-Path '{path}')) {{ New-Item -Path '{path}' -Force }}
            Set-ItemProperty -Path '{path}' -Name 'RequireSecureDeviceAssignment' -Value 0 -Type DWord
            Set-ItemProperty -Path '{path}' -Name 'RequireSupportedDeviceAssignment' -Value 0 -Type DWord";
        Run(script); 
    }

    /// <summary>
    /// 移除Hyper-V GPU分配策略注册表项。
    /// </summary>
    public static void RemoveGpuAssignmentStrategyReg()
    {
        string path = @"HKLM:\SOFTWARE\Policies\Microsoft\Windows\HyperV";
        string script = $@"
            if (Test-Path '{path}') {{
                Remove-ItemProperty -Path '{path}' -Name 'RequireSecureDeviceAssignment' -ErrorAction SilentlyContinue
                Remove-ItemProperty -Path '{path}' -Name 'RequireSupportedDeviceAssignment' -ErrorAction SilentlyContinue
            }}";
        Run(script); 
    }

    /// <summary>
    /// 应用 GPU-P 修复补丁。
    /// 该方法通过禁用 Hyper-V 的 GPU 分区严格模式来解决 Windows 更新后的问题。
    /// </summary>
    public static void ApplyGpuPartitionStrictModeFix()
    {
        string path = @"HKLM:\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Virtualization";
        string script = $@"
            if (-not (Test-Path '{path}')) {{ New-Item -Path '{path}' -Force }}
            Set-ItemProperty -Path '{path}' -Name 'DisableGpuPartitionStrictMode' -Value 1 -Type DWord -Force";
        Run(script);
    }

    #region Hyper-V Network Helpers

    /// <summary>
    /// 异步获取虚拟机的IP地址。
    /// 首先尝试通过Hyper-V集成服务直接获取，如果失败，则回退到使用主机的ARP缓存通过MAC地址查找。
    /// </summary>
    /// <param name="vmName">虚拟机的名称。</param>
    /// <param name="macAddressWithColons">虚拟机网络适配器的MAC地址，格式为 "00:15:5D:..."。</param>
    /// <returns>一个包含逗号分隔的IP地址的字符串，如果未找到则为空字符串。</returns>
    public static async Task<string> GetVmIpAddressAsync(string vmName, string macAddressWithColons)
    {
        if (string.IsNullOrEmpty(vmName) || string.IsNullOrEmpty(macAddressWithColons))
        {
            return string.Empty;
        }

        // 1. 尝试直接从Hyper-V获取IP
        string macAddressWithoutColons = macAddressWithColons.Replace(":", "");
        // 注意: Get-VMNetworkAdapter 返回的 IPAddresses 是一个字符串数组
        string directIpScript = $"@(Get-VMNetworkAdapter -VMName '{vmName}' | Where-Object {{ $_.MacAddress -eq '{macAddressWithoutColons}' }}).IPAddresses";

        string ipAddresses = string.Empty;
        try
        {
            var directResults = await Run2(directIpScript);

            if (directResults != null && directResults.Count > 0)
            {
                var ips = directResults.Select(pso => pso?.BaseObject?.ToString()).Where(ip => !string.IsNullOrEmpty(ip));
                ipAddresses = string.Join(", ", ips);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Direct IP lookup for VM '{vmName}' failed: {ex.Message}");
            // 失败时继续尝试ARP，所以这里不抛出异常
        }


        // 2. 如果直接获取失败，则尝试从ARP缓存获取
        if (string.IsNullOrEmpty(ipAddresses))
        {
            System.Diagnostics.Debug.WriteLine($"Direct IP lookup failed or returned empty for VM '{vmName}' (MAC: {macAddressWithColons}). Trying ARP cache.");
            ipAddresses = await GetIpFromArpCacheByMacAsync(macAddressWithColons);
        }

        return ipAddresses;
    }

    /// <summary>
    /// 通过MAC地址在主机的ARP缓存中查找对应的IPv4地址。
    /// </summary>
    /// <param name="macWithColons">带冒号的MAC地址。</param>
    /// <returns>找到的IP地址，如果未找到则为空字符串。</returns>
    private static async Task<string> GetIpFromArpCacheByMacAsync(string macWithColons)
    {
        string formattedMacForArp = macWithColons.Replace(':', '-');
        string script = $"Get-NetNeighbor -AddressFamily IPv4 | Where-Object {{ $_.LinkLayerAddress -eq '{formattedMacForArp}' -and $_.State -ne 'Incomplete' }} | Select-Object -ExpandProperty IPAddress -First 1 -ErrorAction SilentlyContinue";

        try
        {
            // 使用 Run2 方法
            var results = await Run2(script);
            if (results != null && results.Count > 0)
            {
                return results[0]?.BaseObject?.ToString() ?? string.Empty;
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"ARP lookup failed for MAC {formattedMacForArp}: {ex.Message}");
        }
        return string.Empty;
    }

    #endregion


    public static void Show(string message)
    {
        var messageBox = new Wpf.Ui.Controls.MessageBox
        {
            Title = "提示",
            Content = message,
            CloseButtonText = "OK"
        };
        messageBox.ShowDialogAsync();
    }
    public static void Show2(string message)
    {

        System.Windows.MessageBox.Show(message);
    }
    public static string GetFriendlyErrorMessage(string rawMessage)
    {
        if (string.IsNullOrWhiteSpace(rawMessage)) return "Storage_Error_Unknown";
        var match = Regex.Match(rawMessage, @"Storage_(Error|Msg)_[A-Za-z0-9_]+");
        if (match.Success) return match.Value;
        string cleanMsg = Regex.Replace(rawMessage.Trim(), @"[\(\（].*?ID\s+[a-fA-F0-9-]{36}.*?[\)\）]", "").Replace("\r", "").Replace("\n", " ");
        var parts = cleanMsg.Split(new[] { '。', '.' }, StringSplitOptions.RemoveEmptyEntries).Select(s => s.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).ToList();
        return (parts.Count >= 2 && parts.Last().Length > 2) ? parts.Last() + "。" : cleanMsg;
    }
    public static string FormatBytes(long bytes)
    {
        if (bytes < 0)
        {
            return "Invalid size";
        }
        if (bytes == 0)
        {
            return "0 B";
        }

        string[] units = { "B", "KB", "MB", "GB", "TB", "PB", "EB" };

        int unitIndex = (int)Math.Floor(Math.Log(bytes, 1024));

        double number = bytes / Math.Pow(1024, unitIndex);

        string format = (unitIndex == 0) ? "F0" : "F2";

        return $"{number.ToString(format)} {units[unitIndex]}";
    }

    public static string Version => "V1.3.2-Beta";
    public static string Author => "Saniye";

}

================================================================================
FILE: ViewModels\AddDiskViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Services;
using System.Collections.ObjectModel;
using System.Windows;

namespace ExHyperV.ViewModels
{
    public partial class AddDiskViewModel : ObservableObject
    {
        private readonly IStorageService _storageService;
        private readonly string _vmName;
        private readonly int _vmGeneration;
        private readonly bool _isVmRunning;
        private readonly List<VmStorageControllerInfo> _currentStorage;
        private List<HostDiskInfo> _cachedHostDisks = new();
        private bool _isInternalUpdating = false;

        public AddDiskViewModel(string vmName, int generation, bool isVmRunning, List<VmStorageControllerInfo> currentStorage)
        {
            _storageService = new StorageService();
            _vmName = vmName;
            _vmGeneration = generation;
            _isVmRunning = isVmRunning;
            _currentStorage = currentStorage ?? new List<VmStorageControllerInfo>();

            AvailableControllerTypes = new ObservableCollection<string>();
            AvailableControllerNumbers = new ObservableCollection<int>();
            AvailableLocations = new ObservableCollection<int>();

            _ = InitialLoadAsync();
        }

        private async Task InitialLoadAsync()
        {
            await InitialDiskScanAsync();
            UpdateControllerTypeOptions();
            await RefreshControllerLayoutAsync(true);
        }

        public ObservableCollection<string> AvailableControllerTypes { get; }
        public ObservableCollection<int> AvailableControllerNumbers { get; }
        public ObservableCollection<int> AvailableLocations { get; }

        [ObservableProperty] private string _selectedControllerType = "SCSI";
        [ObservableProperty] private int _selectedControllerNumber = 0;
        [ObservableProperty] private int _selectedLocation = 0;
        [ObservableProperty] private bool _autoAssign = true;

        async partial void OnAutoAssignChanged(bool value) => await RefreshControllerLayoutAsync(value);

        async partial void OnSelectedControllerTypeChanged(string value)
        {
            if (_isInternalUpdating || string.IsNullOrEmpty(value)) return;
            await RefreshControllerLayoutAsync(AutoAssign);
        }

        async partial void OnSelectedControllerNumberChanged(int value)
        {
            if (_isInternalUpdating || value < 0) return;
            await RefreshControllerLayoutAsync(AutoAssign);
        }

        private void UpdateControllerTypeOptions()
        {
            _isInternalUpdating = true;
            AvailableControllerTypes.Clear();

            if (_vmGeneration == 2)
            {
                AvailableControllerTypes.Add("SCSI");
                SelectedControllerType = "SCSI";
            }
            else
            {
                if (DeviceType == "DvdDrive")
                {
                    AvailableControllerTypes.Add("IDE");
                    SelectedControllerType = "IDE";
                }
                else
                {
                    if (_isVmRunning)
                    {
                        AvailableControllerTypes.Add("SCSI");
                        SelectedControllerType = "SCSI";
                    }
                    else
                    {
                        AvailableControllerTypes.Add("IDE");
                        AvailableControllerTypes.Add("SCSI");
                        SelectedControllerType = "IDE";
                    }
                }
            }
            _isInternalUpdating = false;
        }

        private async Task RefreshControllerLayoutAsync(bool useAutoAssign)
        {
            if (_isInternalUpdating) return;
            _isInternalUpdating = true;

            try
            {
                string targetType = SelectedControllerType;
                int targetNumber = SelectedControllerNumber;
                int targetLocation = SelectedLocation;

                if (useAutoAssign)
                {
                    var bestSlot = FindFirstAvailableSlot();
                    targetType = bestSlot.Type;
                    targetNumber = bestSlot.Number;
                    targetLocation = bestSlot.Location;
                }

                if (targetType == "IDE")
                {
                    if (AvailableControllerNumbers.Count != 2)
                    {
                        AvailableControllerNumbers.Clear();
                        AvailableControllerNumbers.Add(0);
                        AvailableControllerNumbers.Add(1);
                    }
                }
                else
                {
                    var existingScsiNums = _currentStorage
                        .Where(c => c.ControllerType == "SCSI")
                        .Select(c => c.ControllerNumber)
                        .OrderBy(n => n).ToList();

                    if (_isVmRunning)
                    {
                        AvailableControllerNumbers.Clear();
                        foreach (var n in existingScsiNums) AvailableControllerNumbers.Add(n);
                        if (AvailableControllerNumbers.Count == 0) AvailableControllerNumbers.Add(0);
                    }
                    else
                    {
                        if (AvailableControllerNumbers.Count != 4 || AvailableControllerNumbers.Max() < 3)
                        {
                            AvailableControllerNumbers.Clear();
                            for (int i = 0; i < 4; i++) AvailableControllerNumbers.Add(i);
                        }
                    }
                }

                int maxSlots = (targetType == "IDE") ? 2 : 64;
                var occupied = _currentStorage
                    .Where(c => c.ControllerType == targetType && c.ControllerNumber == targetNumber)
                    .SelectMany(c => c.AttachedDrives)
                    .Select(d => d.ControllerLocation).ToList();

                var validLocations = new List<int>();
                for (int i = 0; i < maxSlots; i++)
                {
                    if (useAutoAssign || !occupied.Contains(i) || i == targetLocation)
                        validLocations.Add(i);
                }

                if (!AvailableLocations.SequenceEqual(validLocations))
                {
                    AvailableLocations.Clear();
                    foreach (var loc in validLocations) AvailableLocations.Add(loc);
                }

                SelectedControllerType = targetType;
                SelectedControllerNumber = AvailableControllerNumbers.Contains(targetNumber) ? targetNumber : AvailableControllerNumbers.FirstOrDefault();
                SelectedLocation = AvailableLocations.Contains(targetLocation) ? targetLocation : AvailableLocations.FirstOrDefault();

                OnPropertyChanged(nameof(SelectedControllerNumber));
                OnPropertyChanged(nameof(SelectedLocation));
            }
            finally { _isInternalUpdating = false; }
            ConfirmCommand.NotifyCanExecuteChanged();
        }
        private (string Type, int Number, int Location) FindFirstAvailableSlot()
        {
            var usedSlots = _currentStorage.SelectMany(c =>
                c.AttachedDrives.Select(d => $"{c.ControllerType}-{c.ControllerNumber}-{d.ControllerLocation}")
            ).ToHashSet();

            if (_vmGeneration == 1)
            {
                if (DeviceType == "DvdDrive" || !_isVmRunning)
                {
                    for (int n = 0; n < 2; n++)
                        for (int l = 0; l < 2; l++)
                            if (!usedSlots.Contains($"IDE-{n}-{l}")) return ("IDE", n, l);
                }
                if (DeviceType == "DvdDrive")
                {
                    return ("IDE", 0, 0);
                }
            }

            if (_isVmRunning)
            {
                var existingScsiNums = _currentStorage
                    .Where(c => c.ControllerType == "SCSI")
                    .Select(c => c.ControllerNumber)
                    .OrderBy(n => n).ToList();

                if (existingScsiNums.Count == 0) existingScsiNums.Add(0);

                foreach (var n in existingScsiNums)
                {
                    for (int l = 0; l < 64; l++)
                    {
                        if (!usedSlots.Contains($"SCSI-{n}-{l}")) return ("SCSI", n, l);
                    }
                }
            }
            else
            {
                for (int n = 0; n < 4; n++)
                {
                    for (int l = 0; l < 64; l++)
                    {
                        if (!usedSlots.Contains($"SCSI-{n}-{l}")) return ("SCSI", n, l);
                    }
                }
            }

            return ("SCSI", 0, 0);
        }

        [ObservableProperty][NotifyCanExecuteChangedFor(nameof(ConfirmCommand))] private string _deviceType = "HardDisk";
        [ObservableProperty][NotifyCanExecuteChangedFor(nameof(ConfirmCommand))] private bool _isPhysicalSource = false;
        [ObservableProperty][NotifyCanExecuteChangedFor(nameof(ConfirmCommand))] private string _filePath = string.Empty;
        [ObservableProperty][NotifyCanExecuteChangedFor(nameof(ConfirmCommand))] private HostDiskInfo? _selectedPhysicalDisk;
        [ObservableProperty][NotifyCanExecuteChangedFor(nameof(ConfirmCommand))] private bool _isNewDisk = false;
        [ObservableProperty] private int _newDiskSize = 256;
        [ObservableProperty] private string _selectedVhdType = "Dynamic";
        [ObservableProperty] private string _parentPath = "";
        [ObservableProperty] private string _sectorFormat = "Default";
        [ObservableProperty] private string _blockSize = "Default";

        [ObservableProperty][NotifyCanExecuteChangedFor(nameof(ConfirmCommand))] private string _isoSourceFolderPath = string.Empty;
        [ObservableProperty] private string _isoVolumeLabel = string.Empty;

        public ObservableCollection<int> NewDiskSizePresets { get; } = new ObservableCollection<int> { 64, 128, 256, 512, 1024 };

        public string FilePathPlaceholder => IsNewDisk ? Properties.Resources.AddDisk_Placeholder_SavePath : Properties.Resources.AddDisk_Placeholder_FilePath;

        async partial void OnDeviceTypeChanged(string value)
        {
            if (value == "DvdDrive")
            {
            }
            else
            {
            }
            SyncHostDiskDisplay();
            UpdateControllerTypeOptions();
            await RefreshControllerLayoutAsync(AutoAssign);
            ConfirmCommand.NotifyCanExecuteChanged();
        }

        async partial void OnIsPhysicalSourceChanged(bool value)
        {
            if (value) IsNewDisk = false;
            SyncHostDiskDisplay();
            await RefreshControllerLayoutAsync(AutoAssign);
            ConfirmCommand.NotifyCanExecuteChanged();
        }

        async partial void OnParentPathChanged(string value)
        {
            if (!string.IsNullOrEmpty(value) && System.IO.File.Exists(value))
            {
                var size = await _storageService.GetVhdSizeGbAsync(value);
                if (size > 0) NewDiskSize = (int)Math.Ceiling(size);
            }
        }

        partial void OnIsNewDiskChanged(bool value)
        {
            if (!value) ParentPath = string.Empty;
            OnPropertyChanged(nameof(FilePathPlaceholder));
            ConfirmCommand.NotifyCanExecuteChanged();
        }

        public ObservableCollection<HostDiskInfo> HostDisks { get; } = new();

        private async Task InitialDiskScanAsync()
        {
            try
            {
                var disks = await _storageService.GetHostDisksAsync();
                _cachedHostDisks = disks.ToList();
                SyncHostDiskDisplay();
            }
            catch { }
        }

        private void SyncHostDiskDisplay()
        {
            HostDisks.Clear();
            if (IsPhysicalSource && DeviceType == "HardDisk")
                foreach (var disk in _cachedHostDisks) HostDisks.Add(disk);
        }

        [RelayCommand]
        private void BrowseFile()
        {
            Microsoft.Win32.FileDialog dialog = IsNewDisk ? (Microsoft.Win32.FileDialog)new Microsoft.Win32.SaveFileDialog() : new Microsoft.Win32.OpenFileDialog();
            dialog.Filter = DeviceType == "HardDisk" ? $"{Properties.Resources.AddDisk_Filter_VirtualDisk}|*.vhdx;*.vhd" : $"{Properties.Resources.AddDisk_Filter_OpticalImage}|*.iso";
            if (dialog.ShowDialog() == true) FilePath = dialog.FileName;
            ConfirmCommand.NotifyCanExecuteChanged();
        }

        [RelayCommand]
        private void BrowseParentFile()
        {
            var dialog = new Microsoft.Win32.OpenFileDialog { Title = Properties.Resources.AddDisk_Title_SelectParentDisk, Filter = $"{Properties.Resources.AddDisk_Filter_VirtualDisk}|*.vhdx;*.vhd" };
            if (dialog.ShowDialog() == true) ParentPath = dialog.FileName;
            ConfirmCommand.NotifyCanExecuteChanged();
        }

        [RelayCommand]
        private void BrowseFolder()
        {
            var dialog = new Microsoft.Win32.OpenFolderDialog
            {
                Title = Properties.Resources.AddDisk_Title_SelectSourceFolder,
                Multiselect = false
            };

            if (dialog.ShowDialog() == true)
            {
                IsoSourceFolderPath = dialog.FolderName;
                try
                {
                    var dirInfo = new System.IO.DirectoryInfo(dialog.FolderName);
                    IsoVolumeLabel = dirInfo.Name.ToUpper();
                }
                catch { }
            }
            ConfirmCommand.NotifyCanExecuteChanged();
        }

        [RelayCommand(CanExecute = nameof(CanConfirmAction))]
        private void Confirm(Window window)
        {
            if (window != null)
            {
                window.DialogResult = true;
                window.Close();
            }
        }

        private bool CanConfirmAction()
        {
            if (_vmGeneration == 1 && _isVmRunning && SelectedControllerType == "IDE") return false;
            if (_vmGeneration == 1 && DeviceType == "DvdDrive" && SelectedControllerType == "SCSI") return false;

            if (IsPhysicalSource) return SelectedPhysicalDisk != null;

            if (IsNewDisk && DeviceType == "DvdDrive")
            {
                return !string.IsNullOrEmpty(FilePath) && !string.IsNullOrEmpty(IsoSourceFolderPath);
            }

            return !string.IsNullOrEmpty(FilePath);
        }
    }
}

================================================================================
FILE: ViewModels\AddSwitchViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Models;

namespace ExHyperV.ViewModels
{
    public partial class AddSwitchViewModel : ObservableObject
    {
        private readonly IEnumerable<SwitchViewModel> _existingSwitches;
        private readonly IEnumerable<PhysicalAdapterInfo> _allPhysicalAdapters;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(IsNetworkAdapterSelectionEnabled))]
        private string _selectedSwitchType = "External";

        [ObservableProperty]
        private string _switchName = ExHyperV.Properties.Resources.AddSwitch_DefaultName_External;

        [ObservableProperty]
        private string? _selectedNetworkAdapter;

        [ObservableProperty]
        private string? _errorMessage;

        public ObservableCollection<string> AvailableNetworkAdapters { get; } = new();
        public bool IsNetworkAdapterSelectionEnabled => _selectedSwitchType == "External" || _selectedSwitchType == "NAT";
        public string ComboBoxPlaceholderText => AvailableNetworkAdapters.Any() ? ExHyperV.Properties.Resources.AddSwitch_Placeholder_SelectAdapter : ExHyperV.Properties.Resources.AddSwitch_Placeholder_NoAdaptersAvailable;

        public bool IsComboBoxEnabled => IsNetworkAdapterSelectionEnabled && AvailableNetworkAdapters.Any();


        public AddSwitchViewModel(IEnumerable<SwitchViewModel> existingSwitches, IEnumerable<PhysicalAdapterInfo> allPhysicalAdapters)
        {
            _existingSwitches = existingSwitches;
            _allPhysicalAdapters = allPhysicalAdapters;

            foreach (var adapter in _allPhysicalAdapters)
            {
                if (!_existingSwitches.Any(s => s.SelectedUpstreamAdapter == adapter.InterfaceDescription))
                {
                    AvailableNetworkAdapters.Add(adapter.InterfaceDescription);
                }
            }
            OnPropertyChanged(nameof(ComboBoxPlaceholderText));
            OnPropertyChanged(nameof(IsComboBoxEnabled));
        }

        partial void OnSelectedSwitchTypeChanged(string value)
        {
            SwitchName = value switch
            {
                "External" => ExHyperV.Properties.Resources.AddSwitch_DefaultName_External,
                "NAT" => ExHyperV.Properties.Resources.AddSwitch_DefaultName_NAT,
                "Internal" => ExHyperV.Properties.Resources.AddSwitch_DefaultName_Internal,
                _ => ExHyperV.Properties.Resources.AddSwitch_DefaultName_Generic
            };
        }

        public bool Validate()
        {
            ErrorMessage = null;
            if (string.IsNullOrWhiteSpace(SwitchName))
            {
                ErrorMessage = ExHyperV.Properties.Resources.AddSwitch_Validation_NameCannotBeEmpty;
                return false;
            }
            if (_existingSwitches.Any(s => s.SwitchName.Equals(SwitchName, System.StringComparison.OrdinalIgnoreCase)))
            {
                ErrorMessage = string.Format(Properties.Resources.AddSwitch_Validation_NameExists, SwitchName);
                return false;
            }
            if (IsNetworkAdapterSelectionEnabled && !AvailableNetworkAdapters.Any())
            {
                ErrorMessage = ExHyperV.Properties.Resources.AddSwitch_Validation_NoAdaptersForExternalOrNat;
                return false;
            }
            if (IsNetworkAdapterSelectionEnabled && string.IsNullOrEmpty(SelectedNetworkAdapter))
            {
                ErrorMessage = ExHyperV.Properties.Resources.AddSwitch_Validation_AdapterRequiredForExternalOrNat;
                return false;
            }
            if (_selectedSwitchType == "NAT")
            {
                if (_existingSwitches.Any(s => !s.IsDefaultSwitch && s.SelectedNetworkMode == "NAT"))
                {
                    ErrorMessage = ExHyperV.Properties.Resources.AddSwitch_Validation_OnlyOneNatAllowed;
                    return false;
                }
            }
            return true;
        }
    }
}

================================================================================
FILE: ViewModels\AssignedGpuViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;

namespace ExHyperV.ViewModels
{
    public partial class AssignedGpuViewModel : ObservableObject
    {
        public string AdapterId { get; set; }
        public string InstancePath { get; set; }
        public string ParentGpuName { get; set; }
        public string ParentGpuVendor { get; set; }
        public string ParentGpuManu { get; set; }
    }
}

================================================================================
FILE: ViewModels\CheckStatusViewModel.cs
================================================================================

﻿using System.Windows.Media;
using CommunityToolkit.Mvvm.ComponentModel;

namespace ExHyperV.ViewModels
{
    /// <summary>
    /// 表示单个环境检查项的ViewModel。
    /// </summary>
    public partial class CheckStatusViewModel : ObservableObject
    {
        [ObservableProperty]
        private bool _isChecking = true;

        [ObservableProperty]
        private string _statusText;

        [ObservableProperty]
        private bool? _isSuccess;

        public string IconGlyph => IsSuccess switch
        {
            true => "\uEC61",
            false => "\uEB90",
            _ => ""
        };

        public Brush IconColor => IsSuccess switch
        {
            true => new SolidColorBrush(Color.FromArgb(255, 0, 138, 23)),
            false => new SolidColorBrush(Colors.Red),
            _ => Brushes.Transparent
        };

        public CheckStatusViewModel(string initialText)
        {
            _statusText = initialText;
        }

        partial void OnIsSuccessChanged(bool? value)
        {
            OnPropertyChanged(nameof(IconGlyph));
            OnPropertyChanged(nameof(IconColor));
        }
    }
}

================================================================================
FILE: ViewModels\CpuAffinityDialogViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Models;
using ExHyperV.Services;
using System.Collections.ObjectModel;
using System.ComponentModel;

namespace ExHyperV.ViewModels.Dialogs
{
    public partial class CpuAffinityDialogViewModel : ObservableObject
    {
        [ObservableProperty]
        private int _columns;

        [ObservableProperty]
        private int _rows;

        [ObservableProperty]
        private string _statusText;

        [ObservableProperty]
        private string _statusEmoji;

        private readonly int _assignedCoreCount;
        public ObservableCollection<SelectableCoreViewModel> Cores { get; } = new();

        private readonly HyperVSchedulerType _schedulerType;
        private readonly Dictionary<int, int> _cpuSiblingMap;
        private bool _isUpdatingFromLogic = false;

        public CpuAffinityDialogViewModel(
            string vmName,
            int assignedCoreCount,
            ObservableCollection<UiCoreModel> hostCores,
            HyperVSchedulerType schedulerType,
            Dictionary<int, int> cpuSiblingMap)
        {
            _assignedCoreCount = assignedCoreCount;
            Columns = CalculateOptimalColumns(hostCores.Count);
            Rows = (hostCores.Count > 0) ? (int)Math.Ceiling((double)hostCores.Count / Columns) : 0;
            _schedulerType = schedulerType;
            _cpuSiblingMap = cpuSiblingMap;

            foreach (var core in hostCores.OrderBy(c => c.CoreId))
            {
                var selectableCore = new SelectableCoreViewModel();
                selectableCore.CoreId = core.CoreId;
                selectableCore.CoreType = core.CoreType;

                selectableCore.PropertyChanged += OnCoreSelectionChanged;
                Cores.Add(selectableCore);
            }

            UpdateStatusText();
        }

        private void OnCoreSelectionChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(SelectableCoreViewModel.IsSelected))
            {
                HandleSiblingSelection(sender as SelectableCoreViewModel);
                UpdateStatusText();
            }
        }

        private void HandleSiblingSelection(SelectableCoreViewModel changedCore)
        {
            if (changedCore == null || _isUpdatingFromLogic) return;

            if (_schedulerType == HyperVSchedulerType.Core)
            {
                if (_cpuSiblingMap.TryGetValue(changedCore.CoreId, out int siblingId))
                {
                    var siblingCoreViewModel = Cores.FirstOrDefault(c => c.CoreId == siblingId);
                    if (siblingCoreViewModel != null && siblingCoreViewModel.IsSelected != changedCore.IsSelected)
                    {
                        _isUpdatingFromLogic = true;
                        siblingCoreViewModel.IsSelected = changedCore.IsSelected;
                        _isUpdatingFromLogic = false;
                    }
                }
            }
        }
        private void UpdateStatusText()
        {
            int selectedCount = Cores.Count(c => c.IsSelected);

            string countStr = $"({selectedCount} / {_assignedCoreCount})";

            if (selectedCount == 0)
            {
                StatusEmoji = "🔄";
                StatusText = ExHyperV.Properties.Resources.SystemAutomaticallyScheduled;
            }
            else if (selectedCount < _assignedCoreCount)
            {
                StatusEmoji = "⚠️";
                StatusText = string.Format(ExHyperV.Properties.Resources.PerformanceLimited, countStr);
            }
            else if (selectedCount > _assignedCoreCount)
            {
                StatusEmoji = "💨";
                StatusText = string.Format(ExHyperV.Properties.Resources.RandomlyDriftWithinSelectedCoreGroup, countStr);
            }
            else
            {
                StatusEmoji = "🎯";
                StatusText = string.Format(ExHyperV.Properties.Resources.Perfect, countStr);
            }
        }

        private int CalculateOptimalColumns(int count)
        {
            if (count <= 1) return 1;
            if (count <= 3) return count;
            if (count == 4) return 2;
            if (count <= 6) return 3;
            if (count == 8) return 4;

            double sqrt = Math.Sqrt(count);
            if (sqrt == (int)sqrt) return (int)sqrt;

            int startingPoint = (int)sqrt;
            for (int i = startingPoint; i >= 2; i--)
            {
                if (count % i == 0) return count / i;
            }
            return (int)Math.Ceiling(sqrt);
        }
    }
}

================================================================================
FILE: ViewModels\CpuPageViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Management;
using System.Text.Json;
using System.Windows;
using System.Windows.Media;
using ExHyperV.Models;
using ExHyperV.Services;
using ExHyperV.Tools;
using ExHyperV.ViewModels.Dialogs;
using ExHyperV.Views.Dialogs;
using Wpf.Ui.Controls;

namespace ExHyperV.ViewModels
{
    internal class CoreUpdateDto
    {
        public string VmName { get; set; }
        public int CoreId { get; set; }
        public double Usage { get; set; }
        public PointCollection RenderedGraph { get; set; }
        public bool IsRunning { get; set; }
    }

    public partial class CpuPageViewModel : ObservableObject, IDisposable
    {
        public static CpuPageViewModel Instance { get; } = new CpuPageViewModel();

        private CpuMonitorService _cpuService;
        private CancellationTokenSource _monitoringCts;
        private Task _monitoringTask;
        private CancellationTokenSource _sleepTokenSource = new CancellationTokenSource();
        private const int MaxHistoryLength = 60;
        private readonly Dictionary<string, LinkedList<double>> _historyCache = new();
        private readonly IVmProcessorService _vmProcessorService;
        private readonly CpuAffinityService _cpuAffinityService;
        private VMProcessorViewModel _originalProcessorConfig;

        private string? _lockedTopologyVmName;
        private DateTime _lockedTopologyUntil;

        public List<int> PossibleVCpuCounts { get; }

        public ObservableCollection<UiVmModel> VmList { get; } = new ObservableCollection<UiVmModel>();

        [ObservableProperty]
        private UiVmModel? _selectedVm;

        [ObservableProperty]
        private bool _isRootSchedulerActive;

        async partial void OnSelectedVmChanged(UiVmModel? value)
        {
            if (value != null && value.Name != "Host")
            {
                await LoadVmProcessorSettingsAsync(value);
                _originalProcessorConfig = value.Processor.CreateCopy();
                value.Processor.InstantApplyAction = (propertyName) => HandleInstantApply(propertyName);
            }
            else
            {
                _originalProcessorConfig = null;
            }
        }

        [ObservableProperty]
        private int _refreshInterval = 1000; //默认刷新间隔

        [ObservableProperty]
        private bool _isLoading = true;

        private int _selectedSpeedIndex = 1;
        public int SelectedSpeedIndex
        {
            get => _selectedSpeedIndex;
            set { if (SetProperty(ref _selectedSpeedIndex, value)) { UpdateInterval(); WakeUpThread(); } }
        }

        private bool _systemInfoCached = false;
        private HyperVSchedulerType _cachedSchedulerType = HyperVSchedulerType.Unknown;
        private Dictionary<int, int> _cachedCpuSiblingMap = new Dictionary<int, int>();

        [ObservableProperty]
        private bool _isNumaSpanningEnabled = true;

        private bool _suppressNumaChange = false;

        async partial void OnIsNumaSpanningEnabledChanged(bool value)
        {
            if (_suppressNumaChange) return;
            if (SelectedVm == null || SelectedVm.Name != "Host") return;

            var (success, message) = await HyperVNUMAService.SetNumaSpanningEnabledAsync(value);

            if (success)
            {
                ShowSnackbar(ExHyperV.Properties.Resources.SettingsSavedSuccessfully, ExHyperV.Properties.Resources.NumaSettingsModifiedRestartRequired, ControlAppearance.Success, SymbolRegular.CheckmarkCircle24, 3);
            }
            else
            {
                _suppressNumaChange = true;
                IsNumaSpanningEnabled = !value;
                _suppressNumaChange = false;
                ShowSnackbar(ExHyperV.Properties.Resources.SettingFailed, message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
            }
        }

        public CpuPageViewModel()
        {
            SelectedSpeedIndex = 1;
            _cpuAffinityService = new CpuAffinityService();
            _vmProcessorService = new VmProcessorService();

            var options = new HashSet<int>();
            int maxCores = Environment.ProcessorCount;
            int current = 1;

            while (current <= maxCores)
            {
                options.Add(current);
                current *= 2;
            }
            options.Add(maxCores);

            PossibleVCpuCounts = options.OrderBy(x => x).ToList();
            StartMonitoring();
        }

        private int _selectedSchedulerIndex = -1;
        public int SelectedSchedulerIndex
        {
            get => _selectedSchedulerIndex;
            set
            {
                if (value == _selectedSchedulerIndex || !_systemInfoCached || value < 0)
                {
                    SetProperty(ref _selectedSchedulerIndex, value);
                    return;
                }

                SetProperty(ref _selectedSchedulerIndex, value);
                IsRootSchedulerActive = (value == 2);

                var newType = value switch
                {
                    0 => HyperVSchedulerType.Classic,
                    1 => HyperVSchedulerType.Core,
                    2 => HyperVSchedulerType.Root,
                    _ => HyperVSchedulerType.Unknown
                };

                if (newType != HyperVSchedulerType.Unknown)
                {
                    _ = Task.Run(async () =>
                    {
                        if (await HyperVSchedulerService.SetSchedulerTypeAsync(newType))
                        {
                            Application.Current.Dispatcher.Invoke(() =>
                            {
                                ShowSnackbar(ExHyperV.Properties.Resources.SettingsSavedSuccessfully, ExHyperV.Properties.Resources.SchedulerTypeChangedRestartRequired, ControlAppearance.Success, SymbolRegular.CheckmarkCircle24);
                            });
                        }
                    });
                }
            }
        }

        public void StartMonitoring()
        {
            if (_monitoringTask != null && !_monitoringTask.IsCompleted) return;
            _monitoringCts = new CancellationTokenSource();
            _monitoringTask = Task.Run(() => MonitorLoop(_monitoringCts.Token));
        }

        public async Task StopMonitoringAsync()
        {
            if (_monitoringCts != null && !_monitoringCts.IsCancellationRequested)
            {
                _monitoringCts.Cancel();
                WakeUpThread();
                if (_monitoringTask != null)
                {
                    try { await Task.WhenAny(_monitoringTask, Task.Delay(1000)); } catch { }
                }
                _monitoringCts.Dispose();
                _monitoringCts = null;
            }
        }

        private async void HandleInstantApply(string propertyName)
        {
            if (SelectedVm == null || SelectedVm.Name == "Host" || IsLoading) return;

            try
            {
                Debug.WriteLine($"即时应用: {propertyName} 属性已更改。");
                var (success, message) = await _vmProcessorService.SetVmProcessorAsync(SelectedVm.Name, SelectedVm.Processor);

                if (success)
                {
                    _originalProcessorConfig = SelectedVm.Processor.CreateCopy();
                }
                else
                {
                    ShowSnackbar(ExHyperV.Properties.Resources.SettingFailed, message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
                    if (_originalProcessorConfig != null)
                    {
                        SelectedVm.Processor.Restore(_originalProcessorConfig);
                    }
                }
            }
            catch (Exception ex)
            {
                ShowSnackbar(ExHyperV.Properties.Resources.UnknownError, string.Format(ExHyperV.Properties.Resources.UnexpectedErrorOccurred, ex.Message), ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
                if (_originalProcessorConfig != null)
                {
                    SelectedVm.Processor.Restore(_originalProcessorConfig);
                }
            }
        }

        private void UpdateInterval()
        {
            RefreshInterval = SelectedSpeedIndex switch
            {
                0 => 500,
                1 => 1000,
                2 => 2000,
                3 => -1,
                _ => 1000
            };
        }

        private void WakeUpThread()
        {
            _sleepTokenSource?.Cancel();
        }

        private async Task MonitorLoop(CancellationToken token)
        {
            try
            {
                _cpuService = new CpuMonitorService();
                Application.Current.Dispatcher.Invoke(() => IsLoading = false);
            }
            catch { Application.Current.Dispatcher.Invoke(() => IsLoading = false); return; }

            while (!token.IsCancellationRequested)
            {
                try
                {
                    if (_sleepTokenSource.IsCancellationRequested) { _sleepTokenSource.Dispose(); _sleepTokenSource = new CancellationTokenSource(); }
                    if (RefreshInterval == -1)
                    {
                        await Task.Delay(Timeout.Infinite, CancellationTokenSource.CreateLinkedTokenSource(token, _sleepTokenSource.Token).Token);
                        continue;
                    }
                    var startTime = DateTime.Now;
                    var rawData = _cpuService.GetCpuUsage();
                    var updates = ProcessData(rawData);
                    if (token.IsCancellationRequested) break;
                    Application.Current.Dispatcher.Invoke(() => ApplyUpdates(updates));
                    var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
                    var delay = RefreshInterval - (int)elapsed;
                    if (delay < 100) delay = 100;
                    await Task.Delay(delay, CancellationTokenSource.CreateLinkedTokenSource(token, _sleepTokenSource.Token).Token);
                }
                catch (TaskCanceledException) { if (token.IsCancellationRequested) break; }
                catch (Exception) { if (token.IsCancellationRequested) break; await Task.Delay(5000, token); }
            }
            _cpuService?.Dispose();
            _cpuService = null;
        }

        private List<CoreUpdateDto> ProcessData(List<CpuCoreMetric> rawData)
        {
            var updates = new List<CoreUpdateDto>();
            foreach (var metric in rawData)
            {
                if (metric.IsRunning)
                {
                    var key = $"{metric.VmName}_{metric.CoreId}";
                    if (!_historyCache.TryGetValue(key, out var history))
                    {
                        history = new LinkedList<double>();
                        for (int k = 0; k < MaxHistoryLength; k++) history.AddLast(0);
                        _historyCache[key] = history;
                    }
                    history.AddLast(metric.Usage);
                    if (history.Count > MaxHistoryLength) history.RemoveFirst();
                    var points = CalculatePoints(history);
                    points.Freeze();
                    updates.Add(new CoreUpdateDto { VmName = metric.VmName, CoreId = metric.CoreId, Usage = metric.Usage, RenderedGraph = points, IsRunning = true });
                }
                else
                {
                    updates.Add(new CoreUpdateDto { VmName = metric.VmName, CoreId = metric.CoreId, IsRunning = false });
                }
            }
            return updates;
        }

        private PointCollection CalculatePoints(LinkedList<double> history)
        {
            double w = 100.0; double h = 100.0; double step = w / (MaxHistoryLength - 1);
            var points = new PointCollection(MaxHistoryLength + 2);
            points.Add(new Point(0, h));
            int i = 0;
            foreach (var val in history)
            {
                double x = i * step;
                double y = h - (val * h / 100.0);
                points.Add(new Point(x, y));
                i++;
            }
            points.Add(new Point(w, h));
            return points;
        }

        private void ApplyUpdates(List<CoreUpdateDto> updates)
        {
            if (_monitoringCts == null || _monitoringCts.IsCancellationRequested) return;

            var activeVmNames = updates.Select(x => x.VmName).ToHashSet();
            var vmsToRemove = VmList.Where(vm => !activeVmNames.Contains(vm.Name)).ToList();
            foreach (var vm in vmsToRemove) VmList.Remove(vm);

            var groupedByVm = updates.GroupBy(x => x.VmName);
            foreach (var group in groupedByVm)
            {
                var vmName = group.Key;
                var uiVm = VmList.FirstOrDefault(v => v.Name == vmName);
                if (uiVm == null)
                {
                    uiVm = new UiVmModel { Name = vmName };
                    if (vmName != "Host")
                    {
                        uiVm.Processor.Count = group.Count();
                        uiVm.Processor.RelativeWeight = 100;
                        uiVm.Processor.Reserve = 0;
                        uiVm.Processor.Maximum = 100;
                        uiVm.Processor.SmtMode = SmtMode.Inherit;
                        uiVm.Processor.EnableHostResourceProtection = false;
                    }
                    VmList.Add(uiVm);
                }

                uiVm.IsRunning = group.Any(u => u.IsRunning);
                uiVm.AverageUsage = uiVm.IsRunning ? group.Average(u => u.Usage) : 0;

                bool isTopologyLocked = (vmName == _lockedTopologyVmName && DateTime.Now < _lockedTopologyUntil);

                if (!isTopologyLocked)
                {
                    var updatedCoreIds = group.Select(u => u.CoreId).ToHashSet();
                    var coresToRemove = uiVm.Cores.Where(c => !updatedCoreIds.Contains(c.CoreId)).ToList();
                    foreach (var core in coresToRemove) uiVm.Cores.Remove(core);
                }

                foreach (var update in group)
                {
                    var uiCore = uiVm.Cores.FirstOrDefault(c => c.CoreId == update.CoreId);
                    if (uiCore == null)
                    {
                        if (isTopologyLocked) continue;

                        var serviceCoreType = vmName.Equals("Host", StringComparison.OrdinalIgnoreCase)
                            ? CpuMonitorService.GetCoreType(update.CoreId)
                            : Services.CoreType.Unknown;

                        Models.CoreType modelCoreType = serviceCoreType switch
                        {
                            Services.CoreType.Performance => Models.CoreType.Performance,
                            Services.CoreType.Efficient => Models.CoreType.Efficient,
                            _ => Models.CoreType.Unknown
                        };

                        uiCore = new UiCoreModel { CoreId = update.CoreId, CoreType = modelCoreType };
                        uiVm.Cores.Add(uiCore);
                    }

                    if (uiCore != null)
                    {
                        uiCore.Usage = update.Usage;
                        uiCore.HistoryPoints = update.RenderedGraph;
                    }
                }

                if (!isTopologyLocked)
                {
                    var sortedCores = uiVm.Cores.OrderBy(c => c.CoreId).ToList();
                    for (int i = 0; i < sortedCores.Count; i++)
                    {
                        var desiredCore = sortedCores[i];
                        int currentIndex = uiVm.Cores.IndexOf(desiredCore);
                        if (currentIndex != i)
                        {
                            uiVm.Cores.Move(currentIndex, i);
                        }
                    }

                    uiVm.Columns = CalculateOptimalColumns(uiVm.Cores.Count);
                    uiVm.Rows = (uiVm.Cores.Count > 0) ? (int)Math.Ceiling((double)uiVm.Cores.Count / uiVm.Columns) : 0;
                }
            }

            var hostVm = VmList.FirstOrDefault(vm => vm.Name.Equals("Host", StringComparison.OrdinalIgnoreCase));
            if (!_systemInfoCached && hostVm != null && hostVm.Cores.Any())
            {
                _cachedSchedulerType = HyperVSchedulerService.GetSchedulerType();
                _cachedCpuSiblingMap = CpuTopologyService.GetCpuSiblingMap();

                Task.Run(async () =>
                {
                    var numaEnabled = await HyperVNUMAService.GetNumaSpanningEnabledAsync();
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        _suppressNumaChange = true;
                        IsNumaSpanningEnabled = numaEnabled;
                        _suppressNumaChange = false;
                    });
                });

                _systemInfoCached = true;

                var initialIndex = _cachedSchedulerType switch
                {
                    HyperVSchedulerType.Classic => 0,
                    HyperVSchedulerType.Core => 1,
                    HyperVSchedulerType.Root => 2,
                    _ => -1
                };
                _selectedSchedulerIndex = initialIndex;
                IsRootSchedulerActive = (initialIndex == 2);
                OnPropertyChanged(nameof(SelectedSchedulerIndex));
            }

            if (SelectedVm == null)
            {
                SelectedVm = VmList.FirstOrDefault(vm => vm.Name == "Host") ?? VmList.FirstOrDefault();
            }

            var sortedVms = VmList
                .OrderBy(vm => vm.Name != "Host")
                .ThenBy(vm => !vm.IsRunning)
                .ThenBy(vm => vm.Name)
                .ToList();
            for (int i = 0; i < sortedVms.Count; i++)
            {
                var desiredVm = sortedVms[i];
                if (VmList.IndexOf(desiredVm) != i) VmList.Move(VmList.IndexOf(desiredVm), i);
            }
        }

        private int CalculateOptimalColumns(int count)
        {
            if (count <= 1) return 1; if (count <= 3) return count; if (count == 4) return 2; if (count <= 6) return 3; if (count == 8) return 4;
            double sqrt = Math.Sqrt(count);
            if (sqrt == (int)sqrt) return (int)sqrt;
            int startingPoint = (int)sqrt;
            for (int i = startingPoint; i >= 2; i--) { if (count % i == 0) return count / i; }
            return (int)Math.Ceiling(sqrt);
        }

        private async Task LoadVmProcessorSettingsAsync(UiVmModel vm)
        {
            try
            {
                var processorSettings = await _vmProcessorService.GetVmProcessorAsync(vm.Name);
                if (processorSettings != null)
                {
                    vm.Processor.Count = processorSettings.Count;
                    vm.Processor.Reserve = processorSettings.Reserve;
                    vm.Processor.Maximum = processorSettings.Maximum;
                    vm.Processor.RelativeWeight = processorSettings.RelativeWeight;
                    vm.Processor.ExposeVirtualizationExtensions = processorSettings.ExposeVirtualizationExtensions;
                    vm.Processor.EnableHostResourceProtection = processorSettings.EnableHostResourceProtection;
                    vm.Processor.CompatibilityForMigrationEnabled = processorSettings.CompatibilityForMigrationEnabled;
                    vm.Processor.CompatibilityForOlderOperatingSystemsEnabled = processorSettings.CompatibilityForOlderOperatingSystemsEnabled;
                    vm.Processor.SmtMode = processorSettings.SmtMode;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"加载虚拟机 {vm.Name} 的处理器配置失败: {ex.Message}");
            }
        }

        [RelayCommand]
        private async Task OpenVmCpuAffinityAsync()
        {
            if (SelectedVm == null || SelectedVm.Name.Equals("Host", StringComparison.OrdinalIgnoreCase)) return;
            var hostVm = VmList.FirstOrDefault(vm => vm.Name.Equals("Host", StringComparison.OrdinalIgnoreCase));
            if (hostVm == null || hostVm.Cores.Count == 0) return;

            if (_cachedSchedulerType == HyperVSchedulerType.Root)
            {
                if (!SelectedVm.IsRunning)
                {
                    ShowSnackbar(ExHyperV.Properties.Resources.Dialog_Title_OperationFailed, ExHyperV.Properties.Resources.CannotSetCpuPinningWithRootSchedulerAndVmOff, ControlAppearance.Caution, SymbolRegular.Warning24);
                    return;
                }

                IsLoading = true;
                try
                {
                    var (vmId, currentAffinity) = await Task.Run(() =>
                    {
                        var id = GetVmGuidByName(SelectedVm.Name);
                        var affinity = (id != Guid.Empty) ? ProcessAffinityManager.GetVmProcessAffinity(id) : new List<int>();
                        return (id, affinity);
                    });

                    if (vmId == Guid.Empty)
                    {
                        ShowSnackbar(ExHyperV.Properties.Resources.error,ExHyperV.Properties.Resources.VmProcessNotFound, ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
                        return;
                    }

                    var dialogViewModel = new CpuAffinityDialogViewModel(SelectedVm.Name, SelectedVm.Cores.Count, hostVm.Cores, _cachedSchedulerType, _cachedCpuSiblingMap);
                    foreach (var coreVm in dialogViewModel.Cores)
                    {
                        if (currentAffinity.Contains(coreVm.CoreId))
                        {
                            coreVm.IsSelected = true;
                        }
                    }

                    var dialog = new CpuAffinityDialog { DataContext = dialogViewModel, Owner = Application.Current.MainWindow };
                    if (dialog.ShowDialog() == true)
                    {
                        var selectedCoreIds = dialogViewModel.Cores.Where(c => c.IsSelected).Select(c => c.CoreId).ToList();
                        await Task.Run(() => ProcessAffinityManager.SetVmProcessAffinity(vmId, selectedCoreIds));
                    }
                }
                finally
                {
                    IsLoading = false;
                }
            }
            else
            {
                var vmId = GetVmGuidByName(SelectedVm.Name);
                if (vmId == Guid.Empty) return;

                var dialogViewModel = new CpuAffinityDialogViewModel(SelectedVm.Name, SelectedVm.Cores.Count, hostVm.Cores, _cachedSchedulerType, _cachedCpuSiblingMap);

                try
                {
                    string vmGroupJson = await Task.Run(() => HcsManager.GetVmCpuGroupAsJson(vmId));
                    if (!string.IsNullOrEmpty(vmGroupJson))
                    {
                        var vmGroupInfo = JsonSerializer.Deserialize<VmCpuGroupInfo>(vmGroupJson);
                        if (vmGroupInfo?.CpuGroupId != Guid.Empty)
                        {
                            var groupDetails = await _cpuAffinityService.GetCpuGroupDetailsAsync(vmGroupInfo.CpuGroupId);
                            if (groupDetails?.Affinity?.LogicalProcessors != null)
                            {
                                foreach (var coreVM in dialogViewModel.Cores)
                                {
                                    if (groupDetails.Affinity.LogicalProcessors.Contains((uint)coreVM.CoreId))
                                    {
                                        coreVM.IsSelected = true;
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"查询虚拟机当前CPU组失败: {ex.Message}");
                }

                var dialog = new CpuAffinityDialog { DataContext = dialogViewModel, Owner = Application.Current.MainWindow };
                if (dialog.ShowDialog() == true)
                {
                    var selectedCoreIds = dialogViewModel.Cores.Where(c => c.IsSelected).Select(c => c.CoreId).ToList();
                    await Task.Run(() => HcsManager.SetVmCpuGroup(vmId, Guid.Empty));
                    if (selectedCoreIds.Any())
                    {
                        Guid cpuGroupId = await _cpuAffinityService.FindOrCreateCpuGroupAsync(selectedCoreIds);
                        await Task.Run(() => HcsManager.SetVmCpuGroup(vmId, cpuGroupId));
                    }
                }
            }
        }


        [RelayCommand]
        private async Task ApplyChangesAsync()
        {
            if (SelectedVm == null || SelectedVm.Name == "Host" || IsLoading) return;

            var (success, message) = await _vmProcessorService.SetVmProcessorAsync(SelectedVm.Name, SelectedVm.Processor);

            if (success)
            {
                _originalProcessorConfig = SelectedVm.Processor.CreateCopy();
                UpdateCoresImmediately();
                _lockedTopologyVmName = SelectedVm.Name;
                _lockedTopologyUntil = DateTime.Now.AddSeconds(5);
                ShowSnackbar(ExHyperV.Properties.Resources.OperationSucceeded, message, ControlAppearance.Success, SymbolRegular.CheckmarkCircle24, 1.5);
            }
            else
            {
                ShowSnackbar(ExHyperV.Properties.Resources.Dialog_Title_OperationFailed, message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
            }
        }

        private void UpdateCoresImmediately()
        {
            if (SelectedVm == null) return;

            int targetCount = (int)SelectedVm.Processor.Count;
            var currentCores = SelectedVm.Cores;

            while (currentCores.Count > targetCount)
            {
                currentCores.RemoveAt(currentCores.Count - 1);
            }

            while (currentCores.Count < targetCount)
            {
                int newId = currentCores.Count;
                currentCores.Add(new UiCoreModel
                {
                    CoreId = newId,
                    CoreType = Models.CoreType.Unknown,
                    Usage = 0,
                    HistoryPoints = null
                });
            }

            SelectedVm.Columns = CalculateOptimalColumns(currentCores.Count);
            SelectedVm.Rows = (currentCores.Count > 0) ? (int)Math.Ceiling((double)currentCores.Count / SelectedVm.Columns) : 0;
        }

        [RelayCommand]
        private void OpenNumaSettings()
        {
        }

        private void ShowSnackbar(string title, string message, ControlAppearance appearance, SymbolRegular icon, double seconds = 2)
        {
            var mainWindow = Application.Current.MainWindow as MainWindow;
            if (mainWindow != null)
            {
                var snackbar = new Snackbar(mainWindow.SnackbarPresenter)
                {
                    Title = title,
                    Content = message,
                    Appearance = appearance,
                    Icon = new SymbolIcon(icon) { FontSize = 32 },
                    Timeout = TimeSpan.FromSeconds(seconds),
                    Padding = new Thickness(12, 4, 12, 4)
                };

                snackbar.Show();
            }
        }
        private Guid GetVmGuidByName(string vmName)
        {
            try
            {
                string query = $"SELECT * FROM Msvm_ComputerSystem WHERE ElementName = '{vmName}'";
                using (var searcher = new ManagementObjectSearcher("root\\virtualization\\v2", query))
                {
                    var vmObject = searcher.Get().Cast<ManagementObject>().FirstOrDefault();
                    if (vmObject != null && Guid.TryParse((string)vmObject["Name"], out Guid vmId))
                    {
                        return vmId;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"GetVmGuidByName for '{vmName}' failed: {ex.Message}");
            }
            return Guid.Empty;
        }

        public async void Dispose()
        {
            await StopMonitoringAsync();
            _cpuService?.Dispose();
        }
    }
}

================================================================================
FILE: ViewModels\DDAPageViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Controls;
using System.Xml.Linq;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Properties;
using ExHyperV.Services;
using Wpf.Ui.Controls;
using MessageBox = Wpf.Ui.Controls.MessageBox;
using TextBlock = Wpf.Ui.Controls.TextBlock;

namespace ExHyperV.ViewModels
{
    /// <summary>
    /// DDAPage页面的ViewModel，负责管理DDA设备数据和用户交互逻辑。
    /// </summary>
    public partial class DDAPageViewModel : ObservableObject
    {
        private readonly IHyperVService _hyperVService;

        [ObservableProperty]
        private bool _isLoading;

        [ObservableProperty]
        private bool _showServerError;

        [ObservableProperty]
        private bool _isUiEnabled = true;

        public ObservableCollection<DeviceViewModel> Devices { get; }
        public IAsyncRelayCommand LoadDataCommand { get; }
        public IAsyncRelayCommand<object> ChangeAssignmentCommand { get; }

        public DDAPageViewModel()
        {
            _hyperVService = new DDAService();
            Devices = new ObservableCollection<DeviceViewModel>();
            LoadDataCommand = new AsyncRelayCommand(LoadDataAsync);
            ChangeAssignmentCommand = new AsyncRelayCommand<object>(ChangeAssignmentAsync);
            LoadDataCommand.Execute(null);
        }

        private async Task LoadDataAsync()
        {
            if (System.ComponentModel.DesignerProperties.GetIsInDesignMode(new System.Windows.DependencyObject()))
            {
                IsLoading = false;
                IsUiEnabled = true;
                return;
            }

            IsUiEnabled = false;
            IsLoading = true;
            try
            {
                var serverCheckTask = _hyperVService.IsServerOperatingSystemAsync();
                var ddaInfoTask = _hyperVService.GetDdaInfoAsync();
                await Task.WhenAll(serverCheckTask, ddaInfoTask);

                Devices.Clear();

                ShowServerError = !await serverCheckTask;
                var (devices, vmNames) = await ddaInfoTask;

                if (devices != null)
                {
                    foreach (var deviceInfo in devices)
                    {
                        Devices.Add(new DeviceViewModel(deviceInfo, vmNames));
                    }
                }
            }
            finally
            {
                IsLoading = false;
                IsUiEnabled = true;
            }
        }

        private async Task ChangeAssignmentAsync(object parameter)
        {
            if (parameter is not object[] parameters || parameters.Length < 2 ||
                parameters[0] is not DeviceViewModel deviceViewModel ||
                parameters[1] is not string selectedTarget)
            {
                return;
            }

            if (deviceViewModel.Status == selectedTarget) return;

            IsUiEnabled = false;

            // MMIO空间检查流程
            if (selectedTarget != Resources.Host)
            {
                bool canProceed = await HandleMmioCheckAsync(selectedTarget);
                if (!canProceed)
                {
                    IsUiEnabled = true;
                    return;
                }
            }

            // DDA设备分配流程
            await PerformDdaAssignmentAsync(deviceViewModel, selectedTarget);

            // 最终刷新
            await LoadDataCommand.ExecuteAsync(null);
        }

        /// <summary>
        /// 管理MMIO空间检查和用户确认流程。
        /// </summary>
        private async Task<bool> HandleMmioCheckAsync(string targetVmName)
        {
            var (resultType, message) = await _hyperVService.CheckMmioSpaceAsync(targetVmName);

            if (resultType == MmioCheckResultType.NeedsConfirmation)
            {
                var confirmDialog = new ContentDialog
                {
                    Title = ExHyperV.Properties.Resources.DdaPage_Title_MmioSpaceTooSmall,
                    Content = message,
                    PrimaryButtonText = ExHyperV.Properties.Resources.Button_Yes,
                    CloseButtonText = ExHyperV.Properties.Resources.Button_No,
                    DialogHost = ((MainWindow)Application.Current.MainWindow).ContentPresenterForDialogs
                };
                var result = await confirmDialog.ShowAsync();
                if (result != ContentDialogResult.Primary) return false;

                var shutdownDialog = new ContentDialog
                {
                    Title = ExHyperV.Properties.Resources.Dialog_Title_PleaseWait,
                    Content = new TextBlock { Text = string.Format(ExHyperV.Properties.Resources.DdaPage_Status_ShuttingDownVm, targetVmName), HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center },
                    DialogHost = ((MainWindow)Application.Current.MainWindow).ContentPresenterForDialogs,
                };
                var shutdownDialogTask = shutdownDialog.ShowAsync();
                bool updateSuccess = await _hyperVService.UpdateMmioSpaceAsync(targetVmName);
                shutdownDialog.Hide();
                await shutdownDialogTask;

                if (!updateSuccess)
                {
                    var errorDialog = new MessageBox { Title = Properties.Resources.error, Content = Resources.DdaPage_Error_UpdateMmioFailed, CloseButtonText = Resources.sure };
                    await errorDialog.ShowDialogAsync();
                    await LoadDataCommand.ExecuteAsync(null);
                    return false;
                }
            }
            else if (resultType == MmioCheckResultType.Error)
            {
                var errorDialog = new MessageBox { Title = Resources.error, Content = ExHyperV.Properties.Resources.DdaPage_Error_CheckMmioGeneric, CloseButtonText = Resources.sure };
                await errorDialog.ShowDialogAsync();
                return false;
            }

            return true;
        }

        /// <summary>
        /// 执行DDA分配并显示一个等待对话框。
        /// </summary>
        /// <summary>
        /// 执行DDA分配并显示一个可以报告详细进度的等待对话框。
        /// </summary>
        private async Task PerformDdaAssignmentAsync(DeviceViewModel device, string target)
        {
            var statusTextBlock = new TextBlock
            {
                Text = "", // 初始文本
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center
            };
            var waitDialog = new ContentDialog
            {
                Title = Resources.setting,
                Content = statusTextBlock,
                DialogHost = ((MainWindow)Application.Current.MainWindow).ContentPresenterForDialogs,
                CloseButtonText = ExHyperV.Properties.Resources.Close
            };
            bool isOperationInProgress = true;

            waitDialog.Closing += (sender, args) =>
            {
                if (isOperationInProgress)
                {
                    args.Cancel = true;
                }
            };

            var progressReporter = new Progress<string>(message =>
            {
                statusTextBlock.Text = message;
            });
            var dialogTask = waitDialog.ShowAsync();
            var (success, errorMessage) = await _hyperVService.ExecuteDdaOperationAsync(
                target,
                device.Status,
                device.InstanceId,
                device.Path,
                progressReporter 
            );
            isOperationInProgress = false;
            if (success)
            {
                waitDialog.Hide();
            }
            else
            {
                waitDialog.Title = ExHyperV.Properties.Resources.Dialog_Title_OperationFailed;
                waitDialog.Content = new ScrollViewer
                {
                    Content = new TextBlock
                    {
                        Text = string.Format(Properties.Resources.DdaPage_Error_ExecutionGeneric, errorMessage ?? Properties.Resources.Error_Unknown),
                        TextWrapping = TextWrapping.Wrap
                    }
                };
            }
            await dialogTask;
        }
    }
}

================================================================================
FILE: ViewModels\DeviceViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Models;
using ExHyperV.Properties;
using ExHyperV.Tools;

namespace ExHyperV.ViewModels
{
    public partial class DeviceViewModel : ObservableObject
    {
        private readonly DeviceInfo _device;
        public List<string> AssignmentOptions { get; }
        public DeviceViewModel(DeviceInfo device, List<string> allVmNames)
        {
            _device = device;
            IconGlyph = Utils.GetIconPath(device.ClassType, device.FriendlyName);
            AssignmentOptions = new List<string> { Resources.Host }; // 1. 首先添加“主机”
            if (allVmNames != null)
            {
                AssignmentOptions.AddRange(allVmNames); // 2. 然后添加所有虚拟机名称
            }
        }
        public string FriendlyName => _device.FriendlyName;
        public string ClassType => _device.ClassType;
        public string InstanceId => _device.InstanceId;
        public string Path => _device.Path;
        public string Vendor => _device.Vendor;
        public string Status
        {
            get => _device.Status;
            set => SetProperty(_device.Status, value, _device, (d, v) => d.Status = v);
        }
        public string IconGlyph { get; }
    }
}

================================================================================
FILE: ViewModels\GPUPageViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Media;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Services;
using ExHyperV.Tools;
using ExHyperV.Views;
using Wpf.Ui;
using Wpf.Ui.Controls;



namespace ExHyperV.ViewModels
{
    public partial class GPUPageViewModel : ObservableObject
    {
        private readonly IGpuPartitionService _gpuService;
        private readonly SshService _sshService;

        [ObservableProperty]
        private bool _isLoading;

        public ObservableCollection<HostGpuViewModel> HostGpus { get; } = new();
        public ObservableCollection<VirtualMachineViewModel> VirtualMachines { get; } = new();

        public GPUPageViewModel()
        {
            _gpuService = new GpuPartitionService();
            _sshService = new SshService();
            _ = LoadDataCommand.ExecuteAsync(null);
        }

        [RelayCommand]
        private async Task LoadDataAsync()
        {
            if (IsLoading) return;
            IsLoading = true;
            try
            {
                await CoreLoadDataAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task AddGpuAsync(VirtualMachineViewModel vm)
        {
            if (vm == null) return;

            var gpuInfoList = this.HostGpus.Select(h => h.Model).ToList();
            var chooseGpuWindow = new ChooseGPUWindow(vm.Name, gpuInfoList);
            if (chooseGpuWindow.ShowDialog() != true) return;

            var selectedGpu = chooseGpuWindow.SelectedGpu;
            bool isSimpleMode = chooseGpuWindow.IsSimpleMode;

            PartitionInfo userSelectedPartition = null;

            if (!isSimpleMode)
            {
                string vmState = await _gpuService.GetVmStateAsync(vm.Name);
                if (vmState != "Off")
                {
                    ShutdownChoice choice = ShutdownChoice.Cancel;
                    await Application.Current.Dispatcher.InvokeAsync(() => {
                        var dialog = new ShutdownConfirmationDialog(vm.Name);
                        dialog.ShowDialog();
                        choice = dialog.UserChoice;
                    });

                    if (choice == ShutdownChoice.ShutdownAndContinue)
                    {
                        IsLoading = true;
                        await _gpuService.ShutdownVmAsync(vm.Name);
                        IsLoading = false;
                    }
                    else return;
                }

                IsLoading = true;
                try
                {
                    var partitions = await _gpuService.GetPartitionsFromVmAsync(vm.Name);
                    var selectablePartitions = partitions
                        .Where(p => p.OsType == OperatingSystemType.Windows || p.OsType == OperatingSystemType.Linux)
                        .ToList();

                    if (!selectablePartitions.Any())
                    {
                        Utils.Show(ExHyperV.Properties.Resources.Error_NoRecognizedPartitionFound);
                        return;
                    }

                    await Application.Current.Dispatcher.InvokeAsync(async () => {
                        userSelectedPartition = await ShowPartitionSelectionDialog(selectablePartitions);
                    });

                    if (userSelectedPartition == null) return;
                }
                catch (Exception ex)
                {
                    Utils.Show(string.Format(Properties.Resources.Error_FatalError, ex.Message));
                    return;
                }
                finally { IsLoading = false; }
            }

            IsLoading = true;
            try
            {
                string result = await _gpuService.AddGpuPartitionAsync(vm.Name, selectedGpu.Path, selectedGpu.Manu, userSelectedPartition, selectedGpu.Id);

                if (result == "OK")
                {
                    string GPUname = selectedGpu.GPUname;
                    string VMname = vm.Name;
                    var ms = Application.Current.MainWindow as MainWindow;
                    if (ms != null)
                    {
                        var snackbarService = new SnackbarService();
                        snackbarService.SetSnackbarPresenter(ms.SnackbarPresenter);
                        snackbarService.Show(
                            Properties.Resources.success,
                            GPUname + Properties.Resources.already + VMname,
                            ControlAppearance.Success,
                            new FontIcon
                            {
                                Glyph = "\uF16C",
                                FontSize = 32,
                                FontFamily = Application.Current.FindResource("SegoeFluentIcons") as FontFamily,
                            },
                            System.TimeSpan.FromSeconds(2)
                        );
                    }
                }
                else
                {
                    Utils.Show(string.Format(Properties.Resources.GpuPartition_Error_MountGpuFailed, result));
                }
            }
            catch (System.Exception ex)
            {
                Utils.Show(string.Format(Properties.Resources.Error_FatalError, ex.Message));
            }
            finally
            {
                await CoreLoadDataAsync();
                IsLoading = false;
            }
        }
        [RelayCommand]
        private async Task RemoveGpuAsync(object[] parameters)
        {
            if (parameters == null || parameters.Length < 2) return;
            if (parameters[0] is not VirtualMachineViewModel vm ||
                parameters[1] is not AssignedGpuViewModel gpuToRemove)
            {
                if (parameters[0] is AssignedGpuViewModel gpu && parameters[1] is VirtualMachineViewModel v)
                {
                    gpuToRemove = gpu;
                    vm = v;
                }
                else
                {
                    return;
                }
            }

            IsLoading = true;
            try
            {
                bool success = await _gpuService.RemoveGpuPartitionAsync(vm.Name, gpuToRemove.AdapterId);
                if (success)
                {
                    vm.AssignedGpus.Remove(gpuToRemove);
                }
                else
                {
                    Utils.Show(Properties.Resources.Error_UnmountGpuFailed);
                }
            }
            finally
            {
                IsLoading = false;
            }
        }

        private async Task CoreLoadDataAsync()
        {
            try
            {
                var isHyperVInstalled = await _gpuService.IsHyperVModuleAvailableAsync();
                var hostGpuModels = await _gpuService.GetHostGpusAsync();
                var vmModels = await _gpuService.GetVirtualMachinesAsync();
                var newHostGpus = new List<HostGpuViewModel>();
                foreach (var gpuModel in hostGpuModels)
                {
                    newHostGpus.Add(new HostGpuViewModel(gpuModel, isHyperVInstalled));
                }
                var newVirtualMachines = new List<VirtualMachineViewModel>();
                foreach (var vmModel in vmModels)
                {
                    newVirtualMachines.Add(new VirtualMachineViewModel(vmModel, newHostGpus));
                }
                if (System.Windows.Application.Current.Dispatcher.CheckAccess())
                {
                    UpdateCollections(newHostGpus, newVirtualMachines);
                }
                else
                {
                    await System.Windows.Application.Current.Dispatcher.InvokeAsync(() =>
                    {
                        UpdateCollections(newHostGpus, newVirtualMachines);
                    });
                }
            }
            catch (Exception ex)
            {
                Utils.Show(string.Format(Properties.Resources.Error_LoadDataFailed, ex.Message));
            }
        }

        private void UpdateCollections(List<HostGpuViewModel> newGpus, List<VirtualMachineViewModel> newVms)
        {
            HostGpus.Clear();
            foreach (var gpu in newGpus) { HostGpus.Add(gpu); }
            VirtualMachines.Clear();
            foreach (var vm in newVms) { VirtualMachines.Add(vm); }
        }

        private async Task<PartitionInfo> ShowPartitionSelectionDialog(List<PartitionInfo> partitions)
        {
            var dialog = new ChoosePartitionWindow(partitions);
            bool? result = dialog.ShowDialog();
            if (result == true)
            {
                return dialog.SelectedPartition;
            }
            return null;
        }

    }
}

================================================================================
FILE: ViewModels\HostGpuViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Models;
using ExHyperV.Properties;

namespace ExHyperV.ViewModels
{
    public partial class HostGpuViewModel : ObservableObject
    {
        public GPUInfo Model { get; }

        public HostGpuViewModel(GPUInfo model, bool isHyperVInstalled)
        {
            Model = model;
            if (!isHyperVInstalled)
            {
                GpuPartitionStatusText = Resources.needhyperv;
            }
            else if (!string.IsNullOrEmpty(Model.Pname) && Model.Pname != Resources.none)
            {
                GpuPartitionStatusText = Resources.support;
            }
            else
            {
                GpuPartitionStatusText = Resources.notsupport;
            }
        }

        public string Name => Model.Name;
        public string Vendor => Model.Vendor;
        public string Manu => Model.Manu;
        public string Ram => Model.Ram;
        public string InstanceId => Model.InstanceId;
        public string DriverVersion => Model.DriverVersion;
        public string Pname => Model.Pname;
        public string GpuPartitionStatusText { get; }

        public string RamDisplay
        {
            get
            {
                if (long.TryParse(Model.Ram, out long ramBytes))
                {
                    // 专门为摩尔线程准备的单位换算逻辑（注册表里面单位是 MB）
                    if (Model.Manu.Contains("Moore"))
                    {
                        return $"{ramBytes / 1024} MB";
                    }
                    // 标准逻辑
                    return $"{ramBytes / (1024 * 1024)} MB";
                }
                return "N/A"; // 如果无法解析，则显示 N/A
            }
        }
        public bool IsPartitionable => !string.IsNullOrEmpty(Model.Pname);
    }
}

================================================================================
FILE: ViewModels\InstancesPageViewModel.cs
================================================================================

﻿using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Threading; // 必须引用：用于定时器
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Properties;
using ExHyperV.Services;
using ExHyperV.Tools;

namespace ExHyperV.ViewModels
{
    public partial class InstancesPageViewModel : ObservableObject
    {
        private readonly InstancesService _instancesService;
        private readonly DispatcherTimer _localTimer;

        [ObservableProperty]
        private bool _isLoading;

        [ObservableProperty]
        private ObservableCollection<VmInstanceInfo> _vmList = new();

        [ObservableProperty]
        private VmInstanceInfo _selectedVm;

        public InstancesPageViewModel(InstancesService instancesService)
        {
            _instancesService = instancesService;

            // 初始化本地 1秒 定时器 (用于 UI 秒表跳动)
            _localTimer = new DispatcherTimer();
            _localTimer.Interval = TimeSpan.FromSeconds(1);
            _localTimer.Tick += LocalTimer_Tick;
            _localTimer.Start();

            _ = LoadVmsAsync();
        }

        // 每秒触发：纯内存操作，界面极其流畅
        private void LocalTimer_Tick(object sender, EventArgs e)
        {
            if (VmList == null) return;
            foreach (var vm in VmList)
            {
                // 只有处于“运行中”状态才自增时间
                if (vm.IsRunning)
                {
                    vm.AddOneSecond();
                }
            }
        }

        [RelayCommand]
        private async Task LoadVmsAsync()
        {
            IsLoading = true;
            VmList.Clear();
            var vms = await _instancesService.GetVmListAsync();

            // 排序：正在运行/启动中等非关机状态排在前面，然后按名称排序
            var sortedVms = vms.OrderBy(v => v.Status == "已关机" ? 1 : 0)
                               .ThenBy(v => v.Name);

            foreach (var vm in sortedVms)
            {
                // 解析 Note 中的 OS 类型标记
                string osType = "windows"; // 默认为 windows
                if (!string.IsNullOrEmpty(vm.Notes))
                {
                    string notes = vm.Notes.ToLower();
                    if (notes.Contains("[ostype:linux]")) osType = "linux";
                    else if (notes.Contains("[ostype:android]")) osType = "android";
                    else if (notes.Contains("[ostype:macos]")) osType = "macos";
                    else if (notes.Contains("[ostype:freebsd]")) osType = "freebsd"; // 新增
                    else if (notes.Contains("[ostype:openbsd]")) osType = "openbsd"; // 新增
                    else if (notes.Contains("[ostype:openwrt]")) osType = "openwrt";
                    else if (notes.Contains("[ostype:fnos]")) osType = "fnos";
                    else if (notes.Contains("[ostype:chromeos]")) osType = "chromeos";
                    else if (notes.Contains("[ostype:fydeos]")) osType = "fydeos";
                }

                // 传递原始 TimeSpan
                var instance = new VmInstanceInfo(
                    vm.Name,
                    vm.Status,
                    osType,
                    vm.CpuCount,
                    vm.MemoryGb,
                    vm.DiskSize,
                    vm.Uptime
                );

                // 监听系统类型改变并自动写入 Hyper-V Notes
                instance.PropertyChanged += async (s, e) =>
                {
                    if (e.PropertyName == nameof(VmInstanceInfo.OsType))
                    {
                        await _instancesService.UpdateOsTypeNoteAsync(instance.Name, instance.OsType);
                    }
                };

                VmList.Add(instance);
            }
            IsLoading = false;

            // 启动后台轮询
            _ = StatusPollingLoop();
        }

        // 后台校准循环：每3秒一次，修正时间误差，获取真实状态
        private async Task StatusPollingLoop()
        {
            while (true)
            {
                if (VmList.Count > 0)
                {
                    // 创建副本列表以防集合修改
                    var checkList = VmList.ToList();
                    foreach (var vm in checkList)
                    {
                        var info = await _instancesService.GetVmDynamicInfoAsync(vm.Name);

                        // 更新 UI 线程上的属性
                        System.Windows.Application.Current.Dispatcher.Invoke(() =>
                        {
                            vm.State = info.State; // 会自动更新 IsRunning
                            // 覆盖时间（校准）
                            vm.RawUptime = info.Uptime;
                        });
                    }
                }
                // 每3秒进行一次后台校准
                await Task.Delay(3000);
            }
        }

        [RelayCommand]
        private async Task ControlAsync(string action)
        {
            if (SelectedVm == null) return;

            // 对危险操作进行二次确认
            bool confirmed = action switch
            {
                "Restart" => await DialogManager.ShowConfirmAsync(
                    Resources.Confirm_Restart_Title,
                    string.Format(Resources.Confirm_Restart_Message, SelectedVm.Name),
                    isDanger: false),
                "Stop" => await DialogManager.ShowConfirmAsync(
                    Resources.Confirm_Shutdown_Title,
                    string.Format(Resources.Confirm_Shutdown_Message, SelectedVm.Name),
                    isDanger: false),
                "TurnOff" => await DialogManager.ShowConfirmAsync(
                    Resources.Confirm_TurnOff_Title,
                    string.Format(Resources.Confirm_TurnOff_Message, SelectedVm.Name),
                    isDanger: true),
                _ => true // 启动、暂停、保存等操作无需确认
            };

            if (!confirmed) return;

            await _instancesService.ExecuteControlActionAsync(SelectedVm.Name, action);

            // 操作后立即校准一次状态，提升交互响应感
            var info = await _instancesService.GetVmDynamicInfoAsync(SelectedVm.Name);
            SelectedVm.State = info.State;
            SelectedVm.RawUptime = info.Uptime;
        }
    }

    // ==========================================
    // UI 绑定的包装类
    // ==========================================
    public partial class VmInstanceInfo : ObservableObject
    {
        [ObservableProperty] private string _name;
        [ObservableProperty] private string _state; // 如 "运行中", "已关机"
        [ObservableProperty] private string _osType;

        // 配置摘要 (用于 UI 显示: "16 Cores / 4.0GB RAM / 64G")
        [ObservableProperty] private string _configSummary;

        // 原始时间数据
        private TimeSpan _rawUptime;
        public TimeSpan RawUptime
        {
            get => _rawUptime;
            set
            {
                if (SetProperty(ref _rawUptime, value))
                {
                    // 当原始时间改变时，通知 Uptime 字符串更新
                    OnPropertyChanged(nameof(Uptime));
                }
            }
        }

        // 给 UI 绑定的格式化时间字符串
        public string Uptime => string.Format("{0:D2}:{1:D2}:{2:D2}:{3:D2}",
            _rawUptime.Days, _rawUptime.Hours, _rawUptime.Minutes, _rawUptime.Seconds);

        // 判断是否应该计时
        public bool IsRunning => State == "运行中" || State == "正在启动" || State == "正在关闭";

        public VmInstanceInfo(string name, string state, string osType, int cpu, double ram, string disk, TimeSpan uptime)
        {
            _name = name;
            _state = state;
            _osType = osType;
            _rawUptime = uptime;
            _configSummary = $"{cpu} Cores / {ram:F1}GB RAM / {disk}";
        }

        // 手动增加一秒 (由定时器调用)
        public void AddOneSecond()
        {
            RawUptime = RawUptime.Add(TimeSpan.FromSeconds(1));
        }

        // 当状态改变时，更新 IsRunning 属性
        partial void OnStateChanged(string value)
        {
            OnPropertyChanged(nameof(IsRunning));
            // 如果关机了，重置时间为 0
            if (value == "已关机")
            {
                RawUptime = TimeSpan.Zero;
            }
        }
    }
}

================================================================================
FILE: ViewModels\MainPageViewModel.cs
================================================================================

﻿using System.Globalization;
using System.Management.Automation;
using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Tools;

namespace ExHyperV.ViewModels
{
    public partial class MainPageViewModel : ObservableObject
    {
        [ObservableProperty]
        private string? _caption;

        [ObservableProperty]
        private string? _OSArchitecture;

        [ObservableProperty]
        private string? _cpuModel;

        [ObservableProperty]
        private string? _memCap;

        [ObservableProperty]
        private string? _appVersion;

        [ObservableProperty]
        private string? _author;

        [ObservableProperty]
        private string? _buildDate;

        public MainPageViewModel()
        {
            AppVersion = Utils.Version;
            Author = Utils.Author;
            BuildDate = Utils.GetLinkerTime().ToString("yyyy/MM/dd HH:mm", CultureInfo.InvariantCulture);

            static (string Caption, string OSArchitecture, string CpuModel, string MemCap) LoadSystemData()
            {
                Utils.Run("Set-ExecutionPolicy RemoteSigned -Scope Process -Force");
                var script = @"
                    $os = Get-CimInstance Win32_OperatingSystem | Select-Object Caption, OSArchitecture, Version
                    $cpu = Get-CimInstance Win32_Processor | Select-Object Name, MaxClockSpeed
                    $memory = (Get-CimInstance Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum).Sum / 1GB
                    return @($os, $cpu, [double]$memory)";
                var results = Utils.Run(script);

                string osCaption = "N/A";
                string osVersion = "";
                string osArch = "N/A";
                string cpuInfo = "N/A";
                string memoryInfo = "N/A GB";

                if (results != null && results.Count > 0 && results[0]?.Properties["Caption"]?.Value != null)
                {
                    osCaption = results[0].Properties["Caption"].Value.ToString().Replace("Microsoft ", "");
                    if (results[0].Properties["Version"]?.Value != null)
                    {
                        osVersion = results[0].Properties["Version"].Value.ToString();
                        if (osVersion.Length >= 5)
                        {
                            osVersion = osVersion.Substring(osVersion.Length - 5);
                        }
                    }
                    osArch = results[0].Properties["OSArchitecture"]?.Value?.ToString() ?? "N/A";
                }

                if (results != null && results.Count > 1 && results[1] != null)
                {
                    object cpuData = results[1].BaseObject;
                    var cpus = new List<PSObject>();

                    if (cpuData is System.Collections.IEnumerable enumerableData && !(cpuData is string)) { foreach (var item in enumerableData) { if (item is PSObject pso) cpus.Add(pso); } }
                    else if (cpuData is PSObject singleCpuPso) { cpus.Add(singleCpuPso); }
                    else if (results[1].Properties["Name"]?.Value != null) { cpus.Add(results[1]); }

                    if (cpus.Any())
                    {
                        PSObject firstCpu = cpus.First();
                        string cpuName = firstCpu.Properties["Name"]?.Value?.ToString()?.Trim() ?? "Unknown CPU";
                        double cpuSpeedGHz = 0;
                        if (firstCpu.Properties["MaxClockSpeed"]?.Value != null && double.TryParse(firstCpu.Properties["MaxClockSpeed"].Value.ToString(), NumberStyles.Any, CultureInfo.InvariantCulture, out double mcsRaw))
                        {
                            cpuSpeedGHz = Math.Round(mcsRaw / 1000, 2);
                        }
                        string speedSuffix = (cpuName.IndexOf("GHz", StringComparison.OrdinalIgnoreCase) == -1 && cpuSpeedGHz > 0) ? $" @ {cpuSpeedGHz.ToString(CultureInfo.InvariantCulture)} GHz" : "";
                        cpuInfo = cpus.Count > 1 ? $"{cpuName}{speedSuffix} x{cpus.Count}" : $"{cpuName}{speedSuffix}";
                    }
                }

                if (results != null && results.Count > 2 && results[2]?.BaseObject != null && double.TryParse(results[2].BaseObject.ToString(), NumberStyles.Any, CultureInfo.InvariantCulture, out double totalMemoryRaw))
                {
                    double totalMemory = Math.Round(totalMemoryRaw, 2);
                    memoryInfo = $"{totalMemory.ToString(CultureInfo.InvariantCulture)} GB";
                }

                return (
                    Caption: string.IsNullOrEmpty(osVersion) ? osCaption : $"{osCaption} Build.{osVersion}",
                    OSArchitecture: osArch,
                    CpuModel: cpuInfo,
                    MemCap: memoryInfo
                );
            }

            var systemData = Task.Run(LoadSystemData).Result;

            Caption = systemData.Caption;
            OSArchitecture = systemData.OSArchitecture;
            CpuModel = systemData.CpuModel;
            MemCap = systemData.MemCap;
        }
    }
}

================================================================================
FILE: ViewModels\MemoryPageViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Services;
using ExHyperV.Models;
using Wpf.Ui;
using Wpf.Ui.Controls;

namespace ExHyperV.ViewModels
{
    public partial class MemoryPageViewModel : ObservableObject
    {
        public static MemoryPageViewModel Instance { get; } = new MemoryPageViewModel();

        private readonly IMemoryService _memoryService;
        private readonly DispatcherTimer _liveDataTimer;
        private bool _isUpdating = false;

        [ObservableProperty]
        private bool _isLoading;

        [ObservableProperty]
        private ObservableCollection<VMMemoryViewModel> _virtualMachinesMemory = new();

        public MemoryPageViewModel()
        {
            _memoryService = new MemoryService();

            _liveDataTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };
            _liveDataTimer.Tick += OnLiveDataTimerTick;

            _ = LoadAllDataAsync();
        }

        public void StartTimer()
        {
            if (!_liveDataTimer.IsEnabled) _liveDataTimer.Start();
        }

        public void StopTimer()
        {
            if (_liveDataTimer.IsEnabled) _liveDataTimer.Stop();
        }

        private async void OnLiveDataTimerTick(object sender, EventArgs e)
        {
            if (_isUpdating) return;
            _isUpdating = true;

            try
            {
                var liveDataList = await _memoryService.GetVirtualMachinesMemoryUsageAsync();
                if (liveDataList == null) return;

                var liveDataLookup = liveDataList.ToDictionary(d => d.VMName);
                bool needsResort = false;

                foreach (var vmViewModel in VirtualMachinesMemory)
                {
                    bool wasRunning = vmViewModel.IsVmRunning;
                    if (liveDataLookup.TryGetValue(vmViewModel.VMName, out var liveData))
                    {
                        vmViewModel.UpdateLiveData(liveData);
                    }
                    else
                    {
                        vmViewModel.MarkAsOff();
                    }

                    if (wasRunning != vmViewModel.IsVmRunning)
                    {
                        needsResort = true;
                    }
                }

                if (needsResort)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        var sorted = VirtualMachinesMemory
                            .OrderByDescending(v => v.IsVmRunning)
                            .ThenBy(v => v.VMName)
                            .ToList();

                        for (int i = 0; i < sorted.Count; i++)
                        {
                            int oldIndex = VirtualMachinesMemory.IndexOf(sorted[i]);
                            if (oldIndex != i)
                            {
                                VirtualMachinesMemory.Move(oldIndex, i);
                            }
                        }
                    });
                }
            }
            catch { }
            finally
            {
                _isUpdating = false;
            }
        }

        [RelayCommand]
        public async Task LoadAllDataAsync()
        {
            if (IsLoading) return;
            IsLoading = true;
            try
            {
                var vmConfigs = await _memoryService.GetVirtualMachinesMemoryConfigurationAsync();

                var sortedConfigs = vmConfigs
                    .OrderByDescending(c => c.State == "Running")
                    .ThenBy(c => c.VMName)
                    .ToList();

                Application.Current.Dispatcher.Invoke(() =>
                {
                    var currentVms = VirtualMachinesMemory.ToDictionary(vm => vm.VMName);
                    VirtualMachinesMemory.Clear();

                    foreach (var config in sortedConfigs)
                    {
                        if (currentVms.TryGetValue(config.VMName, out var existingVm))
                        {
                            existingVm.UpdateConfiguration(config);
                            VirtualMachinesMemory.Add(existingVm);
                        }
                        else
                        {
                            VirtualMachinesMemory.Add(new VMMemoryViewModel(config, this, _memoryService));
                        }
                    }
                });

                StartTimer();
            }
            catch (Exception ex)
            {
                ShowSnackbar(
                    ExHyperV.Properties.Resources.error,
                    string.Format(ExHyperV.Properties.Resources.Error_GenericFormat, ex.Message),
                    ControlAppearance.Danger,
                    SymbolRegular.ErrorCircle24);
            }
            finally
            {
                IsLoading = false;
            }
        }

        public void ShowSnackbar(string title, string message, ControlAppearance appearance, SymbolRegular icon, double seconds = 3)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                var mainWindow = Application.Current.MainWindow;
                if (mainWindow != null)
                {
                    var presenter = mainWindow.FindName("SnackbarPresenter") as SnackbarPresenter;
                    if (presenter != null)
                    {
                        var snackbar = new Snackbar(presenter)
                        {
                            Title = title,
                            Content = message,
                            Appearance = appearance,
                            Icon = new SymbolIcon(icon) { FontSize = 20 },
                            Timeout = TimeSpan.FromSeconds(seconds)
                        };
                        snackbar.Show();
                    }
                }
            });
        }
    }
}

================================================================================
FILE: ViewModels\SelectableCoreViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Models;

namespace ExHyperV.ViewModels.Dialogs
{
    public partial class SelectableCoreViewModel : ObservableObject
    {
        [ObservableProperty]
        private int _coreId;

        [ObservableProperty]
        private bool _isSelected;

        [ObservableProperty]
        private CoreType _coreType;
    }
}

================================================================================
FILE: ViewModels\SettingsViewModel.cs
================================================================================

﻿using System.Diagnostics;
using System.Collections.Generic;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Properties;
using ExHyperV.Services;
using ExHyperV.Tools;
using System.Threading.Tasks;
using System;

namespace ExHyperV.ViewModels
{
    public partial class SettingsViewModel : ObservableObject
    {
        private bool _isInitializing = true;

        [ObservableProperty] private List<string> _availableThemes;
        [ObservableProperty] private string _selectedTheme;
        [ObservableProperty] private List<string> _availableLanguages;
        [ObservableProperty] private string _selectedLanguage;

        [ObservableProperty] private string _updateStatusText;
        [ObservableProperty] private bool _isCheckingForUpdate;
        [ObservableProperty] private string _updateActionIcon;
        [ObservableProperty] private IRelayCommand _updateActionCommand;
        [ObservableProperty] private bool _isUpdateActionEnabled;
        private string _latestVersionTag;

        [ObservableProperty]
        private bool _showUpdateIndicator;


        [RelayCommand]
        private async Task CheckForUpdateAsync()
        {
            IsCheckingForUpdate = true;
            IsUpdateActionEnabled = false;
            ShowUpdateIndicator = false;
            UpdateStatusText = ExHyperV.Properties.Resources.Status_CheckingForUpdates;

            try
            {
                var result = await SettingsService.CheckForUpdateAsync(Utils.Version);

                if (result.IsUpdateAvailable)
                {
                    UpdateStatusText = string.Format(Properties.Resources.Info_NewVersionFound, result.LatestVersion);
                    UpdateActionIcon = "\uE71B";
                    UpdateActionCommand = GoToReleasePageCommand;
                    _latestVersionTag = result.LatestVersion;
                    ShowUpdateIndicator = true;
                }
                else
                {
                    UpdateStatusText = ExHyperV.Properties.Resources.Info_AlreadyLatestVersion;
                    UpdateActionIcon = "\uE73E";
                    UpdateActionCommand = CheckForUpdateCommand;
                }
            }
            catch (Exception ex)
            {
                UpdateStatusText = ex.Message;
                UpdateActionIcon = "\uE72C";
                UpdateActionCommand = CheckForUpdateCommand;
            }
            finally
            {
                IsCheckingForUpdate = false;
                IsUpdateActionEnabled = true;
            }
        }

        [RelayCommand]
        private void GoToReleasePage()
        {
            if (string.IsNullOrEmpty(_latestVersionTag)) return;

            var url = $"https://github.com/Justsenger/ExHyperV/releases/tag/{_latestVersionTag}";

            try
            {
                Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });
            }
            catch{}
        }
        public string CopyrightInfo => "© 2025 | Saniye | " + Utils.Version;

        public SettingsViewModel()
        {
            AvailableThemes = new List<string> { Resources.light, Resources.dark };
            AvailableLanguages = new List<string> { "中文", "English" };

            LoadCurrentSettings();
            _isInitializing = false;

            UpdateActionCommand = CheckForUpdateCommand;
            _ = CheckForUpdateCommand.ExecuteAsync(null);
        }

        private void LoadCurrentSettings()
        {
            _selectedTheme = SettingsService.GetTheme();
            string langCode = SettingsService.GetLanguage();
            _selectedLanguage = langCode == "zh-CN" ? "中文" : "English";
        }

        partial void OnSelectedThemeChanged(string value)
        {
            if (_isInitializing || value == null) return;
            SettingsService.ApplyTheme(value);
        }

        partial void OnSelectedLanguageChanged(string value)
        {
            if (_isInitializing || value == null) return;
            SettingsService.SetLanguageAndRestart(value);
        }
    }
}

================================================================================
FILE: ViewModels\StatusPageViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Tools;
using Microsoft.Win32;
using System.Security.Principal;
using System.Windows;
using System.Windows.Controls;
using Wpf.Ui.Controls;
using TextBlock = Wpf.Ui.Controls.TextBlock;

namespace ExHyperV.ViewModels
{
    public partial class StatusPageViewModel : ObservableObject
    {
        private bool _isInitialized = false;

        public CheckStatusViewModel SystemStatus { get; }
        public CheckStatusViewModel CpuStatus { get; }
        public CheckStatusViewModel HyperVStatus { get; }
        public CheckStatusViewModel AdminStatus { get; }
        public CheckStatusViewModel VersionStatus { get; }
        public CheckStatusViewModel IommuStatus { get; }

        [ObservableProperty] private bool _isGpuStrategyEnabled;
        [ObservableProperty] private bool _isGpuStrategyToggleEnabled = false;
        [ObservableProperty] private bool _isServerSystem;
        [ObservableProperty] private bool _isSystemSwitchEnabled = false;
        [ObservableProperty] private string _systemVersionDesc;

        public StatusPageViewModel()
        {
            SystemStatus = new CheckStatusViewModel(Properties.Resources.checksys);
            CpuStatus = new CheckStatusViewModel(Properties.Resources.checkcpuct);
            HyperVStatus = new CheckStatusViewModel(Properties.Resources.checkhyperv);
            AdminStatus = new CheckStatusViewModel(Properties.Resources.checkadmin);
            VersionStatus = new CheckStatusViewModel(Properties.Resources.checkversion);
            IommuStatus = new CheckStatusViewModel(Properties.Resources.Status_CheckingBiosIommu);
            _ = LoadInitialStatusAsync();
        }

        private async Task LoadInitialStatusAsync()
        {
            await Task.WhenAll(CheckSystemInfoAsync(), CheckCpuInfoAsync(), CheckHyperVInfoAsync(), CheckServerInfoAsync(), CheckIommuAsync());
            await CheckAdminInfoAsync();
        }

        private async Task CheckSystemInfoAsync()
        {
            await Task.Run(() =>
            {
                int buildVersion = Environment.OSVersion.Version.Build;
                bool success = buildVersion >= 17134;
                SystemStatus.IsSuccess = success;
                SystemStatus.StatusText = $"{Properties.Resources.String3}{buildVersion}{(success ? Properties.Resources.v19041 : Properties.Resources.disablegpu)}";
                SystemStatus.IsChecking = false;
            });
        }

        private async Task CheckCpuInfoAsync()
        {
            await Task.Run(() =>
            {
                var cpuvt1 = Utils.Run("(Get-CimInstance -Class Win32_Processor).VirtualizationFirmwareEnabled");
                var cpuvt2 = Utils.Run("(Get-CimInstance -Class Win32_ComputerSystem).HypervisorPresent");
                bool success = cpuvt1.Count > 0 && cpuvt2.Count > 0 && (cpuvt1[0].ToString() == "True" || cpuvt2[0].ToString() == "True");
                CpuStatus.IsSuccess = success;
                CpuStatus.StatusText = success ? Properties.Resources.GPU1 : Properties.Resources.GPU2;
                CpuStatus.IsChecking = false;
            });
        }

        private async Task CheckHyperVInfoAsync()
        {
            await Task.Run(() =>
            {
                var hypervstatus = Utils.Run("Get-Module -ListAvailable -Name Hyper-V");
                bool success = hypervstatus.Count != 0;
                HyperVStatus.IsSuccess = success;
                HyperVStatus.StatusText = success ? Properties.Resources.String1 : Properties.Resources.String2;
                HyperVStatus.IsChecking = false;
            });
        }

        private async Task CheckAdminInfoAsync()
        {
            await Task.Run(() =>
            {
                WindowsIdentity identity = WindowsIdentity.GetCurrent();
                WindowsPrincipal principal = new WindowsPrincipal(identity);
                bool isAdmin = principal.IsInRole(WindowsBuiltInRole.Administrator);
                AdminStatus.IsSuccess = isAdmin;
                AdminStatus.StatusText = isAdmin ? Properties.Resources.Admin1 : Properties.Resources.Admin2;
                if (isAdmin)
                {
                    IsGpuStrategyToggleEnabled = true;
                    CheckGpuStrategyReg();
                    IsSystemSwitchEnabled = true;
                    InitializeProductType();
                }
                AdminStatus.IsChecking = false;
            });
        }

        private async Task CheckServerInfoAsync()
        {
            await Task.Run(() =>
            {
                var result = Utils.Run("(Get-CimInstance -Class Win32_OperatingSystem).ProductType");
                bool success = result.Count > 0 && result[0].ToString() == "3";
                VersionStatus.IsSuccess = success;
                VersionStatus.StatusText = success ? Properties.Resources.Isserver : Properties.Resources.ddaa;
                VersionStatus.IsChecking = false;
            });
        }

        private async Task CheckIommuAsync()
        {
            await Task.Run(() =>
            {
                var io = Utils.Run("(Get-CimInstance -Namespace \"Root\\Microsoft\\Windows\\DeviceGuard\" -ClassName \"Win32_DeviceGuard\").AvailableSecurityProperties -contains 3");
                bool success = io.Count > 0 && io[0].ToString() == "True";
                IommuStatus.IsSuccess = success;
                IommuStatus.StatusText = success ? ExHyperV.Properties.Resources.Info_BiosIommuEnabled : ExHyperV.Properties.Resources.Error_BiosIommuDisabled;
                IommuStatus.IsChecking = false;
            });
        }

        partial void OnIsGpuStrategyEnabledChanged(bool value)
        {
            if (value) Utils.AddGpuAssignmentStrategyReg(); else Utils.RemoveGpuAssignmentStrategyReg();
        }

        private void CheckGpuStrategyReg()
        {
            string script = @"[bool]((Test-Path 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\HyperV') -and ($k = Get-Item 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\HyperV' -EA 0) -and ('RequireSecureDeviceAssignment', 'RequireSupportedDeviceAssignment' | ForEach-Object { ($k.GetValue($_, $null) -ne $null) }) -notcontains $false)";
            var result = Utils.Run(script);
            SetProperty(ref _isGpuStrategyEnabled, result.Count > 0 && result[0].ToString().ToLower() == "true", nameof(IsGpuStrategyEnabled));
        }

        private void InitializeProductType()
        {
            bool isServer = false;
            try
            {
                using (var key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\ProductOptions"))
                {
                    if (key != null)
                    {
                        var val = key.GetValue("ProductType")?.ToString();
                        isServer = val != null && val.Contains("Server");
                    }
                }
            }
            catch { }
            _isServerSystem = isServer;
            UpdateSystemDesc(isServer);
            _isInitialized = true;
            OnPropertyChanged(nameof(IsServerSystem));
        }

        private void UpdateSystemDesc(bool isServer)
        {
            string current = isServer ? Translate("Status_Edition_Server") : Translate("Status_Edition_Workstation");
            SystemVersionDesc = $"{Translate("Status_Msg_CurrentVer")}: {current}";
        }

        partial void OnIsServerSystemChanged(bool value)
        {
            if (!_isInitialized) return;
            SwitchSystemVersion(value);
        }

        private async void SwitchSystemVersion(bool toServer)
        {
            try
            {
                IsSystemSwitchEnabled = false;
                string result = await Task.Run(() => SystemSwitcher.ExecutePatch(toServer ? 1 : 2));

                if (result == "SUCCESS")
                {
                    SystemVersionDesc = Translate("Status_Msg_OperationPending");
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        var presenter = Application.Current.MainWindow?.FindName("SnackbarPresenter") as SnackbarPresenter;
                        if (presenter == null) return;
                        var grid = new Grid();
                        grid.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });
                        grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });
                        var txt = new TextBlock { Text = Translate("Status_Msg_RestartNow"), VerticalAlignment = VerticalAlignment.Center, Margin = new Thickness(0, 0, 15, 0) };
                        Grid.SetColumn(txt, 0);
                        var btn = new Wpf.Ui.Controls.Button { Content = Translate("Global_Restart"), Appearance = ControlAppearance.Primary };
                        btn.Click += (s, e) => System.Diagnostics.Process.Start("shutdown", "-r -t 0");
                        Grid.SetColumn(btn, 1);
                        grid.Children.Add(txt); grid.Children.Add(btn);
                        var snack = new Snackbar(presenter) { Title = Translate("Status_Title_Success"), Content = grid, Appearance = ControlAppearance.Success, Icon = new SymbolIcon(SymbolRegular.CheckmarkCircle24), Timeout = TimeSpan.FromSeconds(15) };
                        snack.Show();
                    });
                }
                else if (result == "PENDING")
                {
                    ShowSnackbar(Translate("Status_Title_Info"), Translate("Status_Msg_OperationPending"), ControlAppearance.Info, SymbolRegular.Info24);
                }
                else
                {
                    ShowSnackbar(Translate("Status_Title_Error"), result, ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
                    _isInitialized = false;
                    IsServerSystem = !toServer;
                    _isInitialized = true;
                    IsSystemSwitchEnabled = true;
                }
            }
            catch { IsSystemSwitchEnabled = true; }
        }

        private string Translate(string key)
        {
            if (string.IsNullOrEmpty(key)) return key;
            try { return ExHyperV.Properties.Resources.ResourceManager.GetString(key) ?? key; } catch { return key; }
        }

        public void ShowSnackbar(string title, string message, ControlAppearance appearance, SymbolRegular icon)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                var presenter = Application.Current.MainWindow?.FindName("SnackbarPresenter") as SnackbarPresenter;
                if (presenter != null)
                {
                    var snack = new Snackbar(presenter) { Title = title, Content = message, Appearance = appearance, Icon = new SymbolIcon(icon) { FontSize = 20 }, Timeout = TimeSpan.FromSeconds(4) };
                    snack.Show();
                }
            });
        }
    }
}

================================================================================
FILE: ViewModels\StoragePageViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Services;
using ExHyperV.Views;
using System.Collections.ObjectModel;
using System.Windows;
using Wpf.Ui.Controls;

namespace ExHyperV.ViewModels
{
    public partial class StoragePageViewModel : ObservableObject
    {
        public static StoragePageViewModel Instance { get; } = new StoragePageViewModel();
        private readonly IStorageService _storageService;
        public ObservableCollection<VMInfo> VmList { get; } = new();
        [ObservableProperty] private ObservableCollection<UiDriveModel> _allDrives = new();
        [ObservableProperty] private VMInfo? _selectedVm;
        [ObservableProperty] private bool _isLoading;

        public StoragePageViewModel()
        {
            _storageService = new StorageService();
            _ = InitializeVmListAsync();
        }

        async partial void OnSelectedVmChanged(VMInfo? value)
        {
            if (value != null) await RefreshVmStorageAsync();
            else AllDrives.Clear();
        }

        private async Task InitializeVmListAsync()
        {
            IsLoading = true;
            try
            {
                var vms = await Task.Run(() =>
                {
                    using (var ps = System.Management.Automation.PowerShell.Create())
                    {
                        ps.AddScript("Get-VM | Select-Object Name, State, Generation");
                        var results = ps.Invoke();
                        return results.Select(r => new VMInfo(
                            r.Properties["Name"].Value?.ToString() ?? "",
                            "", "", "", new Dictionary<string, string>(),
                            r.Properties["Generation"].Value != null ? Convert.ToInt32(r.Properties["Generation"].Value) : 0,
                            r.Properties["State"].Value?.ToString() == "Running"
                        )).OrderByDescending(vm => vm.IsRunning).ThenBy(vm => vm.Name).ToList();
                    }
                });
                VmList.Clear();
                foreach (var vm in vms) VmList.Add(vm);
                if (SelectedVm == null) SelectedVm = VmList.FirstOrDefault();
            }
            catch (Exception ex) { ShowSnackbar(Translate("Storage_Title_Error"), ex.Message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24); }
            finally { IsLoading = false; }
        }

        [RelayCommand]
        public async Task RefreshVmStorageAsync()
        {
            if (SelectedVm == null) return;
            try
            {
                var storageInfo = await _storageService.GetVmStorageInfoAsync(SelectedVm.Name);
                Application.Current.Dispatcher.Invoke(() => {
                    AllDrives.Clear();
                    foreach (var ctrl in storageInfo)
                    {
                        if (ctrl.AttachedDrives == null) continue;
                        foreach (var drive in ctrl.AttachedDrives)
                        {
                            AllDrives.Add(new UiDriveModel
                            {
                                DriveType = drive.DriveType,
                                DiskType = drive.DiskType,
                                PathOrDiskNumber = drive.PathOrDiskNumber?.ToString() ?? "",
                                ControllerLocation = drive.ControllerLocation,
                                ControllerType = ctrl.ControllerType,
                                ControllerNumber = ctrl.ControllerNumber,
                                DiskNumber = drive.DiskNumber,
                                DiskModel = drive.DiskModel,
                                DiskSizeGB = drive.DiskSizeGB,
                                SerialNumber = drive.SerialNumber
                            });
                        }
                    }
                });
            }
            catch (Exception ex) { ShowSnackbar(Translate("Storage_Title_Error"), ex.Message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24); }
            finally { IsLoading = false; }
        }

        [RelayCommand]
        public async Task RemoveDriveAsync(UiDriveModel drive)
        {
            if (drive == null || SelectedVm == null) return;
            IsLoading = true;
            try
            {
                var (success, message) = await _storageService.RemoveDriveAsync(SelectedVm.Name, drive);
                if (success)
                {
                    await RefreshVmStorageAsync();
                    string titleKey = message == "Storage_Msg_Ejected" ? "Storage_Title_EjectSuccess" : "Storage_Title_RemoveSuccess";
                    ShowSnackbar(Translate(titleKey), Translate(message), ControlAppearance.Success, SymbolRegular.CheckmarkCircle24);
                }
                else
                {
                    ShowSnackbar(Translate("Storage_Title_Error"), Translate(message), ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
                }
            }
            catch (Exception ex) { ShowSnackbar(Translate("Storage_Title_Error"), ex.Message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24); }
            finally { IsLoading = false; }
        }

        [RelayCommand]
        public async Task AddStorageAsync()
        {
            if (SelectedVm == null) return;
            await Task.Delay(50);
            try
            {
                var currentStorage = ConvertUiDrivesToInfo(AllDrives);
                var dialog = new ChooseDiskWindow(SelectedVm.Name, SelectedVm.Generation, SelectedVm.IsRunning, currentStorage);
                if (Application.Current.MainWindow != null) dialog.Owner = Application.Current.MainWindow;

                if (dialog.ShowDialog() == true)
                {
                    var resultVm = dialog.ViewModel;
                    IsLoading = true;

                    if (resultVm.IsPhysicalSource && resultVm.SelectedPhysicalDisk != null)
                        await _storageService.SetDiskOfflineStatusAsync(resultVm.SelectedPhysicalDisk.Number, true);

                    string pathOrNumber = resultVm.IsPhysicalSource ? resultVm.SelectedPhysicalDisk?.Number.ToString() : resultVm.FilePath;

                    var (success, message, actualType, actualNumber, actualLocation) = await _storageService.AddDriveAsync(
                        SelectedVm.Name,
                        resultVm.SelectedControllerType,
                        resultVm.SelectedControllerNumber,
                        resultVm.SelectedLocation,
                        resultVm.DeviceType,
                        pathOrNumber,
                        resultVm.IsPhysicalSource,
                        resultVm.IsNewDisk,
                        resultVm.NewDiskSize,
                        resultVm.SelectedVhdType,
                        resultVm.ParentPath,
                        resultVm.SectorFormat,
                        resultVm.BlockSize,
                        resultVm.IsoSourceFolderPath,
                        resultVm.IsoVolumeLabel
                    );

                    if (success)
                    {
                        await RefreshVmStorageAsync();
                        string detail = $"{Translate("Storage_Msg_MountedTo")} {actualType} {actualNumber} : {actualLocation}";
                        ShowSnackbar(Translate("Storage_Title_AddSuccess"), detail, ControlAppearance.Success, SymbolRegular.CheckmarkCircle24);
                    }
                    else
                    {
                        ShowSnackbar(Translate("Storage_Title_Error"), Translate(message), ControlAppearance.Danger, SymbolRegular.DismissCircle24);
                    }
                }
            }
            catch (Exception ex) { ShowSnackbar(Translate("Storage_Title_Error"), ex.Message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24); }
            finally { IsLoading = false; }
        }

        private List<VmStorageControllerInfo> ConvertUiDrivesToInfo(IEnumerable<UiDriveModel> uiDrives)
        {
            return uiDrives.GroupBy(d => new { d.ControllerType, d.ControllerNumber }).Select(g => new VmStorageControllerInfo
            {
                ControllerType = g.Key.ControllerType,
                ControllerNumber = g.Key.ControllerNumber,
                AttachedDrives = g.Select(d => new AttachedDriveInfo { ControllerLocation = d.ControllerLocation, DriveType = d.DriveType, DiskType = d.DiskType, PathOrDiskNumber = d.PathOrDiskNumber, DiskNumber = d.DiskNumber }).ToList()
            }).ToList();
        }

        [RelayCommand]
        public async Task ModifyDriveAsync(UiDriveModel drive)
        {
            if (drive == null || SelectedVm == null) return;
            var dialog = new Microsoft.Win32.OpenFileDialog();
            dialog.Filter = drive.DriveType == "HardDisk" ? "vhdx|*.vhdx;*.vhd" : "iso|*.iso";
            if (dialog.ShowDialog() == true)
            {
                IsLoading = true;
                try
                {
                    var (addSuccess, addMsg, _, _, _) = await _storageService.AddDriveAsync(SelectedVm.Name, drive.ControllerType, drive.ControllerNumber, drive.ControllerLocation, drive.DriveType, dialog.FileName, false);
                    if (addSuccess)
                    {
                        await RefreshVmStorageAsync();
                        ShowSnackbar(Translate("Storage_Title_ModifySuccess"), Translate("Storage_Msg_MediaUpdated"), ControlAppearance.Success, SymbolRegular.CheckmarkCircle24);
                    }
                    else { ShowSnackbar(Translate("Storage_Title_Error"), Translate(addMsg), ControlAppearance.Danger, SymbolRegular.ErrorCircle24); }
                }
                catch (Exception ex) { ShowSnackbar(Translate("Storage_Title_Error"), ex.Message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24); }
                finally { IsLoading = false; }
            }
        }

        private string Translate(string key)
        {
            if (string.IsNullOrEmpty(key)) return key;
            try
            {
                var translated = ExHyperV.Properties.Resources.ResourceManager.GetString(key);
                return string.IsNullOrEmpty(translated) ? key : translated;
            }
            catch { return key; }
        }

        public void ShowSnackbar(string title, string message, ControlAppearance appearance, SymbolRegular icon, double seconds = 4)
        {
            Application.Current.Dispatcher.Invoke(() => {
                var mainWindow = Application.Current.MainWindow;
                if (mainWindow != null)
                {
                    var presenter = mainWindow.FindName("SnackbarPresenter") as SnackbarPresenter;
                    if (presenter != null)
                    {
                        var snackbar = new Snackbar(presenter) { Title = title, Content = message, Appearance = appearance, Icon = new SymbolIcon(icon) { FontSize = 20 }, Timeout = TimeSpan.FromSeconds(seconds) };
                        snackbar.Show();
                    }
                }
            });
        }
    }
}

================================================================================
FILE: ViewModels\SwitchViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Services;
using ExHyperV.Tools;

namespace ExHyperV.ViewModels
{
    public partial class SwitchViewModel : ObservableObject
    {
        private readonly INetworkService _networkService;
        private readonly List<PhysicalAdapterInfo> _allPhysicalAdapters;
        private readonly ObservableCollection<SwitchViewModel> _allSwitchViewModels;

        [ObservableProperty] private bool _isLockedForInteraction = false;

        [ObservableProperty] private string _switchName;
        [ObservableProperty] private string _switchId;
        [ObservableProperty][NotifyPropertyChangedFor(nameof(StatusText)), NotifyPropertyChangedFor(nameof(IsConnected))] private string _selectedNetworkMode;
        [ObservableProperty][NotifyPropertyChangedFor(nameof(StatusText)), NotifyPropertyChangedFor(nameof(IsConnected)), NotifyPropertyChangedFor(nameof(DropDownButtonContent))] private string? _selectedUpstreamAdapter;
        [ObservableProperty] private bool _isHostConnectionAllowed;
        [ObservableProperty] private bool _isUpstreamSelectionEnabled;
        [ObservableProperty] private bool _isHostConnectionToggleEnabled;
        [ObservableProperty] private bool _isDefaultSwitch;
        [ObservableProperty] private ObservableCollection<string> _menuItems = new();
        [ObservableProperty] private ObservableCollection<AdapterInfo> _connectedClients = new();
        [ObservableProperty] private bool _isExpanded = false;

        public bool IsReverting { get; private set; } = false;

        public string StatusText => IsDefaultSwitch ? ExHyperV.Properties.Resources.Warning_CannotModifyDefaultSwitch : IsConnected ? string.Format(Properties.Resources.Status_ConnectedTo, SelectedUpstreamAdapter) : ExHyperV.Properties.Resources.Status_UpstreamNotConnected;
        public bool IsConnected => !string.IsNullOrEmpty(SelectedUpstreamAdapter) && (SelectedNetworkMode == "Bridge" || SelectedNetworkMode == "NAT");
        public string DropDownButtonContent => IsDefaultSwitch ? ExHyperV.Properties.Resources.Auto : SelectedNetworkMode == "Isolated" ? ExHyperV.Properties.Resources.Status_Unavailable : string.IsNullOrEmpty(SelectedUpstreamAdapter) ? ExHyperV.Properties.Resources.Placeholder_SelectNetworkAdapter : SelectedUpstreamAdapter;
        public string IconGlyph => Utils.GetIconPath("Switch", SwitchName);

        public SwitchViewModel(SwitchInfo switchInfo, INetworkService networkService, List<PhysicalAdapterInfo> allPhysicalAdapters, ObservableCollection<SwitchViewModel> allSwitchViewModels)
        {
            _networkService = networkService;
            _allPhysicalAdapters = allPhysicalAdapters;
            _allSwitchViewModels = allSwitchViewModels;

            _switchName = switchInfo.SwitchName;
            _switchId = switchInfo.Id;
            _isDefaultSwitch = _switchName == "Default Switch";

            _ = RevertTo(switchInfo);

            PropertyChanged += (s, e) =>
            {
                if (e.PropertyName == nameof(SelectedNetworkMode))
                {
                    UpdateUiLogic();
                    OnPropertyChanged(nameof(DropDownButtonContent));
                }
            };
        }

        [RelayCommand]
        private void SetNetworkMode(string? mode)
        {
            if (string.IsNullOrEmpty(mode) || SelectedNetworkMode == mode)
            {
                return;
            }
            SelectedNetworkMode = mode;
        }

        [RelayCommand]
        private void SelectUpstreamAdapter(string adapterName)
        {
            SelectedUpstreamAdapter = adapterName;
        }

        public async Task RevertTo(SwitchInfo switchInfo)
        {
            IsReverting = true;
            try
            {
                SelectedNetworkMode = GetModeFromSwitchType(switchInfo.SwitchType);
                SelectedUpstreamAdapter = switchInfo.NetAdapterInterfaceDescription;
                IsHostConnectionAllowed = bool.TryParse(switchInfo.AllowManagementOS, out var result) && result;
                if (_isDefaultSwitch) { SelectedNetworkMode = "NAT"; }
                UpdateUiLogic();
                await UpdateTopologyAsync();
            }
            finally
            {
                IsReverting = false;
            }
        }

        private void UpdateUiLogic()
        {
            IsUpstreamSelectionEnabled = (SelectedNetworkMode == "Bridge" || SelectedNetworkMode == "NAT") && !IsDefaultSwitch;
            IsHostConnectionToggleEnabled = SelectedNetworkMode == "Isolated" && !IsDefaultSwitch;
            if (!IsHostConnectionToggleEnabled && !IsDefaultSwitch)
            {
                IsHostConnectionAllowed = true;
            }
        }

        public void UpdateMenuItems()
        {
            var currentSelection = this.SelectedUpstreamAdapter;
            MenuItems.Clear();
            if (_allPhysicalAdapters == null) return;
            var allPhysicalAdapterNames = _allPhysicalAdapters.Select(p => p.InterfaceDescription).ToList();
            foreach (var name in allPhysicalAdapterNames) { MenuItems.Add(name); }
            if (!string.IsNullOrEmpty(currentSelection) && !MenuItems.Contains(currentSelection)) { MenuItems.Add(currentSelection); }
        }

        [RelayCommand]
        private async Task UpdateTopologyAsync()
        {
            if (string.IsNullOrEmpty(SwitchName)) return;
            var clients = await _networkService.GetFullSwitchNetworkStateAsync(SwitchName);
            ConnectedClients.Clear();
            foreach (var client in clients) { ConnectedClients.Add(client); }
        }

        public static string GetModeFromSwitchType(string switchType) => switchType switch
        {
            "External" => "Bridge",
            "NAT" => "NAT",
            _ => "Isolated"
        };
    }
}

================================================================================
FILE: ViewModels\VirtualMachineViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using ExHyperV.Models;
using ExHyperV.Tools;
using Wpf.Ui.Controls;


namespace ExHyperV.ViewModels
{
    public partial class VirtualMachineViewModel : ObservableObject
    {
        public VMInfo Model { get; }
        public FontIcon VmIcon { get; }

        public ObservableCollection<AssignedGpuViewModel> AssignedGpus { get; } = new();

        public VirtualMachineViewModel(VMInfo model, System.Collections.Generic.IEnumerable<HostGpuViewModel> allHostGpus)
        {
            Model = model;

            VmIcon = Utils.FontIcon(24, "\xE7F8");

            foreach (var assignedGpu in model.GPUs)
            {
                // 从所有主机GPU中，找到这个分区的“父亲”
                var parentGpu = allHostGpus.FirstOrDefault(h => h.Pname == assignedGpu.Value);

                AssignedGpus.Add(new AssignedGpuViewModel
                {
                    AdapterId = assignedGpu.Key,
                    InstancePath = assignedGpu.Value,
                    ParentGpuName = parentGpu?.Name ?? "Unknown GPU",
                    ParentGpuVendor = parentGpu?.Vendor ?? "Unknown",
                    ParentGpuManu = parentGpu?.Manu ?? "Unknown"
                });
            }
        }

        public string Name => Model.Name;

        // 计算属性，用于在XAML中判断是否应该默认展开
        public bool HasAssignedGpus => AssignedGpus.Any();
        public string VmIconGlyph => "\xE7F4";
    }
}

================================================================================
FILE: ViewModels\VMMemoryViewModel.cs
================================================================================

﻿using System.ComponentModel;
using System.Windows;
using System.Windows.Media;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Services;
using Wpf.Ui.Controls;

namespace ExHyperV.ViewModels
{
    public partial class VMMemoryViewModel : ObservableObject
    {
        private VirtualMachineMemoryInfo _originalModel;
        private readonly MemoryPageViewModel _parentViewModel;
        private readonly IMemoryService _memoryService;

        [ObservableProperty] private string _startupMB;
        [ObservableProperty] private string _minimumMB;
        [ObservableProperty] private string _maximumMB;
        [ObservableProperty] private string _buffer;
        [ObservableProperty] private int _priority;
        [ObservableProperty] private bool _dynamicMemoryEnabled;

        [ObservableProperty][NotifyPropertyChangedFor(nameof(IsDataValid))] private bool _isStartupMBValid;
        [ObservableProperty][NotifyPropertyChangedFor(nameof(IsDataValid))] private bool _isMinimumMBValid;
        [ObservableProperty][NotifyPropertyChangedFor(nameof(IsDataValid))] private bool _isMaximumMBValid;
        [ObservableProperty][NotifyPropertyChangedFor(nameof(IsDataValid))] private bool _isBufferValid;

        [ObservableProperty] private long _assignedMB;
        [ObservableProperty] private long _demandMB;
        [ObservableProperty] private string _state;
        [ObservableProperty] private string _status;

        [ObservableProperty]
        [NotifyCanExecuteChangedFor(nameof(SaveChangesCommand))]
        [NotifyCanExecuteChangedFor(nameof(RevertChangesCommand))]
        private bool _isSaving;

        public VMMemoryViewModel(VirtualMachineMemoryInfo model, MemoryPageViewModel parent, IMemoryService memoryService)
        {
            _originalModel = model;
            _parentViewModel = parent;
            _memoryService = memoryService;

            this.PropertyChanged += OnViewModelPropertyChanged;

            UpdateLiveData(model);
            RevertChanges();
        }

        public string VMName => _originalModel.VMName;
        public bool IsVmRunning => State?.Equals("Running", StringComparison.OrdinalIgnoreCase) ?? false;
        public string VmIconGlyph => "\uE7F8";
        public bool IsDataValid => IsStartupMBValid && IsMinimumMBValid && IsMaximumMBValid && IsBufferValid;

        public double UsagePercentage => IsVmRunning && AssignedMB > 0 ? Math.Min((double)DemandMB / AssignedMB * 100, 100) : 0;

        public Brush UsageBarBrush
        {
            get
            {
                if (!IsVmRunning) return Brushes.Transparent;
                double percentage = this.UsagePercentage;
                if (percentage >= 90) return (Brush)Application.Current.Resources["RedBrush"];
                if (percentage >= 70) return (Brush)Application.Current.Resources["OrangeBrush"];
                return (Brush)Application.Current.Resources["AccentFillColorDefaultBrush"];
            }
        }

        public string MemoryUsageText
        {
            get
            {
                if (IsVmRunning)
                {
                    return string.Format(
                        ExHyperV.Properties.Resources.VMMemory_UsageFormat,
                        DemandMB,
                        AssignedMB);
                }
                else
                {
                    return ExHyperV.Properties.Resources.VMMemory_Status_Off;
                }
            }
        }

        public void UpdateLiveData(VirtualMachineMemoryInfo liveData)
        {
            if (liveData == null) return;
            State = liveData.State;
            AssignedMB = liveData.AssignedMB;
            DemandMB = liveData.DemandMB;
            Status = liveData.Status;

            OnPropertyChanged(nameof(IsVmRunning));
            OnPropertyChanged(nameof(UsagePercentage));
            OnPropertyChanged(nameof(UsageBarBrush));
            OnPropertyChanged(nameof(MemoryUsageText));
        }

        public void UpdateConfiguration(VirtualMachineMemoryInfo newConfig)
        {
            if (IsDirty()) return;
            _originalModel = newConfig;
            RevertChanges();
        }

        public void MarkAsOff()
        {
            State = "Off";
            AssignedMB = 0;
            DemandMB = 0;
            Status = ExHyperV.Properties.Resources.VMMemory_Status_Off;
            OnPropertyChanged(nameof(IsVmRunning));
            OnPropertyChanged(nameof(MemoryUsageText));
        }

        private void OnViewModelPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case nameof(StartupMB):
                case nameof(MinimumMB):
                case nameof(MaximumMB):
                case nameof(Buffer):
                case nameof(DynamicMemoryEnabled):
                case nameof(Priority):
                    ValidateAllFields();
                    break;
            }
        }

        private void ValidateAllFields()
        {
            IsStartupMBValid = long.TryParse(StartupMB, out long s) && s > 0;
            IsMinimumMBValid = long.TryParse(MinimumMB, out long m) && m > 0;
            IsMaximumMBValid = long.TryParse(MaximumMB, out long x) && x > 0;
            IsBufferValid = int.TryParse(Buffer, out int b) && b >= 5 && b <= 2000;

            OnPropertyChanged(nameof(IsDataValid));
            SaveChangesCommand.NotifyCanExecuteChanged();
            RevertChangesCommand.NotifyCanExecuteChanged();
        }

        public bool IsDirty()
        {
            return StartupMB != _originalModel.StartupMB.ToString() ||
                   MinimumMB != _originalModel.MinimumMB.ToString() ||
                   MaximumMB != _originalModel.MaximumMB.ToString() ||
                   Buffer != _originalModel.Buffer.ToString() ||
                   Priority != _originalModel.Priority ||
                   DynamicMemoryEnabled != _originalModel.DynamicMemoryEnabled;
        }

        private bool FinalValidation()
        {
            long.TryParse(StartupMB, out long startup);
            long.TryParse(MinimumMB, out long min);
            long.TryParse(MaximumMB, out long max);
            if (DynamicMemoryEnabled && startup < min)
            {
                _parentViewModel.ShowSnackbar(ExHyperV.Properties.Resources.error, ExHyperV.Properties.Resources.StartupRamLessThanMinRam, ControlAppearance.Caution, SymbolRegular.Warning24);
                return false;
            }
            if (DynamicMemoryEnabled && min > max)
            {
                _parentViewModel.ShowSnackbar(ExHyperV.Properties.Resources.error, ExHyperV.Properties.Resources.MinRamGreaterThanMaxRam, ControlAppearance.Caution, SymbolRegular.Warning24);
                return false;
            }
            return true;
        }

        private bool CanExecuteModifyCommands() => IsDataValid && !IsSaving && IsDirty();

        [RelayCommand(CanExecute = nameof(CanExecuteModifyCommands))]
        private async Task SaveChangesAsync()
        {
            if (!FinalValidation()) return;

            IsSaving = true;
            _parentViewModel.IsLoading = true;

            try
            {
                long.TryParse(StartupMB, out long startup);
                long.TryParse(MinimumMB, out long min);
                long.TryParse(MaximumMB, out long max);
                int.TryParse(Buffer, out int buffer);

                var newInfo = new VirtualMachineMemoryInfo
                {
                    VMName = this.VMName,
                    StartupMB = startup,
                    MinimumMB = min,
                    MaximumMB = max,
                    Buffer = buffer,
                    Priority = this.Priority,
                    DynamicMemoryEnabled = this.DynamicMemoryEnabled
                };

                var result = await _memoryService.SetVmMemoryAsync(newInfo);
                if (result.Success)
                {
                    _originalModel = newInfo;
                    _parentViewModel.ShowSnackbar(
                        ExHyperV.Properties.Resources.success,
                        string.Format(ExHyperV.Properties.Resources.VMSettingsSavedSuccessfully, VMName),
                        ControlAppearance.Success,
                        SymbolRegular.CheckmarkCircle24);
                    ValidateAllFields();
                }
                else
                {
                    _parentViewModel.ShowSnackbar(ExHyperV.Properties.Resources.error, result.Message, ControlAppearance.Danger, SymbolRegular.ErrorCircle24);
                }
            }
            catch (Exception ex)
            {
                _parentViewModel.ShowSnackbar(
                    ExHyperV.Properties.Resources.error,
                    string.Format(ExHyperV.Properties.Resources.Error_GenericFormat, ex.Message),
                    ControlAppearance.Danger,
                    SymbolRegular.ErrorCircle24);
            }
            finally
            {
                IsSaving = false;
                _parentViewModel.IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanExecuteModifyCommands))]
        private void RevertChanges()
        {
            DynamicMemoryEnabled = _originalModel.DynamicMemoryEnabled;
            StartupMB = _originalModel.StartupMB.ToString();
            MinimumMB = _originalModel.MinimumMB.ToString();
            MaximumMB = _originalModel.MaximumMB.ToString();
            Buffer = _originalModel.Buffer.ToString();
            Priority = _originalModel.Priority;
            ValidateAllFields();
        }
    }
}

================================================================================
FILE: ViewModels\VMNetViewModel.cs
================================================================================

﻿using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using ExHyperV.Models;
using ExHyperV.Properties;
using ExHyperV.Services;
using ExHyperV.Tools;
using ExHyperV.Views;

namespace ExHyperV.ViewModels
{
    public partial class VMNetViewModel : ObservableObject
    {
        private readonly INetworkService _networkService;

        [ObservableProperty] private bool _isBusy = false;
        [ObservableProperty] private bool _isContentVisible = true;
        [ObservableProperty] private string? _errorMessage;

        public ObservableCollection<SwitchViewModel> Switches { get; } = new();

        private List<PhysicalAdapterInfo> _physicalAdapters = new();
        private List<SwitchInfo> _rawSwitchInfos = new();

        public VMNetViewModel()
        {
            _networkService = new NetworkService();
            LoadNetworkInfoCommand.Execute(null);
        }

        [RelayCommand]
        private async Task AddNewSwitchAsync()
        {
            var addSwitchVm = new AddSwitchViewModel(Switches, _physicalAdapters);
            var addSwitchView = new AddSwitchView
            {
                DataContext = addSwitchVm
            };

            var createConfirmed = await DialogManager.ShowContentDialogAsync(ExHyperV.Properties.Resources.Title_AddVirtualSwitch, addSwitchView);

            if (!createConfirmed)
            {
                return;
            }

            if (addSwitchVm.Validate())
            {
                IsBusy = true;
                try
                {
                    string typeForService = addSwitchVm.SelectedSwitchType;

                    await _networkService.CreateSwitchAsync(
                        addSwitchVm.SwitchName,
                        typeForService,
                        addSwitchVm.SelectedNetworkAdapter
                    );

                    await CoreRefreshLogicAsync();
                }
                catch (System.Exception ex)
                {
                    await DialogManager.ShowAlertAsync(ExHyperV.Properties.Resources.Error_CreationFailed, ex.Message);
                }
                finally
                {
                    IsBusy = false;
                }
            }
            else
            {
                await DialogManager.ShowAlertAsync(ExHyperV.Properties.Resources.Validation_InputInvalid, addSwitchVm.ErrorMessage ?? Resources.Error_Unknown);
            }
        }
        [RelayCommand]
        private async Task DeleteSwitchAsync(SwitchViewModel? switchToDelete)
        {
            if (switchToDelete == null || switchToDelete.IsDefaultSwitch)
            {
                return;
            }

            IsBusy = true;
            try
            {
                await _networkService.DeleteSwitchAsync(switchToDelete.SwitchName);
                await CoreRefreshLogicAsync();
            }
            catch (System.Exception ex)
            {
                await DialogManager.ShowAlertAsync(ExHyperV.Properties.Resources.Error_DeletionFailed, ex.Message);
            }
            finally
            {
                IsBusy = false;
            }
        }


        [RelayCommand]
        private async Task LoadNetworkInfoAsync()
        {
            if (IsBusy) return;

            IsBusy = true;
            try
            {
                await CoreRefreshLogicAsync();
            }
            finally
            {
                IsBusy = false;
            }
        }

        private async Task CoreRefreshLogicAsync()
        {
            ErrorMessage = null;
            IsContentVisible = false;
            Switches.Clear();

            try
            {
                var (switches, adapters) = await _networkService.GetNetworkInfoAsync();
                _rawSwitchInfos = switches;
                _physicalAdapters = adapters;

                if (!_rawSwitchInfos.Any())
                {
                    ErrorMessage = ExHyperV.Properties.Resources.Info_NoSwitchesFound;
                }
                else
                {
                    foreach (var switchInfo in _rawSwitchInfos)
                    {
                        var switchVm = new SwitchViewModel(switchInfo, _networkService, _physicalAdapters, Switches);
                        switchVm.PropertyChanged += OnSwitchViewModelPropertyChanged;
                        Switches.Add(switchVm);
                    }
                    UpdateAllSwitchMenus();
                    IsContentVisible = true;
                }
            }
            catch (Exception ex)
            {
                ErrorMessage = string.Format(Properties.Resources.Error_LoadNetworkInfoFailed, ex.Message);
                await DialogManager.ShowAlertAsync(Resources.error, ErrorMessage);
            }
        }

        private async void OnSwitchViewModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (sender is not SwitchViewModel changedSwitch) return;

            if (changedSwitch.IsReverting || changedSwitch.IsLockedForInteraction) return;

            if (e.PropertyName == nameof(SwitchViewModel.SelectedNetworkMode) ||
                e.PropertyName == nameof(SwitchViewModel.SelectedUpstreamAdapter) ||
                e.PropertyName == nameof(SwitchViewModel.IsHostConnectionAllowed))
            {
                changedSwitch.IsLockedForInteraction = true;
                try
                {
                    await ApplyConfigurationChange(changedSwitch);
                }
                finally
                {
                    changedSwitch.IsLockedForInteraction = false;
                }
            }
        }

        private async Task ApplyConfigurationChange(SwitchViewModel changedSwitch)
        {
            var originalSwitchInfo = _rawSwitchInfos.FirstOrDefault(s => s.Id == changedSwitch.SwitchId);
            if (originalSwitchInfo == null) return;

            if (changedSwitch.SelectedNetworkMode == "NAT")
            {
                var otherNatSwitch = Switches.FirstOrDefault(s => s.SwitchId != changedSwitch.SwitchId && !s.IsDefaultSwitch && s.SelectedNetworkMode == "NAT");
                if (otherNatSwitch != null)
                {
                    await DialogManager.ShowAlertAsync(ExHyperV.Properties.Resources.Error_ConfigurationConflict, string.Format(Properties.Resources.Error_OnlyOneNatNetworkAllowed, otherNatSwitch.SwitchName));
                    await changedSwitch.RevertTo(originalSwitchInfo);
                    return;
                }
            }

            if ((changedSwitch.SelectedNetworkMode == "Bridge" || changedSwitch.SelectedNetworkMode == "NAT") && !string.IsNullOrEmpty(changedSwitch.SelectedUpstreamAdapter))
            {
                var conflictingSwitch = Switches.FirstOrDefault(s => s.SwitchId != changedSwitch.SwitchId && !string.IsNullOrEmpty(s.SelectedUpstreamAdapter) && s.SelectedUpstreamAdapter == changedSwitch.SelectedUpstreamAdapter);
                if (conflictingSwitch != null)
                {
                    await DialogManager.ShowAlertAsync(ExHyperV.Properties.Resources.Error_ConfigurationConflict, string.Format(Properties.Resources.Error_PhysicalAdapterInUse, changedSwitch.SelectedUpstreamAdapter, conflictingSwitch.SwitchName));
                    await changedSwitch.RevertTo(originalSwitchInfo);
                    return;
                }
            }

            if ((changedSwitch.SelectedNetworkMode == "Bridge" || changedSwitch.SelectedNetworkMode == "NAT") && string.IsNullOrEmpty(changedSwitch.SelectedUpstreamAdapter))
            {
                return;
            }

            IsBusy = true;
            try
            {
                await _networkService.UpdateSwitchConfigurationAsync(
                    changedSwitch.SwitchName,
                    changedSwitch.SelectedNetworkMode,
                    changedSwitch.SelectedUpstreamAdapter,
                    changedSwitch.IsHostConnectionAllowed,
                    false
                );

                await RefreshDataModels();
                UpdateAllSwitchMenus();
            }
            catch (Exception ex)
            {
                await DialogManager.ShowAlertAsync(ExHyperV.Properties.Resources.UpdateFailed, string.Format(Properties.Resources.Error_UpdateSwitchConfigFailed, changedSwitch.SwitchName, ex.InnerException?.Message ?? ex.Message));
                await RefreshDataModels();
                UpdateAllSwitchMenus();
            }
            finally
            {
                IsBusy = false;
            }
        }

        private async Task RefreshDataModels()
        {
            var (switches, adapters) = await _networkService.GetNetworkInfoAsync();
            _rawSwitchInfos = switches;
            _physicalAdapters = adapters;

            var updateTasks = new List<Task>();
            foreach (var vm in Switches)
            {
                var latestInfo = _rawSwitchInfos.FirstOrDefault(s => s.Id == vm.SwitchId);
                if (latestInfo != null)
                {
                    updateTasks.Add(vm.RevertTo(latestInfo));
                }
            }
            await Task.WhenAll(updateTasks);
        }

        private void UpdateAllSwitchMenus()
        {
            foreach (var vm in Switches)
            {
                vm.UpdateMenuItems();
            }
        }
    }
}

================================================================================
FILE: ViewModels\VMProcessorViewModel.cs
================================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;
using System;
using System.Runtime.CompilerServices;

namespace ExHyperV.ViewModels
{
    public enum SmtMode
    {
        Inherit,
        SingleThread,
        MultiThread
    }

    public partial class VMProcessorViewModel : ObservableObject
    {
        public Action<string> InstantApplyAction { get; set; }

        [ObservableProperty]
        private long _count;

        [ObservableProperty]
        private int _relativeWeight;

        [ObservableProperty]
        private long _reserve;

        [ObservableProperty]
        private long _maximum;

        [ObservableProperty]
        private SmtMode _smtMode;
        partial void OnSmtModeChanged(SmtMode value) => OnInstantPropertyChanged();

        [ObservableProperty]
        private bool _exposeVirtualizationExtensions;
        partial void OnExposeVirtualizationExtensionsChanged(bool value) => OnInstantPropertyChanged();

        [ObservableProperty]
        private bool _enableHostResourceProtection;
        partial void OnEnableHostResourceProtectionChanged(bool value) => OnInstantPropertyChanged();

        [ObservableProperty]
        private bool _compatibilityForMigrationEnabled;
        partial void OnCompatibilityForMigrationEnabledChanged(bool value) => OnInstantPropertyChanged();

        [ObservableProperty]
        private bool _compatibilityForOlderOperatingSystemsEnabled;
        partial void OnCompatibilityForOlderOperatingSystemsEnabledChanged(bool value) => OnInstantPropertyChanged();

        private void OnInstantPropertyChanged([CallerMemberName] string propertyName = null)
        {
            if (propertyName != null)
            {
                var finalPropertyName = propertyName.Replace("Changed", "");
                InstantApplyAction?.Invoke(finalPropertyName);
            }
        }

        public VMProcessorViewModel CreateCopy()
        {
            return (VMProcessorViewModel)this.MemberwiseClone();
        }

        public void Restore(VMProcessorViewModel source)
        {
            if (source == null) return;

            Count = source.Count;
            RelativeWeight = source.RelativeWeight;
            Reserve = source.Reserve;
            Maximum = source.Maximum;

            bool oldSmt = _smtMode != source._smtMode;
            if (oldSmt) { _smtMode = source._smtMode; OnPropertyChanged(nameof(SmtMode)); }

            bool oldExpose = _exposeVirtualizationExtensions != source._exposeVirtualizationExtensions;
            if (oldExpose) { _exposeVirtualizationExtensions = source._exposeVirtualizationExtensions; OnPropertyChanged(nameof(ExposeVirtualizationExtensions)); }

            bool oldEnable = _enableHostResourceProtection != source._enableHostResourceProtection;
            if (oldEnable) { _enableHostResourceProtection = source._enableHostResourceProtection; OnPropertyChanged(nameof(EnableHostResourceProtection)); }

            bool oldCompat = _compatibilityForMigrationEnabled != source._compatibilityForMigrationEnabled;
            if (oldCompat) { _compatibilityForMigrationEnabled = source._compatibilityForMigrationEnabled; OnPropertyChanged(nameof(CompatibilityForMigrationEnabled)); }

            bool oldCompatOs = _compatibilityForOlderOperatingSystemsEnabled != source._compatibilityForOlderOperatingSystemsEnabled;
            if (oldCompatOs) { _compatibilityForOlderOperatingSystemsEnabled = source._compatibilityForOlderOperatingSystemsEnabled; OnPropertyChanged(nameof(CompatibilityForOlderOperatingSystemsEnabled)); }
        }
    }
}

================================================================================
FILE: Views\AddSwitchView.xaml.cs
================================================================================

﻿using System.Windows.Controls;

namespace ExHyperV.Views
{
    public partial class AddSwitchView : UserControl
    {
        public AddSwitchView()
        {
            InitializeComponent();
        }
    }
}

================================================================================
FILE: Views\ChooseDiskWindow.xaml.cs
================================================================================

﻿using ExHyperV.Models;
using ExHyperV.ViewModels;
using System.Windows;

namespace ExHyperV.Views
{
    public partial class ChooseDiskWindow
    {
        public AddDiskViewModel ViewModel => (AddDiskViewModel)DataContext;

        public ChooseDiskWindow(string vmName, int generation, bool isVmRunning, List<VmStorageControllerInfo> currentStorage)
        {
            InitializeComponent();
            DataContext = new AddDiskViewModel(vmName, generation, isVmRunning, currentStorage);
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}

================================================================================
FILE: Views\ChooseGPUWindow.xaml.cs
================================================================================

﻿using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Controls;
using ExHyperV.Models;
using ExHyperV.Tools;
using Wpf.Ui.Controls;

namespace ExHyperV.Views
{
    public partial class ChooseGPUWindow : FluentWindow
    {
        public string Machinename { get; private set; }
        public bool IsSimpleMode { get; private set; }
        public ObservableCollection<GpuChoice> Items { get; } = new();
        public GpuChoice SelectedGpu { get; private set; }
        public ChooseGPUWindow(string vmname, List<GPUInfo> hostGpuList)
        {
            Machinename = vmname;
            this.WindowStartupLocation = WindowStartupLocation.CenterScreen;
            InitializeComponent();
            this.DataContext = this;
            var availableGpus = hostGpuList.Where(gpu => !string.IsNullOrEmpty(gpu.Pname));
            foreach (var gpu in availableGpus)
            {
                Items.Add(new GpuChoice
                {
                    GPUname = gpu.Name,
                    Path = gpu.Pname,
                    Iconpath = Utils.GetGpuImagePath(gpu.Manu, gpu.Name),
                    Manu = gpu.Manu,
                    Id = gpu.InstanceId
                });
            }
        }
        public class GpuChoice
        {
            public string GPUname { get; set; }
            public string Path { get; set; }
            public string Iconpath { get; set; }
            public string Manu { get; set; }
            public string Id { get; set; }
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
            this.Close();
        }
        private void ConfirmButton_Click(object sender, RoutedEventArgs e)
        {
            if (GpuListView.SelectedItem is GpuChoice selectedGpu)
            {
                this.SelectedGpu = selectedGpu;
                this.IsSimpleMode = SimpleModeCheckBox.IsChecked ?? false;
                this.DialogResult = true;
                this.Close();
            }
        }
        private void ListView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            ConfirmButton.IsEnabled = (sender as Wpf.Ui.Controls.ListView)?.SelectedItem != null;
        }
    }
}

================================================================================
FILE: Views\ChoosePartitionWindow.xaml.cs
================================================================================

﻿using System.Windows;
using System.Windows.Controls;
using Wpf.Ui.Controls; 

namespace ExHyperV.Views
{
    public partial class ChoosePartitionWindow : FluentWindow
    {
        public PartitionInfo SelectedPartition { get; private set; }
        public ChoosePartitionWindow(List<PartitionInfo> partitions)
        {
            InitializeComponent();
            PartitionListView.ItemsSource = partitions;
        }

        private void ListView_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (PartitionListView.SelectedItem is PartitionInfo selected)
            {
                SelectedPartition = selected;
                ConfirmButton.IsEnabled = true;
            }
            else
            {
                ConfirmButton.IsEnabled = false;
            }
        }

        private void ConfirmButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
            this.Close();
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
            this.Close();
        }
    }
}

================================================================================
FILE: Views\CpuAffinityDialog.xaml.cs
================================================================================

﻿using ExHyperV.ViewModels.Dialogs;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;

namespace ExHyperV.Views.Dialogs
{
    public partial class CpuAffinityDialog
    {
        private bool _isDragging = false;
        private SelectableCoreViewModel _lastToggledCore = null;

        public CpuAffinityDialog()
        {
            InitializeComponent();
        }

        private void ConfirmButton_Click(object sender, RoutedEventArgs e) { this.DialogResult = true; this.Close(); }
        private void CancelButton_Click(object sender, RoutedEventArgs e) { this.DialogResult = false; this.Close(); }

        private void ItemsControl_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _isDragging = false;
            _lastToggledCore = null;
            (sender as IInputElement)?.CaptureMouse();
        }

        private void ItemsControl_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed)
            {
                _isDragging = true;

                var core = GetCoreFromPosition(e.GetPosition(CoresItemsControl));
                if (core != null && _lastToggledCore != core)
                {
                    core.IsSelected = !core.IsSelected;
                    _lastToggledCore = core;
                }
            }
        }

        private void ItemsControl_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (!_isDragging)
            {
                var core = GetCoreFromPosition(e.GetPosition(CoresItemsControl));
                if (core != null)
                {
                    core.IsSelected = !core.IsSelected;
                }
            }
            _isDragging = false;
            _lastToggledCore = null;
            (sender as IInputElement)?.ReleaseMouseCapture();
        }

        private SelectableCoreViewModel GetCoreFromPosition(Point position)
        {
            var hitTestResult = VisualTreeHelper.HitTest(CoresItemsControl, position);
            if (hitTestResult == null) return null;

            DependencyObject current = hitTestResult.VisualHit;
            while (current != null && !(current is ContentPresenter))
            {
                current = VisualTreeHelper.GetParent(current);
            }

            if (current is ContentPresenter contentPresenter)
            {
                return contentPresenter.DataContext as SelectableCoreViewModel;
            }
            return null;
        }
    }
}

================================================================================
FILE: Views\CpuPage.xaml.cs
================================================================================

﻿using ExHyperV.ViewModels;
using System.Windows;
using System.Windows.Controls;

namespace ExHyperV.Views.Pages
{
    public partial class CpuPage : Page
    {
        public CpuPage()
        {
            InitializeComponent();
            DataContext = CpuPageViewModel.Instance;
            this.SizeChanged += CpuPage_SizeChanged;
        }

        private void CpuPage_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            Dispatcher.BeginInvoke(new Action(() => this.InvalidateMeasure()),
                System.Windows.Threading.DispatcherPriority.Background);
        }
    }
}

================================================================================
FILE: Views\DDAPage.xaml.cs
================================================================================

﻿using System.Windows.Controls;

namespace ExHyperV.Views.Pages
{
    public partial class DDAPage : Page
    {
        public DDAPage()
        {
            InitializeComponent();
        }
    }
}

================================================================================
FILE: Views\GPUPage.xaml.cs
================================================================================

﻿using System.Windows.Controls;
using ExHyperV.ViewModels;

namespace ExHyperV.Views.Pages
{
    public partial class GPUPage : Page
    {
        public GPUPage()
        {
            InitializeComponent();
            this.DataContext = new GPUPageViewModel();
        }
    }
}

================================================================================
FILE: Views\InstancesPage.xaml.cs
================================================================================

﻿using System.Windows.Controls;
using ExHyperV.ViewModels;
using ExHyperV.Services;

namespace ExHyperV.Views.Pages
{
    public partial class InstancesPage : Page
    {
        public InstancesPage()
        {
            InitializeComponent();
            this.DataContext = new InstancesPageViewModel(new InstancesService());
        }
    }
}

================================================================================
FILE: Views\MainPage.xaml.cs
================================================================================

﻿using ExHyperV.ViewModels;

namespace ExHyperV.Views.Pages
{
    public partial class MainPage
    {
        public MainPage()
        {
            InitializeComponent();
            this.DataContext = new MainPageViewModel();
        }
    }
}

================================================================================
FILE: Views\MemoryPage.xaml.cs
================================================================================

﻿using ExHyperV.ViewModels;
using System.Windows.Controls;

namespace ExHyperV.Views.Pages
{
    public partial class MemoryPage : Page
    {
        public MemoryPage()
        {
            InitializeComponent();
            DataContext = MemoryPageViewModel.Instance;

            Loaded += (s, e) =>
            {
                MemoryPageViewModel.Instance.StartTimer();
            };

            Unloaded += (s, e) =>
            {
                MemoryPageViewModel.Instance.StopTimer();
            };
        }
    }
}

================================================================================
FILE: Views\ProgressWindow.xaml.cs
================================================================================

﻿using System.Windows;
using System.Windows.Controls;
using Wpf.Ui.Controls;

namespace ExHyperV.Views
{
    public partial class ExecutionProgressWindow : FluentWindow
    {
        public event EventHandler RetryClicked;
        private bool _autoScroll = true;
        public ExecutionProgressWindow() => InitializeComponent();
        private void LogTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (_autoScroll)
            {
                LogScrollViewer.ScrollToEnd();
            }
        }
        private void LogScrollViewer_ScrollChanged(object sender, ScrollChangedEventArgs e)
        {
            if (e.ExtentHeightChange == 0)
            {
                _autoScroll = LogScrollViewer.VerticalOffset == LogScrollViewer.ScrollableHeight;
            }
        }
        private void SafeInvoke(Action action)
        {
            try
            {
                Dispatcher.Invoke(action);
            }
            catch
            {
            }
        }

        public void AppendLog(string text) => SafeInvoke(() =>
        {
            LogTextBox.AppendText(text + "\n");
            LogTextBox.ScrollToEnd();
        });

        public void UpdateStatus(string status) => SafeInvoke(() =>
        {
            StatusTextBlock.Text = status;
        });

        public void ShowSuccessState() => SafeInvoke(() =>
        {
            UpdateStatus(ExHyperV.Properties.Resources.Status_DeploymentComplete);
            RetryButton.Visibility = Visibility.Collapsed;
            CloseButton.IsEnabled = true;
        });

        public void ShowErrorState(string errorMessage) => SafeInvoke(() =>
        {
            UpdateStatus(string.Format(Properties.Resources.Error_AnErrorOccurred, errorMessage));
            RetryButton.Visibility = Visibility.Visible;
            CloseButton.IsEnabled = true;
        });

        public void ResetForRetry() => SafeInvoke(() =>
        {
            LogTextBox.Clear();
            AppendLog(ExHyperV.Properties.Resources.Log_UserRetryingDeployment);
            RetryButton.Visibility = Visibility.Collapsed;
            CloseButton.IsEnabled = false;
            _autoScroll = true;
        });

        private void CloseButton_Click(object sender, RoutedEventArgs e) => Close();

        private void RetryButton_Click(object sender, RoutedEventArgs e) => RetryClicked?.Invoke(this, EventArgs.Empty);
    }
}

================================================================================
FILE: Views\Setting.xaml.cs
================================================================================

﻿using ExHyperV.ViewModels;

namespace ExHyperV.Views.Pages
{
    public partial class Setting
    {
        public Setting()
        {
            InitializeComponent();
            DataContext = new SettingsViewModel();
        }
    }
}

================================================================================
FILE: Views\ShutdownConfirmationDialog.xaml.cs
================================================================================

﻿using System.Windows;
using Wpf.Ui.Controls;

namespace ExHyperV.Views
{
    public enum ShutdownChoice
    {
        Cancel,
        ShutdownAndContinue
    }

    public partial class ShutdownConfirmationDialog : FluentWindow
    {
        public ShutdownChoice UserChoice { get; private set; } = ShutdownChoice.Cancel;

        public ShutdownConfirmationDialog(string vmName)
        {
            InitializeComponent();
            MessageTextBlock.Text = string.Format(Properties.Resources.Confirm_ShutdownMessage, vmName);
        }

        private void ConfirmButton_Click(object sender, RoutedEventArgs e)
        {
            UserChoice = ShutdownChoice.ShutdownAndContinue;
            this.DialogResult = true;
            this.Close();
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            UserChoice = ShutdownChoice.Cancel;
            this.DialogResult = false;
            this.Close();
        }
    }
}

================================================================================
FILE: Views\SshLoginWindow.xaml.cs
================================================================================

﻿using ExHyperV.Models;
using System.Windows;
using Wpf.Ui.Controls;
using Renci.SshNet;

namespace ExHyperV.Views
{
    public partial class SshLoginWindow : FluentWindow
    {
        public SshCredentials Credentials { get; private set; }

        public SshLoginWindow()
        {
            InitializeComponent();
            Credentials = new SshCredentials();
            UsernameTextBox.Text = "root";
            PortTextBox.Text = "22";
        }

        public SshLoginWindow(string vmName, string ipAddress) : this()
        {
            string title = string.Format(Properties.Resources.Title_ConnectingToVm, vmName);
            TitleTextBlock.Text = title;
            Title = title;

            if (!string.IsNullOrWhiteSpace(ipAddress))
            {
                HostTextBox.Text = ipAddress;
            }
            else
            {
                Loaded += (s, e) => HostTextBox.Focus();
            }
        }

        private async void ConfirmButton_Click(object sender, RoutedEventArgs e)
        {
            ErrorTextBlock.Text = string.Empty;

            if (string.IsNullOrWhiteSpace(HostTextBox.Text))
            {
                ErrorTextBlock.Text = ExHyperV.Properties.Resources.Validation_HostIpCannotBeEmpty;
                return;
            }

            if (!int.TryParse(PortTextBox.Text, out int sshPort) || sshPort <= 0 || sshPort > 65535)
            {
                ErrorTextBlock.Text = ExHyperV.Properties.Resources.Validation_InvalidSshPort;
                return;
            }

            if (string.IsNullOrWhiteSpace(UsernameTextBox.Text))
            {
                ErrorTextBlock.Text = ExHyperV.Properties.Resources.Validation_UsernameCannotBeEmpty;
                return;
            }

            string proxyHost = ProxyHostTextBox.Text.Trim();
            string proxyPortStr = ProxyPortTextBox.Text.Trim();
            int? proxyPort = null;

            if (!string.IsNullOrEmpty(proxyHost) || !string.IsNullOrEmpty(proxyPortStr))
            {
                if (string.IsNullOrEmpty(proxyHost) || string.IsNullOrEmpty(proxyPortStr))
                {
                    ErrorTextBlock.Text = ExHyperV.Properties.Resources.Validation_ProxyIpAndPortMismatch;
                    return;
                }

                if (int.TryParse(proxyPortStr, out int port) && port > 0 && port < 65536)
                {
                    proxyPort = port;
                }
                else
                {
                    ErrorTextBlock.Text = ExHyperV.Properties.Resources.Validation_InvalidProxyPort;
                    return;
                }
            }

            ConfirmButton.IsEnabled = false;
            ConfirmButton.Content = ExHyperV.Properties.Resources.Status_Connecting;

            Credentials.Host = HostTextBox.Text.Trim();
            Credentials.Port = sshPort;
            Credentials.Username = UsernameTextBox.Text.Trim();
            Credentials.Password = PasswordBox.Password;
            Credentials.ProxyHost = proxyHost;
            Credentials.ProxyPort = proxyPort;
            Credentials.InstallGraphics = GraphicsCheckBox.IsChecked ?? false;

            try
            {
                await Task.Run(() =>
                {
                    using var client = new SshClient(Credentials.Host, Credentials.Port, Credentials.Username, Credentials.Password);
                    client.ConnectionInfo.Timeout = TimeSpan.FromSeconds(5);
                    client.Connect();
                    client.Disconnect();
                });

                DialogResult = true;
                Close();
            }
            catch (System.Net.Sockets.SocketException)
            {
                ErrorTextBlock.Text = string.Format(Properties.Resources.Error_ConnectionFailed, Credentials.Host, Credentials.Port);
            }
            catch (Renci.SshNet.Common.SshOperationTimeoutException)
            {
                ErrorTextBlock.Text = string.Format(Properties.Resources.Error_ConnectionTimedOut, Credentials.Host, Credentials.Port);
            }
            catch (Renci.SshNet.Common.SshAuthenticationException)
            {
                ErrorTextBlock.Text = ExHyperV.Properties.Resources.Error_AuthenticationFailed;
            }
            catch (Exception ex)
            {
                ErrorTextBlock.Text = string.Format(Properties.Resources.Error_UnknownConnectionError, ex.Message);
            }
            finally
            {
                ConfirmButton.IsEnabled = true;
                ConfirmButton.Content = Properties.Resources.Button_Connect;
            }
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}

================================================================================
FILE: Views\StatusPage.xaml.cs
================================================================================

﻿using System.Windows.Controls;
using ExHyperV.ViewModels;

namespace ExHyperV.Views.Pages
{
    public partial class StatusPage : Page
    {
        public StatusPage()
        {
            InitializeComponent();
            this.DataContext = new StatusPageViewModel();
        }
    }
}

================================================================================
FILE: Views\StoragePage.xaml.cs
================================================================================

﻿using ExHyperV.ViewModels;
using System.Windows.Controls;

namespace ExHyperV.Views.Pages
{
    public partial class StoragePage : Page
    {
        public StoragePage()
        {
            InitializeComponent();
            DataContext = StoragePageViewModel.Instance;
        }
    }
}

================================================================================
FILE: Views\VMNetPage.xaml.cs
================================================================================

﻿using System.Windows.Controls;
using ExHyperV.ViewModels;

namespace ExHyperV.Views.Pages
{
    public partial class VMNetPage : Page
    {
        public VMNetPage()
        {
            InitializeComponent();
            DataContext = new VMNetViewModel();
        }
    }
}
